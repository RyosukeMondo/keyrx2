# Tasks Document

## Phase 1: Utility Extraction (Foundation)

- [x] 1. Extract time formatting utilities to shared module
  - File: keyrx_ui/src/utils/timeFormatting.ts
  - Extract formatTimestampMs, formatTimestampRelative, formatDuration from ProfileCard.tsx, MacroRecorderPage.tsx, EventTimeline.tsx
  - Create comprehensive unit tests with edge cases
  - Purpose: Eliminate duplication of timestamp formatting logic across 3+ components
  - _Leverage: Existing implementations in ProfileCard.tsx:21-38, MacroRecorderPage.tsx:33-40, EventTimeline.tsx:27-32_
  - _Requirements: 4.2, 4.3_
  - _Prompt: Role: Frontend Utility Developer specializing in TypeScript and pure functions | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Extract time formatting logic from ProfileCard.tsx (lines 21-38), MacroRecorderPage.tsx (lines 33-40), and EventTimeline.tsx (lines 27-32) into a new shared utility module at keyrx_ui/src/utils/timeFormatting.ts. Provide three functions: formatTimestampMs (microseconds to ms/s string), formatTimestampRelative (timestamp to relative time like "2 hours ago"), and formatDuration (duration in ms to human-readable string). All functions must be pure with no side effects. Create comprehensive unit tests in timeFormatting.test.ts covering edge cases: zero values, negative values, very large values, and typical use cases. After implementation, update ProfileCard.tsx, MacroRecorderPage.tsx, and EventTimeline.tsx to import and use the new utility functions. | Restrictions: Do not add external dependencies; functions must be pure (no I/O, no state); maintain exact output format from original implementations; do not modify component behavior, only extract utilities; ensure tree-shakeable exports | Success: All three functions exported and tested with ≥90% coverage; original components updated to use new utilities; all existing tests still pass; no duplication remains in source files; TypeScript compilation succeeds with no new errors or warnings | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (components, functions, integrations), (4) Mark this task as complete [x] in tasks.md_

- [x] 2. Extract key code mapping utilities to shared module
  - File: keyrx_ui/src/utils/keyCodeMapping.ts
  - Extract formatKeyCode, keyCodeToLabel, parseKeyCode from MacroRecorderPage.tsx and other components
  - Create comprehensive unit tests with all key code ranges
  - Purpose: Centralize key code translation logic used across multiple components
  - _Leverage: Existing implementations in MacroRecorderPage.tsx:42-65_
  - _Requirements: 4.2, 4.3_
  - _Prompt: Role: Frontend Utility Developer specializing in keyboard input and TypeScript | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Extract key code mapping logic from MacroRecorderPage.tsx (lines 42-65) and any other components that format key codes into a new shared utility module at keyrx_ui/src/utils/keyCodeMapping.ts. Provide three functions: formatKeyCode (numeric code to formatted string), keyCodeToLabel (code to human-readable label like "A", "Enter"), and parseKeyCode (label string to numeric code or null). Support all standard key codes (0-255). Create comprehensive unit tests in keyCodeMapping.test.ts covering: all printable characters, special keys (Enter, Escape, arrows), modifier keys (Shift, Ctrl, Alt), unknown codes, and edge cases. After implementation, update MacroRecorderPage.tsx and any other components to import and use the new utility. | Restrictions: No external dependencies; functions must be pure; maintain exact label format from original implementations; ensure consistent naming (e.g., "Enter" not "Return"); do not modify component behavior | Success: All three functions exported and tested with ≥90% coverage; components updated to use new utilities; all existing tests pass; no duplication remains; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (functions with signatures and locations), (4) Mark this task as complete [x] in tasks.md_

- [x] 3. Create CLI common output module for Rust
  - File: keyrx_daemon/src/cli/common.rs
  - Implement output_success, output_error, output_list functions with JSON and text formatting
  - Create unit tests for all output formats
  - Purpose: Eliminate JSON output duplication across config.rs, profiles.rs, layers.rs, devices.rs
  - _Leverage: Existing patterns from config.rs:177-189, profiles.rs similar sections_
  - _Requirements: 4.1, 4.4_
  - _Prompt: Role: Rust Backend Developer specializing in CLI tools and serialization | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create a new common output module at keyrx_daemon/src/cli/common.rs that centralizes JSON and text output formatting for all CLI commands. Extract the duplicated OutputError struct and output_error function from config.rs (lines 177-189) and profiles.rs. Implement three public functions: output_success<T: Serialize>(data: T, json: bool) for successful results, output_error(message: &str, code: u32, json: bool) for errors, and output_list<T: Serialize>(items: Vec<T>, json: bool) for list responses. When json=true, output valid JSON to stdout; when json=false, output human-readable text to stderr for errors or stdout for success. Add comprehensive unit tests in the same file using #[cfg(test)] mod tests covering both JSON and text modes, empty data, large data sets, special characters, and error scenarios. | Restrictions: Must follow Rust API guidelines; use serde for JSON serialization; do not modify existing CLI command behavior; ensure output is identical to current format; follow existing error code conventions; maintain backward compatibility | Success: Module compiles without warnings; all three functions exported and tested with ≥90% coverage; JSON output is valid and parseable; text output matches existing format; no functionality changes in CLI commands; ready for integration in next tasks | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (functions, classes if any, file created), (4) Mark this task as complete [x] in tasks.md_

- [ ] 4. Create test utilities module for React components
  - File: keyrx_ui/tests/testUtils.ts
  - Implement renderWithProviders, createMockStore, waitForAsync helpers
  - Purpose: Provide shared test infrastructure for new component tests
  - _Leverage: Patterns from ProfilesPage.test.tsx, VirtualKeyboard.test.tsx_
  - _Requirements: 2.10_
  - _Prompt: Role: Frontend Test Engineer specializing in React Testing Library and test infrastructure | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create a shared test utilities module at keyrx_ui/tests/testUtils.ts by extracting common patterns from ProfilesPage.test.tsx and VirtualKeyboard.test.tsx. Implement renderWithProviders(ui: ReactElement, options?: RenderOptions) that wraps components with necessary providers (Zustand, ApiContext), createMockStore(initialState?: Partial<ConfigState>) that creates a mock Zustand store with optional initial state, and waitForAsync(callback: () => void, timeout?: number) that waits for async operations with configurable timeout. Export any common mock data or fixtures. Create unit tests in testUtils.test.ts verifying helper functions work correctly. Document each function with JSDoc comments explaining parameters and usage examples. | Restrictions: Do not add new external dependencies beyond @testing-library/react and Zustand; functions must be reusable across all component tests; maintain compatibility with existing test patterns; do not modify existing test files yet | Success: All helper functions exported and documented; renderWithProviders supports custom providers and options; createMockStore creates functional mock stores; waitForAsync handles timeouts correctly; tests verify helper functionality; TypeScript compilation succeeds; ready for use in subsequent test creation tasks | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (functions with signatures), (4) Mark this task as complete [x] in tasks.md_

## Phase 2: File Size Refactoring

- [ ] 5. Refactor profile_manager.rs to comply with 500-line limit
  - Files: keyrx_daemon/src/config/profile_manager.rs, keyrx_daemon/src/config/profile_compiler.rs (new)
  - Extract compilation logic (lines 200-350) to profile_compiler.rs
  - Maintain all existing tests and functionality
  - Purpose: Reduce profile_manager.rs from 1035 lines to <500 lines
  - _Leverage: Existing test patterns in profile_manager.rs:800-1035_
  - _Requirements: 1.1, 1.6, 1.7_
  - _Prompt: Role: Rust Systems Developer specializing in code refactoring and modular design | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Refactor keyrx_daemon/src/config/profile_manager.rs (currently 1035 lines) to comply with the 500-line limit by extracting compilation logic to a new module. Create keyrx_daemon/src/config/profile_compiler.rs containing ProfileCompiler struct with methods: compile_profile(source: &Path, output: &Path) -> Result<()> and validate_config(path: &Path) -> Result<()>. Extract lines approximately 200-350 from profile_manager.rs (compilation and validation logic) to the new module. Update profile_manager.rs to import and use ProfileCompiler. Ensure all 73 existing unit tests continue to pass without modification. Verify no new clippy warnings or rustfmt issues. Update module exports in profile_manager.rs to maintain public API compatibility. | Restrictions: Must maintain backward compatibility for public APIs; do not modify test files; preserve all existing functionality; follow Single Responsibility Principle (manager handles profiles, compiler handles compilation); ensure both files <500 lines; follow Rust naming conventions | Success: profile_manager.rs ≤500 lines; profile_compiler.rs created and ≤300 lines; all 73 existing tests pass; cargo clippy passes with no warnings; cargo fmt check passes; public API unchanged; compilation succeeds; no performance regression | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (classes, methods, files created/modified), (4) Mark this task as complete [x] in tasks.md_

- [ ] 6. Refactor config.rs to comply with 500-line limit using common module
  - File: keyrx_daemon/src/cli/config.rs
  - Replace duplicated output logic with calls to cli/common.rs functions
  - Reduce from 893 lines to <500 lines
  - Purpose: Eliminate duplication and reduce file size
  - _Leverage: cli/common.rs from task 3_
  - _Requirements: 1.2, 1.6, 1.7_
  - _Prompt: Role: Rust CLI Developer specializing in command-line tools and refactoring | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Refactor keyrx_daemon/src/cli/config.rs (currently 893 lines) to use the common output module created in task 3. Replace all duplicated JSON and text output logic with calls to cli/common::output_success, cli/common::output_error, and cli/common::output_list. Remove the local OutputError struct and output_error function (lines approximately 177-189). Update all 8 handler functions to use the common output functions. Verify the CLI behavior is identical before and after refactoring by running integration tests. The file should be reduced to <500 lines after eliminating duplication. Ensure clippy and rustfmt pass. | Restrictions: Must maintain identical CLI output format; do not change command-line arguments or behavior; preserve all error codes; follow existing error handling patterns; ensure backward compatibility for users and scripts; do not modify test expectations | Success: config.rs ≤500 lines (excluding comments/blanks); all handler functions use common output module; no duplicated output logic remains; all CLI integration tests pass; cargo clippy passes; cargo fmt check passes; CLI behavior unchanged; compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (functions modified, integrations), (4) Mark this task as complete [x] in tasks.md_

- [ ] 7. Refactor profiles.rs to comply with 500-line limit using common module
  - File: keyrx_daemon/src/cli/profiles.rs
  - Replace duplicated output logic with calls to cli/common.rs functions
  - Reduce from 589 lines to <500 lines
  - Purpose: Eliminate duplication and reduce file size
  - _Leverage: cli/common.rs from task 3_
  - _Requirements: 1.3, 1.6, 1.7_
  - _Prompt: Role: Rust CLI Developer specializing in command-line tools and refactoring | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Refactor keyrx_daemon/src/cli/profiles.rs (currently 589 lines) to use the common output module created in task 3. Replace all duplicated JSON and text output logic with calls to cli/common::output_success, cli/common::output_error, and cli/common::output_list. Remove any local output formatting code. Update all 7 handler functions to use the common output functions. Verify the CLI behavior is identical before and after refactoring by running integration tests. The file should be reduced to <500 lines after eliminating duplication. Ensure clippy and rustfmt pass. | Restrictions: Must maintain identical CLI output format; do not change command-line arguments or behavior; preserve all error codes; follow existing error handling patterns; ensure backward compatibility; do not modify test expectations | Success: profiles.rs ≤500 lines (excluding comments/blanks); all handler functions use common output module; no duplicated output logic remains; all CLI integration tests pass; cargo clippy passes; cargo fmt check passes; CLI behavior unchanged; compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (functions modified, integrations), (4) Mark this task as complete [x] in tasks.md_

- [ ] 8. Refactor MacroRecorderPage.tsx to comply with 500-line limit
  - File: keyrx_ui/src/components/MacroRecorderPage.tsx
  - Replace inline utilities with imports from utils/timeFormatting.ts and utils/keyCodeMapping.ts
  - Reduce from 532 lines to <500 lines
  - Purpose: Eliminate duplication and reduce file size
  - _Leverage: utils/timeFormatting.ts from task 1, utils/keyCodeMapping.ts from task 2_
  - _Requirements: 1.4, 1.6, 1.7_
  - _Prompt: Role: React Developer specializing in component refactoring and code organization | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Refactor keyrx_ui/src/components/MacroRecorderPage.tsx (currently 532 lines) to use the shared utility modules created in tasks 1 and 2. Remove inline functions formatTimestamp (lines 33-40) and formatKeyCode (lines 42-65) and replace with imports from utils/timeFormatting and utils/keyCodeMapping. Extract the macroEventsToEventSequence helper function (if >50 lines) to a separate utility file or keep as local helper if small. Review component for other extraction opportunities. The file should be reduced to <500 lines after removing duplicated utilities. Ensure all existing functionality works identically. Run component tests to verify behavior unchanged. | Restrictions: Do not modify component behavior or UI; maintain exact output format; preserve all user interactions; do not add new dependencies; ensure accessibility unchanged; follow existing component patterns | Success: MacroRecorderPage.tsx ≤500 lines; imports and uses timeFormatting and keyCodeMapping utilities; no inline utility functions remain; all component tests pass; TypeScript compilation succeeds; UI behavior identical; no visual regressions | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (component modified, integrations), (4) Mark this task as complete [x] in tasks.md_

## Phase 3: Dependency Injection

- [ ] 9. Create API context provider for dependency injection
  - Files: keyrx_ui/src/contexts/ApiContext.tsx, keyrx_ui/src/App.tsx (modify)
  - Implement ApiContext with apiBaseUrl and wsBaseUrl
  - Wrap App with ApiProvider
  - Purpose: Enable injection of API endpoints for testing
  - _Leverage: Pattern from useDaemon.ts hook_
  - _Requirements: 3.1, 3.5, 3.6_
  - _Prompt: Role: React Developer specializing in Context API and dependency injection patterns | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create a new API context at keyrx_ui/src/contexts/ApiContext.tsx following the pattern from useDaemon.ts. Define ApiContextValue interface with apiBaseUrl (string) and wsBaseUrl (string). Create ApiContext with createContext, ApiProvider component that accepts children and optional baseUrl prop (defaults to http://localhost:3030 for API, ws://localhost:9867 for WebSocket), and useApi hook that returns ApiContextValue. Support environment variable overrides (VITE_API_BASE_URL, VITE_WS_BASE_URL). Update keyrx_ui/src/App.tsx to wrap the app with ApiProvider at the root level. Create unit tests in ApiContext.test.tsx verifying context provides correct values, defaults work, environment variables are respected, and useApi hook works correctly. | Restrictions: Do not modify existing components yet (will be done in next tasks); follow existing context patterns; ensure type safety with TypeScript; do not add external dependencies; support SSR-safe defaults | Success: ApiContext.tsx created and exported; ApiProvider wraps App; useApi hook available; environment variables supported; unit tests pass with ≥90% coverage; TypeScript compilation succeeds; no runtime errors; ready for integration in ProfilesPage | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (components, integrations), (4) Mark this task as complete [x] in tasks.md_

- [ ] 10. Update ProfilesPage to use API context instead of hard-coded URLs
  - File: keyrx_ui/src/components/ProfilesPage.tsx
  - Replace hard-coded localhost:3030 with useApi hook
  - Add unit tests demonstrating mockability
  - Purpose: Enable testing with mock API endpoints
  - _Leverage: ApiContext from task 9_
  - _Requirements: 3.1, 3.5, 3.6_
  - _Prompt: Role: React Developer specializing in component refactoring and testing | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Update keyrx_ui/src/components/ProfilesPage.tsx to use the API context created in task 9. Replace hard-coded fetch('http://localhost:3030/api/profiles') on line 34 with const { apiBaseUrl } = useApi(); fetch(`${apiBaseUrl}/api/profiles`). Add useApi import from contexts/ApiContext. Update any other hard-coded API calls in the component. Modify existing unit tests in ProfilesPage.test.tsx to wrap component with custom ApiProvider providing mock URLs. Add new test cases demonstrating the component works with different API base URLs and that API calls use the injected URL. Verify all existing tests still pass. | Restrictions: Do not modify component behavior or UI; maintain exact API call behavior; preserve error handling; ensure all existing features work; do not change props interface; follow existing testing patterns | Success: ProfilesPage uses useApi hook; no hard-coded URLs remain (search for 'localhost:3030'); all existing tests pass; new tests demonstrate mockability with custom URLs; fetch calls use injected apiBaseUrl; TypeScript compilation succeeds; component behavior unchanged | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (component modified, integrations), (4) Mark this task as complete [x] in tasks.md_

- [ ] 11. Create ConfigStorage abstraction interface
  - Files: keyrx_ui/src/services/ConfigStorage.ts, keyrx_ui/src/services/LocalStorageImpl.ts, keyrx_ui/src/services/MockStorageImpl.ts
  - Implement ConfigStorage interface with LocalStorage and Mock implementations
  - Create comprehensive unit tests
  - Purpose: Abstract browser storage for testability
  - _Leverage: Dependency injection pattern from tech.md_
  - _Requirements: 3.2, 3.5, 3.6_
  - _Prompt: Role: TypeScript Developer specializing in abstraction layers and dependency injection | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create a storage abstraction at keyrx_ui/src/services/ConfigStorage.ts. Define ConfigStorage interface with methods: save(key: string, content: string): Promise<void>, load(key: string): Promise<string | null>, and delete(key: string): Promise<void>. Create LocalStorageImpl class in keyrx_ui/src/services/LocalStorageImpl.ts implementing ConfigStorage using browser localStorage API. Create MockStorageImpl class in keyrx_ui/src/services/MockStorageImpl.ts implementing ConfigStorage with in-memory Map for testing. Add error handling for quota exceeded, invalid keys, and storage unavailable scenarios. Create comprehensive unit tests in ConfigStorage.test.ts for both implementations covering success cases, error scenarios, edge cases (empty strings, special characters, large data), and async behavior. Document all classes and methods with JSDoc. | Restrictions: Interface must be promise-based for consistency; do not add external dependencies; ensure LocalStorageImpl handles all localStorage edge cases (disabled, quota exceeded); MockStorageImpl must be fully deterministic; follow async/await patterns; ensure type safety | Success: ConfigStorage interface defined; LocalStorageImpl works with browser localStorage; MockStorageImpl works in-memory; both implementations pass tests with ≥90% coverage; error handling comprehensive; JSDoc complete; TypeScript compilation succeeds; ready for integration in ConfigurationPage | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (classes, interfaces, files created), (4) Mark this task as complete [x] in tasks.md_

- [ ] 12. Update ConfigurationPage to use ConfigStorage abstraction
  - File: keyrx_ui/src/components/ConfigurationPage.tsx
  - Inject ConfigStorage via props or context
  - Replace direct localStorage calls with abstraction
  - Purpose: Enable testing without browser APIs
  - _Leverage: ConfigStorage from task 11_
  - _Requirements: 3.2, 3.5, 3.6_
  - _Prompt: Role: React Developer specializing in component architecture and testability | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Update keyrx_ui/src/components/ConfigurationPage.tsx to use the ConfigStorage abstraction created in task 11. Add storage prop to component (storage?: ConfigStorage with default new LocalStorageImpl() for backward compatibility). Replace direct localStorage.setItem call on line 51 with await storage.save('keyrx_config', content). Add error handling for storage failures with user-visible error messages. Update component tests to inject MockStorageImpl and verify storage interactions. Add new test cases demonstrating storage failures are handled gracefully. Mark the TODO comment on line 44 as addressed or create GitHub issue if API integration is deferred. Ensure async/await is used correctly and loading states are shown during async operations. | Restrictions: Maintain backward compatibility (component works without storage prop); preserve all existing functionality; ensure error messages are user-friendly; do not change UI/UX; follow existing error handling patterns; maintain accessibility | Success: ConfigurationPage uses injected ConfigStorage; direct localStorage calls removed; storage prop added with default; error handling for storage failures implemented; all tests pass with MockStorageImpl; new tests verify storage interaction; component behavior unchanged for end users; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (component modified, integrations), (4) Mark this task as complete [x] in tasks.md_

## Phase 4: Missing Test Coverage

- [ ] 13. Create unit tests for ProfileCard component
  - File: keyrx_ui/src/components/ProfileCard.test.tsx
  - Test rendering, interactions, time formatting, actions (activate, delete, export)
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for ProfileCard
  - _Leverage: testUtils from task 4, patterns from ProfilesPage.test.tsx_
  - _Requirements: 2.1, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in React component testing | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for ProfileCard component at keyrx_ui/src/components/ProfileCard.test.tsx. Use testUtils.renderWithProviders from task 4. Test scenarios: component renders with profile data, displays profile name and active status correctly, shows formatted timestamp using timeFormatting utility, activate button triggers onActivate callback, delete button triggers onDelete callback with confirmation, export button triggers onExport callback, handles missing optional fields gracefully, applies correct CSS classes for active/inactive states. Mock all callbacks (onActivate, onDelete, onExport). Use React Testing Library queries (getByRole, getByText). Test user interactions with fireEvent or userEvent. Aim for ≥80% code coverage measured by istanbul/nyc. Follow existing test patterns from ProfilesPage.test.tsx. | Restrictions: Do not modify component implementation; use React Testing Library best practices; avoid testing implementation details; focus on user-visible behavior; ensure tests are deterministic; do not add unnecessary dependencies | Success: ProfileCard.test.tsx created with ≥10 test cases; all tests pass; coverage ≥80% for ProfileCard.tsx; tests follow React Testing Library patterns; no flaky tests; TypeScript compilation succeeds; tests run in <5 seconds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 14. Create unit tests for ProfileDialog component
  - File: keyrx_ui/src/components/ProfileDialog.test.tsx
  - Test dialog open/close, form submission, validation
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for ProfileDialog
  - _Leverage: testUtils from task 4_
  - _Requirements: 2.2, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in modal and form testing | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for ProfileDialog component at keyrx_ui/src/components/ProfileDialog.test.tsx. Use testUtils.renderWithProviders. Test scenarios: dialog renders when open prop is true, dialog does not render when open is false, form fields are populated in edit mode, form fields are empty in create mode, submit button triggers onSubmit callback with form data, cancel button triggers onClose callback, escape key closes dialog, clicking overlay closes dialog, form validation prevents submission with empty name, handles file upload for config import, resets form on close. Mock onSubmit and onClose callbacks. Test both create and edit modes. Aim for ≥80% coverage. | Restrictions: Do not modify component; follow modal testing best practices; test accessibility (focus management, aria attributes); ensure tests are deterministic; use React Testing Library | Success: ProfileDialog.test.tsx created with ≥12 test cases; all tests pass; coverage ≥80%; tests cover both create and edit modes; accessibility tested; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 15. Create unit tests for DashboardEventTimeline component
  - File: keyrx_ui/src/components/DashboardEventTimeline.test.tsx
  - Test event rendering, scrolling, filtering
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for DashboardEventTimeline
  - _Leverage: testUtils from task 4_
  - _Requirements: 2.3, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in list and timeline components | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for DashboardEventTimeline component at keyrx_ui/src/components/DashboardEventTimeline.test.tsx. Use testUtils. Test scenarios: renders empty state with no events, renders list of events with correct data, displays timestamps using timeFormatting utility, displays event types and descriptions correctly, handles large number of events (virtualization if applicable), auto-scrolls to latest event when new event arrives, filter controls work correctly (if present), handles real-time updates via WebSocket, gracefully handles malformed event data. Mock event data and WebSocket if integrated. Aim for ≥80% coverage. | Restrictions: Do not modify component; test user-visible behavior only; ensure tests handle async updates; avoid flaky tests; use React Testing Library | Success: DashboardEventTimeline.test.tsx created with ≥10 test cases; all tests pass; coverage ≥80%; tests handle async behavior correctly; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 16. Create unit tests for DashboardPage component
  - File: keyrx_ui/src/components/DashboardPage.test.tsx
  - Test dashboard layout, integration with child components
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for DashboardPage
  - _Leverage: testUtils from task 4_
  - _Requirements: 2.4, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in page and integration testing | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for DashboardPage component at keyrx_ui/src/components/DashboardPage.test.tsx. Use testUtils. Test scenarios: page renders with all child components (EventTimeline, MetricsChart, StateIndicatorPanel, etc.), layout is correct, navigation works if present, integrates with WebSocket for real-time data, handles connection failures gracefully, updates child components when data changes, displays loading states during initialization, handles errors with user-friendly messages. Mock WebSocket connections and child components if needed for unit testing. Aim for ≥80% coverage. | Restrictions: Do not modify component; focus on integration between components; test page-level behavior; ensure tests are maintainable; use React Testing Library | Success: DashboardPage.test.tsx created with ≥8 test cases; all tests pass; coverage ≥80%; tests verify child component integration; handles async data correctly; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 17. Create unit tests for DeviceList component
  - File: keyrx_ui/src/components/DeviceList.test.tsx
  - Test device rendering, WebSocket connection, selection
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for DeviceList
  - _Leverage: testUtils from task 4_
  - _Requirements: 2.5, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in WebSocket and real-time components | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for DeviceList component at keyrx_ui/src/components/DeviceList.test.tsx. Use testUtils. Test scenarios: renders list of devices, displays device names and serial numbers, shows device connection status, WebSocket connection established on mount, handles WebSocket reconnection on disconnect, receives and displays real-time device updates, device selection triggers callback, handles device addition/removal events, handles malformed WebSocket messages gracefully (tests silent catch blocks on lines 77 and 89), displays empty state with no devices. Mock WebSocket using a mock implementation. Aim for ≥80% coverage. | Restrictions: Do not modify component; mock WebSocket properly; test reconnection logic; ensure tests are deterministic; avoid timing-based assertions that may be flaky | Success: DeviceList.test.tsx created with ≥12 test cases; all tests pass; coverage ≥80%; WebSocket behavior tested including reconnection; silent catch blocks tested with invalid messages; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 18. Create unit tests for EventTimeline component
  - File: keyrx_ui/src/components/EventTimeline.test.tsx
  - Test event list rendering, time formatting, filtering
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for EventTimeline
  - _Leverage: testUtils from task 4, timeFormatting from task 1_
  - _Requirements: 2.6, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in timeline and event visualization | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for EventTimeline component at keyrx_ui/src/components/EventTimeline.test.tsx. Use testUtils. Test scenarios: renders event list chronologically, displays timestamps using formatTime utility (verify integration with timeFormatting module if refactored), displays event metadata (type, key codes, actions), handles empty event list, auto-scrolls to latest events, filtering by event type works correctly, handles large datasets efficiently, real-time event updates via WebSocket if applicable, handles missing or malformed event data gracefully. Mock event data. Aim for ≥80% coverage. | Restrictions: Do not modify component; test user-visible behavior; ensure async handling is tested; avoid flaky tests; use React Testing Library | Success: EventTimeline.test.tsx created with ≥10 test cases; all tests pass; coverage ≥80%; timestamp formatting tested; filtering tested; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 19. Create unit tests for MetricsChart component
  - File: keyrx_ui/src/components/MetricsChart.test.tsx
  - Test chart rendering, data updates, interaction
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for MetricsChart
  - _Leverage: testUtils from task 4_
  - _Requirements: 2.7, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in data visualization testing | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for MetricsChart component at keyrx_ui/src/components/MetricsChart.test.tsx. Use testUtils. Test scenarios: chart renders with metrics data, displays correct chart type (line, bar, etc.), handles empty data gracefully, updates when new data arrives, chart axes labeled correctly, tooltips show correct values on hover, legend displays correctly, handles large datasets without performance issues, responsive behavior on window resize, accessibility attributes present. Mock chart library if necessary (e.g., Chart.js). Aim for ≥80% coverage. | Restrictions: Do not modify component; mock chart library to avoid canvas issues in tests; test component logic not library internals; ensure tests are fast; use React Testing Library | Success: MetricsChart.test.tsx created with ≥8 test cases; all tests pass; coverage ≥80%; chart rendering tested (mocked or snapshot); data updates tested; accessibility verified; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 20. Create unit tests for StateIndicatorPanel component
  - File: keyrx_ui/src/components/StateIndicatorPanel.test.tsx
  - Test state display, modifier indicators, real-time updates
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for StateIndicatorPanel
  - _Leverage: testUtils from task 4_
  - _Requirements: 2.8, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in state visualization testing | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for StateIndicatorPanel component at keyrx_ui/src/components/StateIndicatorPanel.test.tsx. Use testUtils. Test scenarios: panel renders with initial state, displays active modifiers correctly, displays active lock keys correctly, updates when state changes via props or WebSocket, shows correct visual indicators (colors, icons) for active/inactive states, handles 255 modifiers and 255 locks correctly, displays current layer information, handles rapid state updates without lag, accessibility attributes for screen readers. Mock state data and WebSocket if applicable. Aim for ≥80% coverage. | Restrictions: Do not modify component; test state visualization logic; ensure tests handle rapid updates; avoid flaky tests; test accessibility; use React Testing Library | Success: StateIndicatorPanel.test.tsx created with ≥10 test cases; all tests pass; coverage ≥80%; state updates tested; modifier and lock visualization tested; accessibility verified; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 21. Create unit tests for TemplateLibrary component
  - File: keyrx_ui/src/components/TemplateLibrary.test.tsx
  - Test template list, selection, preview, insertion
  - Achieve ≥80% coverage
  - Purpose: Add missing test coverage for TemplateLibrary
  - _Leverage: testUtils from task 4_
  - _Requirements: 2.9, 2.10, 2.11_
  - _Prompt: Role: Frontend Test Engineer specializing in component and UX testing | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create comprehensive unit tests for TemplateLibrary component at keyrx_ui/src/components/TemplateLibrary.test.tsx. Use testUtils. Test scenarios: component renders template list, displays template names and descriptions, template selection updates preview, insert button triggers callback with template content, search/filter functionality works correctly, handles empty search results, categories or tags work if present, handles large number of templates, template preview displays correctly formatted code. Mock template data and onInsert callback. Aim for ≥80% coverage. | Restrictions: Do not modify component; test user interactions thoroughly; ensure tests are maintainable; avoid flaky tests; use React Testing Library | Success: TemplateLibrary.test.tsx created with ≥10 test cases; all tests pass; coverage ≥80%; template selection and insertion tested; search/filter tested if present; no flaky tests; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (test file created, test cases count), (4) Mark this task as complete [x] in tasks.md_

## Phase 5: Error Handling and Logging

- [ ] 22. Add structured logging to silent catch blocks in DeviceList
  - File: keyrx_ui/src/components/DeviceList.tsx
  - Add console.debug or structured logging to catch blocks on lines 77 and 89
  - Purpose: Improve observability of ignored errors
  - _Leverage: Existing error handling patterns in other components_
  - _Requirements: 5.1, 5.2, 5.6_
  - _Prompt: Role: Frontend Developer specializing in error handling and logging | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Update keyrx_ui/src/components/DeviceList.tsx to add structured logging to silent catch blocks on lines 77 (non-JSON message handling) and 89 (WebSocket reconnection). For line 77, add console.debug('Received non-JSON message:', message) to provide visibility into ignored messages during development. For line 89, add console.debug('WebSocket reconnection scheduled:', { timeout: 5000, error }) to log reconnection attempts. Ensure logging does not impact production performance. Update component tests to verify logging occurs in these scenarios. Consider adding a debug flag or environment variable to control logging verbosity. | Restrictions: Do not change component behavior; logging must not throw errors; ensure console methods are safe (check if console exists); do not log sensitive data; maintain performance; follow existing logging patterns | Success: Silent catch blocks now log at debug level; tests verify logging occurs; no behavior changes; no performance impact; TypeScript compilation succeeds; component tests pass | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (component modified, logging added), (4) Mark this task as complete [x] in tasks.md_

- [ ] 23. Propagate errors to UI in configBuilderStore
  - File: keyrx_ui/src/store/configBuilderStore.ts
  - Add error state to store and propagate validation errors to UI
  - Purpose: Provide user feedback for failed actions
  - _Leverage: Existing store patterns and error handling in other stores_
  - _Requirements: 5.3, 5.5_
  - _Prompt: Role: Frontend State Management Developer specializing in Zustand and error handling | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Update keyrx_ui/src/store/configBuilderStore.ts to propagate errors to the UI instead of just logging warnings. Add an errors field to the store state (errors: string[] or lastError: string | null). Update actions that currently only console.warn (e.g., removeLayer on line 110 when trying to remove base layer) to set error state in addition to logging. Create clearError action to dismiss errors. Update components using the store to display errors to users (e.g., toast notifications, inline error messages). Ensure errors are user-friendly and actionable. Update tests to verify error state is set correctly and can be cleared. | Restrictions: Do not change store behavior beyond adding error propagation; maintain backward compatibility; ensure errors are user-friendly; do not expose internal state in error messages; follow existing Zustand patterns | Success: Store has error state field; actions set errors when validation fails; console.warn calls supplemented with error state updates; clearError action implemented; components display errors to users; tests verify error propagation; TypeScript compilation succeeds; store tests pass | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (store modified, new actions), (4) Mark this task as complete [x] in tasks.md_

- [ ] 24. Add structured logging to Rust CLI modules
  - Files: keyrx_daemon/src/cli/config.rs, keyrx_daemon/src/cli/profiles.rs (and other CLI modules)
  - Replace ad-hoc logging with structured JSON logging
  - Purpose: Enable machine-parseable logs for AI agents
  - _Leverage: keyrx_daemon/src/logger.rs structured logging pattern_
  - _Requirements: 5.4, 5.6_
  - _Prompt: Role: Rust Backend Developer specializing in structured logging and observability | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Update CLI modules (config.rs, profiles.rs, layers.rs, devices.rs) to use structured JSON logging from keyrx_daemon/src/logger.rs. Replace any println! or eprintln! debug statements with log::debug!, log::info!, log::warn!, or log::error! macros. Ensure all log entries include: timestamp (ISO 8601), level, service (keyrx_daemon), event_type (config_load, profile_activate, etc.), context (relevant data as JSON), and correlation_id if applicable. Add logging for important events: command execution start/end, validation errors, configuration changes. Ensure no PII or secrets are logged. Update CLI output functions in common.rs to separate user-facing output from logging. | Restrictions: Do not change CLI output format for users; separate logging from stdout/stderr output; ensure JSON logs go to stderr or log file; follow existing logger patterns; do not log sensitive data; maintain performance | Success: CLI modules use structured logging; all important events logged; log format matches LogEntry schema from design.md; no PII in logs; CLI user output unchanged; tests pass; compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (files modified, logging patterns added), (4) Mark this task as complete [x] in tasks.md_

## Phase 6: Documentation

- [ ] 25. Add comprehensive JSDoc to all React components
  - Files: ProfileCard.tsx, ProfileDialog.tsx, TemplateLibrary.tsx, EventTimeline.tsx, DeviceList.tsx (and others)
  - Add JSDoc comments describing purpose, props, usage examples
  - Purpose: Improve code documentation and developer onboarding
  - _Leverage: Existing JSDoc patterns in well-documented components_
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7_
  - _Prompt: Role: Technical Writer and Frontend Developer specializing in documentation | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Add comprehensive JSDoc comments to all React components that currently lack documentation: ProfileCard.tsx, ProfileDialog.tsx, TemplateLibrary.tsx, EventTimeline.tsx, DeviceList.tsx, DashboardEventTimeline.tsx, DashboardPage.tsx, MetricsChart.tsx, StateIndicatorPanel.tsx. Each component should have a JSDoc block above the function declaration describing: purpose of the component, all props with @param tags (name, type, description), return type with @returns, usage example with @example if helpful, any important behavior notes. Follow TSDoc standard. For complex internal functions, add inline comments explaining "why" not "what". Ensure all public functions and hooks have documentation. Run TypeDoc to verify documentation generates correctly. | Restrictions: Do not modify component behavior; follow TSDoc standard; keep descriptions concise but complete; provide practical usage examples; document edge cases and constraints; maintain consistency across components | Success: All 9 components have JSDoc comments; all props documented with types and descriptions; examples provided for complex components; TypeDoc generates documentation without errors; documentation is clear and helpful; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (components documented, count), (4) Mark this task as complete [x] in tasks.md_

- [ ] 26. Add comprehensive rustdoc to refactored Rust modules
  - Files: cli/common.rs, config/profile_compiler.rs (and refactored modules)
  - Add module-level and function-level documentation
  - Purpose: Document all public APIs for developer reference
  - _Leverage: Existing rustdoc patterns in keyrx_core_
  - _Requirements: 6.6, 6.7_
  - _Prompt: Role: Rust Developer and Technical Writer specializing in API documentation | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Add comprehensive rustdoc comments to all newly created and refactored Rust modules: keyrx_daemon/src/cli/common.rs, keyrx_daemon/src/config/profile_compiler.rs. Each module should have a module-level doc comment (//!) explaining the module's purpose and role in the system. Each public function should have a doc comment (///) with: purpose description, # Arguments section documenting each parameter, # Returns section describing return value, # Errors section listing possible error conditions, # Examples section with usage example, # Panics section if applicable. Document any complex internal logic with inline comments explaining "why". Run cargo doc to verify documentation generates correctly. Ensure links between related functions and types are created with [TypeName] syntax. | Restrictions: Do not modify function behavior; follow Rust API documentation guidelines; keep examples concise and compilable; document all public APIs; explain error conditions; maintain consistency with existing keyrx_core docs | Success: All refactored modules have module-level docs; all public functions documented with examples; cargo doc generates without warnings; documentation is clear and complete; links between types work correctly; compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (modules documented, count), (4) Mark this task as complete [x] in tasks.md_

## Phase 7: Outstanding TODOs

- [ ] 27. Resolve or track ConfigurationPage API integration TODO
  - File: keyrx_ui/src/components/ConfigurationPage.tsx (line 44)
  - Either implement actual API call or create GitHub issue
  - Purpose: Ensure incomplete work is tracked
  - _Leverage: Existing API patterns from ProfilesPage_
  - _Requirements: 7.1, 7.5_
  - _Prompt: Role: Full-stack Developer and Project Manager | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Address the TODO comment on line 44 of keyrx_ui/src/components/ConfigurationPage.tsx ("TODO: Replace with actual API call"). Evaluate whether to: (1) implement the API call now using the API context from task 9, following patterns from ProfilesPage for saving configuration to the daemon backend, OR (2) create a GitHub issue with label "technical-debt" describing the requirement (endpoint needed, request/response format, error handling), acceptance criteria, and link to this spec. If implementing, add error handling, loading states, and success feedback. If deferring, remove or update the TODO comment to reference the GitHub issue. Document the decision in a code comment. | Restrictions: If implementing, must use API context for testability; handle all error scenarios; provide user feedback; do not break existing functionality. If creating issue, must be detailed and actionable | Success: TODO is addressed by either: (1) API call implemented with error handling, tests added, and ConfigStorage used for fallback, OR (2) GitHub issue created with detailed description and TODO comment updated to reference issue #XXX; in either case, no bare TODO remains in production code; TypeScript compilation succeeds | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes or create issue, (3) Use log-implementation tool to record decision and artifacts, (4) Mark this task as complete [x] in tasks.md_

- [ ] 28. Resolve or track WebSocket event streaming TODO
  - File: keyrx_daemon/src/web/ws.rs (line 48)
  - Either implement WebSocket event streaming or create GitHub issue
  - Purpose: Complete or track WebSocket functionality
  - _Leverage: Existing WebSocket handler structure_
  - _Requirements: 7.2, 7.5_
  - _Prompt: Role: Rust Backend Developer specializing in WebSocket and real-time systems | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Address the TODO comments on line 48 of keyrx_daemon/src/web/ws.rs ("TODO: Handle client commands (subscribe/unsubscribe to event types)" and "TODO: Implement Real-time Event Streaming"). Evaluate whether to: (1) implement the functionality now by adding command handling for subscribe/unsubscribe messages and implementing event streaming with crossbeam channels from daemon to WebSocket clients, OR (2) create a GitHub issue describing the requirement (command format, event types to stream, performance considerations), acceptance criteria, and link to this spec. If implementing, ensure proper error handling, client isolation, and no impact on input processing performance. If deferring, update TODO comments to reference the GitHub issue. | Restrictions: If implementing, must not impact <1ms latency requirement; use lock-free channels; isolate client errors; follow existing WebSocket patterns. If creating issue, must be detailed with technical specification | Success: TODO is addressed by either: (1) WebSocket command handling and event streaming implemented with tests, OR (2) GitHub issue created with detailed technical spec and TODO comments updated to reference issue #XXX; no bare TODO remains; compilation succeeds; if implemented, integration tests verify functionality | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes or create issue, (3) Use log-implementation tool to record decision and artifacts, (4) Mark this task as complete [x] in tasks.md_

- [ ] 29. Implement ProfilesPage rename functionality
  - Files: keyrx_ui/src/components/ProfilesPage.tsx (line 209), backend API endpoint
  - Implement rename API endpoint and update frontend
  - Purpose: Complete missing rename feature
  - _Leverage: Existing profile API patterns_
  - _Requirements: 7.3_
  - _Prompt: Role: Full-stack Developer with Rust and React expertise | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Implement the profile rename functionality referenced on line 209 of ProfilesPage.tsx. Backend: Add a PUT /api/profiles/:name/rename endpoint in keyrx_daemon accepting new_name in request body, validating the new name, renaming the profile files (.krx and .rhai), updating any references, and returning success/error response. Frontend: Replace the alert('Rename functionality not yet implemented in API') with actual API call using fetch and the API context from task 9, handling success (refresh profile list) and error cases (display error message to user), showing loading state during request. Add error handling for name conflicts, invalid names, and network errors. Update tests to verify rename functionality. | Restrictions: Backend must validate new name (no special characters, length limits); must handle race conditions (profile being used); frontend must use API context for testability; provide user feedback for all scenarios; follow existing API patterns | Success: Backend endpoint implemented and tested; frontend rename dialog functional; API call uses ApiContext; error handling comprehensive; profile renames successfully; tests verify happy path and error cases; no alert() remains; compilation succeeds; integration tests pass | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Implement the changes, (3) Use log-implementation tool to record detailed artifacts (API endpoint, frontend integration), (4) Mark this task as complete [x] in tasks.md_

## Phase 8: Validation and Cleanup

- [ ] 30. Run full test suite and verify coverage targets
  - Run all Rust and TypeScript tests
  - Verify ≥80% coverage across the board
  - Purpose: Ensure all changes meet quality standards
  - _Requirements: 2.10, 2.11, 1.6, 1.7_
  - _Prompt: Role: QA Engineer and Build System Specialist | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Execute comprehensive test suite validation. Run cargo test --workspace for all Rust tests and verify all pass. Run npm test in keyrx_ui for all TypeScript/React tests and verify all pass. Run cargo tarpaulin to measure Rust code coverage and verify ≥80% overall (≥90% for keyrx_core). Run nyc or istanbul to measure TypeScript coverage and verify ≥80% overall. Generate coverage reports and review any uncovered lines for gaps. If coverage targets not met, identify missing tests and either add them or document why they're not needed. Run cargo clippy and cargo fmt check to ensure code quality. Run npm run lint for TypeScript linting. Document test results and coverage in a summary report. Fix any failing tests or quality issues. | Restrictions: Do not reduce test quality to meet coverage numbers; ensure all tests are meaningful; fix flaky tests; maintain fast test execution; do not skip tests to pass coverage | Success: All Rust tests pass; all TypeScript tests pass; Rust coverage ≥80% (≥90% for keyrx_core); TypeScript coverage ≥80%; no clippy warnings; no rustfmt issues; no linting errors; coverage report generated; all quality gates pass | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Run all tests and checks, (3) Use log-implementation tool to record results and any fixes made, (4) Mark this task as complete [x] in tasks.md_

- [ ] 31. Verify file size compliance across all files
  - Run automated script to measure file sizes
  - Ensure all files ≤500 lines (excluding comments/blanks)
  - Purpose: Confirm adherence to code quality standards
  - _Requirements: 1.1, 1.2, 1.3, 1.4_
  - _Prompt: Role: DevOps Engineer and Code Quality Specialist | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Create and execute an automated file size verification script. Write a script (Bash or Python) that: (1) finds all .rs, .tsx, .ts files in the project, (2) counts lines of code excluding comments and blank lines (use cloc, tokei, or similar tool), (3) reports any files exceeding 500 lines, (4) generates a summary report listing all files checked and their line counts. Run the script on the entire codebase after all refactoring tasks are complete. Verify that profile_manager.rs, config.rs, profiles.rs, and MacroRecorderPage.tsx are all ≤500 lines. If any files still exceed the limit, document why and plan additional refactoring or request exception approval. Integrate script into CI pipeline to prevent future violations. | Restrictions: Script must exclude comments and blank lines; use reliable counting tool (cloc, tokei); do not count generated files or vendored dependencies; report must be clear and actionable | Success: Script created and executable; script runs on all source files; report shows all targeted files ≤500 lines; any violations documented with justification or fix plan; script integrated into CI; no false positives or negatives; documentation updated | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Create and run script, (3) Use log-implementation tool to record script location and results, (4) Mark this task as complete [x] in tasks.md_

- [ ] 32. Update project documentation and close spec
  - Update CLAUDE.md or relevant docs with new utilities and patterns
  - Document lessons learned
  - Purpose: Ensure knowledge transfer and spec completion
  - _Requirements: All_
  - _Prompt: Role: Technical Writer and Developer Advocate | Task: Implement the task for spec technical-debt-remediation, first run spec-workflow-guide to get the workflow guide then implement the task: Complete final documentation updates for the technical debt remediation. Update relevant sections of .claude/CLAUDE.md or docs/ to document: new shared utilities (timeFormatting, keyCodeMapping, cli/common), dependency injection patterns (ApiContext, ConfigStorage), testing utilities (testUtils), and any new project conventions established. Add a "Technical Debt Prevention" section to CLAUDE.md with guidelines learned from this remediation: file size monitoring, test coverage requirements, dependency injection best practices, error handling standards. Update any affected architecture diagrams or documentation. Create a brief lessons learned document summarizing what caused the technical debt, how it was fixed, and how to prevent it in the future. Ensure all new code patterns are documented for future developers. Run a final check that all spec requirements are met and tasks are complete. | Restrictions: Do not modify existing documentation unnecessarily; keep additions concise and actionable; focus on practical guidance; maintain consistency with existing docs; ensure examples are accurate | Success: CLAUDE.md updated with new utilities and patterns; technical debt prevention guidelines added; lessons learned documented; all new patterns explained clearly; documentation is accurate and helpful; all spec requirements verified complete; spec ready for closure | After completing this task: (1) Mark this task as in-progress [-] in tasks.md before starting, (2) Update all documentation, (3) Use log-implementation tool to record documentation changes, (4) Mark this task as complete [x] in tasks.md_
