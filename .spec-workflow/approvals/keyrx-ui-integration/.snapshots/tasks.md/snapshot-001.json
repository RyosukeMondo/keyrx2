{
  "id": "snapshot_1767224066303_egytm1dby",
  "approvalId": "approval_1767224066287_8x2s94965",
  "approvalTitle": "keyrx-ui-integration Tasks Document",
  "version": 1,
  "timestamp": "2025-12-31T23:34:26.303Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n## Task Breakdown\n\nThis document contains the implementation tasks for the keyrx-ui-integration specification. Tasks are organized by requirement and broken down into atomic, implementable units.\n\n**Legend:**\n- `[ ]` - Pending\n- `[-]` - In Progress\n- `[x]` - Completed\n\n---\n\n## Phase 1: Unified WebSocket RPC API (REQ-1)\n\n### 1.1 Backend RPC Infrastructure\n\n#### [ ] 1.1.1 Define RPC Message Types\n\n**Requirements**: REQ-1 (AC1, AC5)\n**Files**:\n- `keyrx_daemon/src/web/rpc_types.rs` (new)\n\n**Success Criteria**:\n- `ClientMessage` enum with Query, Command, Subscribe, Unsubscribe variants\n- `ServerMessage` enum with Response, Event, Connected variants\n- `RpcError` struct with code, message, data fields\n- JSON-RPC error code constants defined\n- All types implement Serialize/Deserialize\n- Unit tests for serialization/deserialization\n\n**_Prompt**:\nCreate `keyrx_daemon/src/web/rpc_types.rs` with the RPC message type definitions from the design document (section 2.1.4). Implement ClientMessage and ServerMessage enums using serde's tag attribute for type discrimination. Define standard JSON-RPC error codes as constants (PARSE_ERROR=-32700, INVALID_REQUEST=-32600, METHOD_NOT_FOUND=-32601, INVALID_PARAMS=-32602, INTERNAL_ERROR=-32603). Add comprehensive unit tests that verify serialization/deserialization works correctly for all message types.\n\n---\n\n#### [ ] 1.1.2 Implement WebSocket RPC Handler\n\n**Requirements**: REQ-1 (AC1, AC2, AC3, AC6, AC7)\n**Files**:\n- `keyrx_daemon/src/web/ws_rpc.rs` (new)\n- `keyrx_daemon/src/web/mod.rs` (modify)\n\n**Success Criteria**:\n- `ws_handler` function accepts WebSocket upgrade\n- Handshake sends Connected message on connection\n- Message loop processes ClientMessage and routes to handlers\n- Request/response correlation via UUID tracking\n- Clean up pending requests on disconnect\n- Invalid JSON returns PARSE_ERROR\n- Unknown methods return METHOD_NOT_FOUND\n\n**_Prompt**:\nImplement the WebSocket RPC handler in `keyrx_daemon/src/web/ws_rpc.rs` following the design in section 2.1.4. The handler should: (1) accept WebSocket upgrade from Axum, (2) send Connected handshake with version and timestamp, (3) split socket into sender/receiver, (4) loop on incoming messages and deserialize to ClientMessage, (5) route Query/Command/Subscribe/Unsubscribe to respective handler functions, (6) track pending requests in a HashMap, (7) handle parse errors and unknown methods with proper error codes, (8) clean up resources on disconnect. Add unit tests for message routing logic.\n\n---\n\n#### [ ] 1.1.3 Implement Profile RPC Methods\n\n**Requirements**: REQ-1 (AC2, AC3)\n**Files**:\n- `keyrx_daemon/src/web/handlers/profile.rs` (new)\n- `keyrx_daemon/src/web/handlers/mod.rs` (new)\n\n**Success Criteria**:\n- `get_profiles()` returns Profile[] via query\n- `create_profile(name, basedOn?)` creates profile via command\n- `activate_profile(name)` activates profile via command\n- `delete_profile(name)` deletes profile via command\n- `duplicate_profile(name, newName)` duplicates profile via command\n- `rename_profile(oldName, newName)` renames profile via command\n- All methods validate parameters and return appropriate errors\n- Integration tests verify each method works end-to-end\n\n**_Prompt**:\nCreate `keyrx_daemon/src/web/handlers/profile.rs` with RPC method implementations for profile operations. Each function should accept `&AppState` and `serde_json::Value` for params, deserialize params to a typed struct, validate inputs (profile names must not contain '..' or '/'), call the underlying profile manager methods, and return `Result<serde_json::Value, RpcError>`. Implement all 6 profile methods from the design (section 2.1.2). Add integration tests that verify each RPC method with valid and invalid inputs.\n\n---\n\n#### [ ] 1.1.4 Implement Device RPC Methods\n\n**Requirements**: REQ-1 (AC2, AC3)\n**Files**:\n- `keyrx_daemon/src/web/handlers/device.rs` (new)\n\n**Success Criteria**:\n- `get_devices()` returns Device[] via query\n- `rename_device(serialNumber, name)` renames device via command\n- `set_scope_device(serialNumber)` sets scope device via command\n- `forget_device(serialNumber)` removes device via command\n- Serial number validation prevents injection attacks\n- Integration tests verify each method\n\n**_Prompt**:\nCreate `keyrx_daemon/src/web/handlers/device.rs` with RPC implementations for device operations. Follow the same pattern as profile handlers: accept `&AppState` and params, deserialize/validate, call device manager, return Result. Implement all 4 device methods from the design (section 2.1.2). Validate serial numbers to prevent path traversal or injection attacks. Add integration tests for each method.\n\n---\n\n#### [ ] 1.1.5 Implement Config RPC Methods\n\n**Requirements**: REQ-1 (AC2, AC3)\n**Files**:\n- `keyrx_daemon/src/web/handlers/config.rs` (new)\n\n**Success Criteria**:\n- `get_config(profileName)` returns config code and hash via query\n- `update_config(profileName, code)` validates and saves config via command\n- `set_key_mapping(profileName, keyCode, mapping)` updates key via command\n- `delete_key_mapping(profileName, keyCode)` removes key via command\n- `get_layers(profileName)` returns layer list via query\n- Configuration validation uses keyrx_compiler\n- Max config size enforced (1MB)\n- Integration tests verify CRUD operations\n\n**_Prompt**:\nCreate `keyrx_daemon/src/web/handlers/config.rs` with RPC implementations for configuration operations. Implement the 5 config methods from the design (section 2.1.2). The `update_config` method MUST validate the configuration using `keyrx_compiler::parse()` before saving, and enforce a 1MB size limit. The `get_config` method should return both the Rhai code string and a hash for verification. Add comprehensive integration tests that verify configuration CRUD operations work correctly.\n\n---\n\n#### [ ] 1.1.6 Implement Metrics and Simulator RPC Methods\n\n**Requirements**: REQ-1 (AC2, AC3)\n**Files**:\n- `keyrx_daemon/src/web/handlers/metrics.rs` (new)\n\n**Success Criteria**:\n- `get_latency()` returns current latency metrics via query\n- `get_events(limit?, offset?)` returns paginated events via query\n- `clear_events()` clears event history via command\n- `simulate(code, input)` runs simulation via command\n- `reset_simulator()` resets simulator state via command\n- Integration tests verify metrics collection and simulation\n\n**_Prompt**:\nCreate `keyrx_daemon/src/web/handlers/metrics.rs` with RPC implementations for metrics and simulator operations. Implement the 5 methods from the design (section 2.1.2). The `get_events` method should support pagination with limit and offset parameters (default limit=100, max=1000). The `simulate` method should use keyrx_core's simulator to run the provided configuration with the input events and return state transitions and output events. Add integration tests.\n\n---\n\n#### [ ] 1.1.7 Implement Subscription Channel Manager\n\n**Requirements**: REQ-1 (AC4, AC8, AC10)\n**Files**:\n- `keyrx_daemon/src/web/subscriptions.rs` (new)\n- `keyrx_daemon/src/web/ws_rpc.rs` (modify)\n\n**Success Criteria**:\n- `SubscriptionManager` tracks client subscriptions per channel\n- Subscribe message adds client to channel\n- Unsubscribe message removes client from channel\n- Broadcast sends event to all subscribed clients\n- Three channels implemented: daemon-state, events, latency\n- Disconnect automatically cleans up all client subscriptions\n- Integration tests verify pub/sub behavior\n\n**_Prompt**:\nCreate `keyrx_daemon/src/web/subscriptions.rs` with a SubscriptionManager that tracks which WebSocket clients are subscribed to which channels. Use a `HashMap<String, HashSet<ClientId>>` to track subscriptions. Implement methods: `subscribe(client_id, channel)`, `unsubscribe(client_id, channel)`, `unsubscribe_all(client_id)`, and `broadcast(channel, data)`. The broadcast method should serialize the data to JSON and send an Event message to all subscribed clients on that channel. Integrate this into the WebSocket handler from task 1.1.2. Add tests that verify multiple clients can subscribe and receive broadcasts.\n\n---\n\n#### [ ] 1.1.8 Integrate Daemon Event Broadcasting\n\n**Requirements**: REQ-1 (AC8)\n**Files**:\n- `keyrx_daemon/src/main.rs` (modify)\n- `keyrx_daemon/src/processor.rs` (modify)\n\n**Success Criteria**:\n- Daemon state changes broadcast to \"daemon-state\" channel\n- Key events broadcast to \"events\" channel\n- Latency metrics broadcast to \"latency\" channel (1s interval)\n- Broadcasts use SubscriptionManager from task 1.1.7\n- No blocking on broadcast (async/spawn)\n- Integration tests verify events are broadcast correctly\n\n**_Prompt**:\nModify the daemon's event processing loop to broadcast events to WebSocket subscribers. In `keyrx_daemon/src/processor.rs`, after processing each key event: (1) broadcast the updated daemon state (modifiers, locks, layer) to the \"daemon-state\" channel, (2) broadcast the key event (timestamp, keyCode, eventType, latency, layer) to the \"events\" channel. In `keyrx_daemon/src/main.rs`, add a periodic task that runs every 1 second and broadcasts latency metrics (min, avg, max, p50, p95, p99, count) to the \"latency\" channel. Use the SubscriptionManager from task 1.1.7. Ensure broadcasts are non-blocking by spawning async tasks.\n\n---\n\n#### [ ] 1.1.9 Add RPC Integration Tests\n\n**Requirements**: REQ-1 (AC1-AC10)\n**Files**:\n- `keyrx_daemon/tests/integration/rpc_api_test.rs` (new)\n\n**Success Criteria**:\n- Test connects to WebSocket and receives Connected handshake\n- Test sends query and receives response with matching ID\n- Test sends command and verifies side effect\n- Test subscribes to channel and receives broadcast events\n- Test unsubscribes and stops receiving events\n- Test sends invalid message and receives error\n- Test sends unknown method and receives METHOD_NOT_FOUND\n- Test multiple concurrent clients with different request IDs\n- Test timeout behavior (30s)\n- All acceptance criteria from REQ-1 verified\n\n**_Prompt**:\nCreate comprehensive integration tests in `keyrx_daemon/tests/integration/rpc_api_test.rs` that verify the complete RPC API implementation. Use tokio-tungstenite to create WebSocket clients. Test scenarios: (1) handshake on connect, (2) query/response correlation, (3) command execution, (4) subscription and event broadcast, (5) unsubscribe stops events, (6) invalid JSON returns PARSE_ERROR, (7) unknown method returns METHOD_NOT_FOUND, (8) concurrent requests from multiple clients are handled correctly, (9) request timeout after 30 seconds. Each test should verify the acceptance criteria from REQ-1.\n\n---\n\n### 1.2 Frontend RPC Client\n\n#### [ ] 1.2.1 Define TypeScript RPC Types\n\n**Requirements**: REQ-1 (AC1, AC2, AC3, AC4)\n**Files**:\n- `keyrx_ui_v2/src/types/rpc.ts` (new)\n\n**Success Criteria**:\n- `RpcMethod` type union of all method names\n- `SubscriptionChannel` type union of channel names\n- `ClientMessage` interface for all client messages\n- `ServerMessage` interface for all server messages\n- `RpcError` interface matching Rust type\n- `DaemonState`, `KeyEvent`, `LatencyMetrics` interfaces\n- Types match Rust types exactly (field names, types)\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/types/rpc.ts` with TypeScript type definitions that exactly match the Rust RPC types from task 1.1.1. Define the RpcMethod string union with all 20+ method names from the design (section 2.1.5). Define SubscriptionChannel as \"daemon-state\" | \"events\" | \"latency\". Create ClientMessage and ServerMessage interfaces using discriminated unions (type field). Define data structure interfaces (DaemonState, KeyEvent, LatencyMetrics) with field names matching the Rust types. Ensure all types are exported.\n\n---\n\n#### [ ] 1.2.2 Implement useUnifiedApi Hook\n\n**Requirements**: REQ-1 (AC1, AC2, AC3, AC4, AC6, AC9, AC10)\n**Files**:\n- `keyrx_ui_v2/src/hooks/useUnifiedApi.ts` (new)\n\n**Success Criteria**:\n- Hook connects to WebSocket URL (default ws://localhost:9867/api)\n- Auto-reconnects on disconnect (3s interval, 10 attempts)\n- `query<T>(method, params?)` sends query and returns Promise<T>\n- `command<T>(method, params)` sends command and returns Promise<T>\n- `subscribe(channel, handler)` subscribes to channel\n- `unsubscribe(channel)` unsubscribes from channel\n- Request/response correlation via UUID v4\n- Timeout after 30 seconds rejects promise\n- Subscriptions cleaned up on unmount\n- Returns `isConnected` and `readyState` state\n\n**_Prompt**:\nImplement `keyrx_ui_v2/src/hooks/useUnifiedApi.ts` following the design in section 2.1.5. Use the `react-use-websocket` library for WebSocket management with auto-reconnect. Implement query and command methods that generate UUIDs, track pending requests in a useRef Map, send ClientMessage, and return Promises that resolve/reject when the matching Response is received. Implement subscribe/unsubscribe methods that track handlers in a useRef Map and send Subscribe/Unsubscribe messages. Handle incoming messages in a useEffect that checks the message type and either resolves pending requests or calls subscription handlers. Add 30-second timeout for requests. Export isConnected and readyState from the underlying WebSocket hook.\n\n---\n\n#### [ ] 1.2.3 Create Type-Safe RPC Client Wrapper\n\n**Requirements**: REQ-1 (AC2, AC3, AC4)\n**Files**:\n- `keyrx_ui_v2/src/api/rpc.ts` (new)\n- `keyrx_ui_v2/src/api/types.ts` (modify)\n\n**Success Criteria**:\n- `RpcClient` class wraps useUnifiedApi\n- Type-safe methods for all RPC operations\n- Profile methods: getProfiles, createProfile, activateProfile, deleteProfile, duplicateProfile, renameProfile\n- Device methods: getDevices, renameDevice, setScopeDevice, forgetDevice\n- Config methods: getConfig, updateConfig, getLayers, setKeyMapping, deleteKeyMapping\n- Metrics methods: getLatency, getEvents, clearEvents\n- Subscription methods: onDaemonState, onEvents, onLatency\n- All methods have proper TypeScript return types\n- JSDoc comments on all public methods\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/api/rpc.ts` with a RpcClient class that wraps the useUnifiedApi hook and provides type-safe methods for all RPC operations (design section 2.1.5). The constructor should accept the result of useUnifiedApi(). Implement all 20+ methods with proper TypeScript types for parameters and return values. For example, `async getProfiles(): Promise<Profile[]>` should call `this.api.query('getProfiles')` and return the result. Subscription methods like `onDaemonState(handler: (state: DaemonState) => void): void` should call `this.api.subscribe('daemon-state', handler)`. Add JSDoc comments describing what each method does.\n\n---\n\n#### [ ] 1.2.4 Write useUnifiedApi Tests\n\n**Requirements**: REQ-1 (AC1, AC2, AC3, AC6, AC9)\n**Files**:\n- `keyrx_ui_v2/src/hooks/useUnifiedApi.test.ts` (new)\n\n**Success Criteria**:\n- Test connects to WebSocket successfully\n- Test sends query and receives response\n- Test sends command and verifies it completes\n- Test subscribes to channel and receives events\n- Test unsubscribes and stops receiving events\n- Test request timeout after 30 seconds\n- Test multiple concurrent requests with different IDs\n- Test auto-reconnect on disconnect\n- Test handles server errors correctly\n- All tests use mock WebSocket server\n\n**_Prompt**:\nCreate comprehensive unit tests for useUnifiedApi in `keyrx_ui_v2/src/hooks/useUnifiedApi.test.ts`. Use `@testing-library/react-hooks` and a mock WebSocket server (e.g., mock-socket or WS). Test scenarios: (1) connection and handshake, (2) query returns response, (3) command executes, (4) subscription receives events, (5) unsubscribe stops events, (6) request timeout rejects promise, (7) concurrent requests with different IDs are correlated correctly, (8) auto-reconnect on disconnect, (9) server error responses reject promises. Each test should render the hook, perform operations, and assert the expected behavior.\n\n---\n\n#### [ ] 1.2.5 End-to-End RPC Communication Test\n\n**Requirements**: REQ-1 (AC1-AC10)\n**Files**:\n- `keyrx_ui_v2/tests/integration/rpc-communication.test.ts` (new)\n\n**Success Criteria**:\n- Test starts real daemon in test mode\n- Test creates RpcClient with useUnifiedApi\n- Test executes full profile workflow (create, activate, delete)\n- Test subscribes to daemon-state and verifies events\n- Test executes config update and verifies validation\n- Test cleans up resources on completion\n- All acceptance criteria from REQ-1 verified end-to-end\n\n**_Prompt**:\nCreate an end-to-end integration test in `keyrx_ui_v2/tests/integration/rpc-communication.test.ts` that verifies the complete RPC stack works from React hook to Rust daemon. Use Vitest with a beforeAll hook to start the daemon in test mode (headless, test port). Create a test component that uses useUnifiedApi and RpcClient. Execute a complete workflow: (1) connect and verify handshake, (2) create a new profile, (3) subscribe to daemon-state, (4) activate the profile, (5) verify state change event is received, (6) update config, (7) delete the profile, (8) disconnect. Use afterAll to stop the daemon. This test verifies all acceptance criteria from REQ-1 work together.\n\n---\n\n## Phase 2: Monaco Code Editor Integration (REQ-2)\n\n#### [ ] 2.1 Monaco Editor Component\n\n**Requirements**: REQ-2 (AC1, AC2, AC3, AC4, AC5, AC6, AC7, AC8, AC9, AC10)\n**Files**:\n- `keyrx_ui_v2/src/components/MonacoEditor.tsx` (new)\n\n**Success Criteria**:\n- Component renders Monaco editor with Rhai language\n- Syntax highlighting for keywords, operators, strings, numbers, comments\n- Dark theme with color scheme matching design\n- Error markers display at correct line/column with red squiggles\n- F8 keyboard shortcut jumps to next error\n- Hover over error shows tooltip with message\n- Validation runs with 500ms debounce\n- Status bar shows validation status (\"✓ No issues\" or \"X errors\")\n- Graceful degradation if WASM unavailable\n- Quick fix lightbulb for errors (if applicable)\n- Component accepts value, onChange, onValidate, readOnly props\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/components/MonacoEditor.tsx` following the design in section 2.2.1. Use `@monaco-editor/react` package. Implement beforeMount to register the Rhai language with monarch tokenizer (keywords, operators, syntax rules) and define a custom dark theme. Implement onMount to configure editor options (minimap disabled, fontSize 14, tabSize 2, rulers at 80/120) and add F8 keybinding to jump to next error. Use useEffect with 500ms debounce to run WASM validation when value changes. Convert validation errors to Monaco markers and call editor.setModelMarkers. Implement validation status display showing error count or success message. Handle case where WASM is unavailable by showing \"Validation unavailable\" status. Add comprehensive props interface with TypeScript types.\n\n---\n\n#### [ ] 2.2 WASM Integration Hook\n\n**Requirements**: REQ-2 (AC8, AC9), REQ-5 (AC1, AC2, AC3, AC4, AC5, AC6)\n**Files**:\n- `keyrx_ui_v2/src/hooks/useWasm.ts` (new)\n\n**Success Criteria**:\n- Hook initializes WASM module on mount\n- `isWasmReady` state tracks initialization status\n- `validateConfig(code)` calls WASM validate_config and returns errors\n- `runSimulation(code, input)` calls WASM simulate and returns result\n- Error state tracked if WASM fails to load\n- Graceful handling of WASM errors (returns empty errors)\n- Hook memoizes validation and simulation functions\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/hooks/useWasm.ts` following the design in section 2.2.2. Use useEffect to call the WASM module's init() function on mount and set isWasmReady to true on success. Implement validateConfig using useCallback that checks isWasmReady, calls the WASM validate_config function, and returns the parsed validation errors. Implement runSimulation similarly for the simulate function. Track error state if init() fails. Return `{ isWasmReady, error, validateConfig, runSimulation }`. Add error handling that logs failures but doesn't crash the app (return empty array for validation errors if WASM is not ready).\n\n---\n\n#### [ ] 2.3 Monaco Editor Tests\n\n**Requirements**: REQ-2 (AC1-AC10)\n**Files**:\n- `keyrx_ui_v2/src/components/MonacoEditor.test.tsx` (new)\n\n**Success Criteria**:\n- Test renders Monaco editor\n- Test syntax highlighting applied (check token classes)\n- Test validation errors create markers\n- Test F8 keyboard shortcut jumps to next error\n- Test hover shows error tooltip\n- Test onChange callback fires when edited\n- Test debounce delays validation by 500ms\n- Test graceful degradation when WASM unavailable\n- Test readOnly prop disables editing\n\n**_Prompt**:\nCreate unit tests for MonacoEditor in `keyrx_ui_v2/src/components/MonacoEditor.test.tsx`. Mock the WASM module and Monaco editor. Test scenarios: (1) component renders, (2) value prop displays in editor, (3) onChange callback fires when user types, (4) validation errors from WASM create markers at correct lines, (5) onValidate callback receives error array, (6) F8 keybinding simulated by calling registered command, (7) debounce delays validation (use jest.useFakeTimers), (8) WASM unavailable shows fallback status, (9) readOnly prop makes editor non-editable. Use @testing-library/react and verify all acceptance criteria from REQ-2.\n\n---\n\n## Phase 3: Real-Time Dashboard (REQ-3)\n\n#### [ ] 3.1 Dashboard Page Component\n\n**Requirements**: REQ-3 (AC1, AC2, AC3)\n**Files**:\n- `keyrx_ui_v2/src/pages/DashboardPage.tsx` (new)\n\n**Success Criteria**:\n- Page connects to WebSocket on mount\n- Connection banner displays status (green \"Connected\" or red \"Disconnected\")\n- Auto-reconnects every 3 seconds on disconnect\n- Subscribes to daemon-state, events, latency channels\n- Unsubscribes on unmount\n- Renders StateIndicatorPanel, MetricsChart, DashboardEventTimeline\n- Passes state data to child components\n- Responsive layout (mobile stacks vertically, desktop 2-column grid)\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/pages/DashboardPage.tsx` following the design in section 2.3.1. Use useUnifiedApi hook to connect to WebSocket. Use RpcClient to subscribe to all three channels on mount. Track daemonState, events array (max 100, FIFO), and latencyHistory array (max 60 points) in useState. Update state when subscription events arrive. Render connection banner with green/red styling based on isConnected. Render StateIndicatorPanel with daemonState, MetricsChart with latencyHistory, and DashboardEventTimeline with events. Clean up subscriptions in useEffect return. Use TailwindCSS classes for responsive layout (single column on mobile, 2-column grid on desktop ≥1024px).\n\n---\n\n#### [ ] 3.2 State Indicator Panel Component\n\n**Requirements**: REQ-3 (AC4)\n**Files**:\n- `keyrx_ui_v2/src/components/StateIndicatorPanel.tsx` (new)\n\n**Success Criteria**:\n- Displays active modifiers as blue badges\n- Displays active locks as orange badges\n- Displays current layer as green badge\n- Shows \"None\" when no modifiers/locks active\n- Responsive grid layout (1 column mobile, 3 columns desktop)\n- Updates immediately when state prop changes\n- Accessible labels and ARIA attributes\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/components/StateIndicatorPanel.tsx` following the design in section 2.3.2. Accept a `state: DaemonState | null` prop. If state is null, show a loading message. Otherwise, render a 3-column grid (single column on mobile) with sections for Modifiers, Locks, and Layer. Map state.modifiers to blue badges with text \"MOD_{id}\". Map state.locks to orange badges with text \"LOCK_{id}\". Show the active layer as a green badge. If arrays are empty, show \"None\" in gray. Use TailwindCSS for styling (bg-blue-600 for modifiers, bg-orange-600 for locks, bg-green-600 for layer). Add ARIA labels for accessibility.\n\n---\n\n#### [ ] 3.3 Metrics Chart Component\n\n**Requirements**: REQ-3 (AC5, AC9)\n**Files**:\n- `keyrx_ui_v2/src/components/MetricsChart.tsx` (new)\n\n**Success Criteria**:\n- Renders LineChart with avg, P95, P99 lines\n- X-axis shows time/index, Y-axis shows milliseconds\n- Reference line at 5ms (performance target) in red\n- Converts microseconds to milliseconds for display\n- Rolling 60-second window (60 data points max)\n- Responsive chart (uses ResponsiveContainer)\n- Tooltip shows values on hover\n- Legend identifies each line\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/components/MetricsChart.tsx` following the design in section 2.3.3. Use Recharts library (LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine). Accept `data: LatencyMetrics[]` prop. Transform data by converting microseconds to milliseconds (divide by 1000) and mapping to chart data format. Render three lines: avg (blue), p95 (orange), p99 (red). Add reference line at y=5ms in red with label \"Target (5ms)\". Configure dark theme colors matching TailwindCSS slate palette. Set height to 300px. Add axis labels and legend.\n\n---\n\n#### [ ] 3.4 Dashboard Event Timeline Component\n\n**Requirements**: REQ-3 (AC6, AC7, AC8, AC9)\n**Files**:\n- `keyrx_ui_v2/src/components/DashboardEventTimeline.tsx` (new)\n\n**Success Criteria**:\n- Renders virtualized list of events (react-window)\n- Displays newest events first (prepend)\n- FIFO queue with max 100 events\n- Pause button stops updates, resume button restarts\n- Clear button empties event list\n- Tooltip on hover shows full event details\n- Formats timestamp as human-readable relative time\n- Formats key code as readable label (e.g., \"A\", \"Enter\")\n- Responsive (single column, vertical scroll)\n\n**_Prompt**:\nCreate `keyrx_ui_v2/src/components/DashboardEventTimeline.tsx` using react-window for virtualized scrolling (design section 2.3.1). Accept `events: KeyEvent[]`, `isPaused: boolean`, `onTogglePause: () => void`, `onClear: () => void` props. Render FixedSizeList with height 400px, itemSize 50px. Each row displays keyCode (formatted as readable label), eventType, and timestamp (formatted as relative time like \"2s ago\"). Add Pause/Resume and Clear buttons above the list. Use TailwindCSS for styling. Add tooltip on hover showing full event details (timestamp in microseconds, latency, layer). Component should be purely presentational - parent (DashboardPage) handles state.\n\n---\n\n#### [ ] 3.5 Dashboard Tests\n\n**Requirements**: REQ-3 (AC1-AC10)\n**Files**:\n- `keyrx_ui_v2/src/pages/DashboardPage.test.tsx` (new)\n- `keyrx_ui_v2/src/components/StateIndicatorPanel.test.tsx` (new)\n- `keyrx_ui_v2/src/components/MetricsChart.test.tsx` (new)\n- `keyrx_ui_v2/src/components/DashboardEventTimeline.test.tsx` (new)\n\n**Success Criteria**:\n- Test DashboardPage connects to WebSocket on mount\n- Test connection banner shows connected/disconnected status\n- Test subscribes to all channels\n- Test unsubscribes on unmount\n- Test StateIndicatorPanel renders modifiers, locks, layer\n- Test MetricsChart renders lines and reference line\n- Test DashboardEventTimeline renders events in FIFO order\n- Test pause button stops updates\n- Test event tooltip shows details on hover\n- All REQ-3 acceptance criteria verified\n\n**_Prompt**:\nCreate comprehensive tests for all dashboard components. For DashboardPage, mock useUnifiedApi and verify it connects, subscribes to channels, and renders child components. For StateIndicatorPanel, test it renders badges for modifiers/locks/layer and shows \"None\" when empty. For MetricsChart, test it renders lines and reference line with mock data. For DashboardEventTimeline, test it renders events, pause/resume works, FIFO limit enforced, and tooltip appears on hover. Use @testing-library/react and mock all external dependencies. Verify all acceptance criteria from REQ-3.\n\n---\n\n## Phase 4: Tab-Based Configuration Editor (REQ-4)\n\n#### [ ] 4.1 Update ConfigPage with Tabs\n\n**Requirements**: REQ-4 (AC1, AC2, AC3, AC4, AC5, AC6, AC7, AC8, AC9, AC10)\n**Files**:\n- `keyrx_ui_v2/src/pages/ConfigPage.tsx` (modify)\n\n**Success Criteria**:\n- Visual Editor tab active by default\n- Code Editor tab renders Monaco when clicked\n- Visual Editor tab renders KeyboardVisualizer when clicked\n- Active tab has primary background and white text\n- Inactive tabs have gray text and hover effect\n- Changes persist across tab switches (single state)\n- Validation status panel shows in both tabs\n- Save button works from either tab\n- Ctrl+S / Cmd+S triggers save in either tab\n- Unsaved changes not lost when switching tabs\n\n**_Prompt**:\nModify `keyrx_ui_v2/src/pages/ConfigPage.tsx` to add tab-based editing (design section 2.4). Add state `activeTab: 'visual' | 'code'` with default 'visual'. Render tab buttons above the editor area with conditional styling (primary background when active). Conditionally render KeyboardVisualizer when activeTab is 'visual' or MonacoEditor when activeTab is 'code'. Both editors share the same configCode state, so changes persist across tabs. Render validation status panel above tabs that shows in both modes. Implement save handler that checks for validation errors and uses RpcClient to call updateConfig. Add keyboard listener for Ctrl+S / Cmd+S. Ensure tab switching doesn't lose unsaved changes by using single source of truth for configCode.\n\n---\n\n#### [ ] 4.2 ConfigPage Tab Tests\n\n**Requirements**: REQ-4 (AC1-AC10)\n**Files**:\n- `keyrx_ui_v2/src/pages/ConfigPage.test.tsx` (modify/create)\n\n**Success Criteria**:\n- Test Visual Editor tab active by default\n- Test clicking Code Editor tab switches view\n- Test clicking Visual Editor tab switches back\n- Test active tab has correct styling\n- Test changes in Code Editor persist when switching to Visual\n- Test validation status shows in both tabs\n- Test save button works from both tabs\n- Test Ctrl+S triggers save in both tabs\n- Test unsaved changes not lost on tab switch\n- Test validation errors prevent save in both tabs\n\n**_Prompt**:\nCreate comprehensive tests for ConfigPage tabs in `keyrx_ui_v2/src/pages/ConfigPage.test.tsx`. Test scenarios: (1) Visual Editor tab is active on mount, (2) clicking Code Editor tab renders Monaco, (3) clicking Visual Editor tab renders KeyboardVisualizer, (4) active tab has bg-primary-500 class, (5) typing in Code Editor then switching to Visual doesn't lose changes (verify configCode state), (6) validation status panel appears in both tabs, (7) save button calls updateConfig RPC method, (8) Ctrl+S keyboard event triggers save, (9) validation errors disable save button, (10) switching tabs with unsaved changes doesn't revert. Use @testing-library/react and userEvent for interactions.\n\n---\n\n## Phase 5: WASM Integration (REQ-5)\n\n#### [ ] 5.1 Configure WASM Build\n\n**Requirements**: REQ-5 (AC1, AC2, AC9, AC10)\n**Files**:\n- `keyrx_core/Cargo.toml` (modify)\n- `keyrx_core/src/lib.rs` (modify)\n\n**Success Criteria**:\n- Cargo.toml has cdylib and rlib crate types\n- wasm feature enables wasm-bindgen dependencies\n- Profile.release optimized for size (opt-level=\"z\", lto=true, strip=true)\n- lib.rs exports validate_config and simulate functions with #[wasm_bindgen]\n- Functions accept/return JsValue for JS interop\n- WASM module builds successfully with wasm-pack\n- Output in keyrx_ui_v2/src/wasm/pkg directory\n\n**_Prompt**:\nConfigure keyrx_core for WASM compilation (design section 2.5.1). Modify `keyrx_core/Cargo.toml` to add crate-type = [\"cdylib\", \"rlib\"], add wasm feature that enables wasm-bindgen and serde-wasm-bindgen dependencies, and optimize release profile for size (opt-level=\"z\", lto=true, codegen-units=1, strip=true). Modify `keyrx_core/src/lib.rs` to export `validate_config(code: &str) -> JsValue` and `simulate(code: &str, input: JsValue) -> JsValue` with #[wasm_bindgen] attribute when wasm feature is enabled. Functions should use serde-wasm-bindgen to convert between Rust types and JsValue. Test build with: `cd keyrx_core && wasm-pack build --target web --out-dir ../keyrx_ui_v2/src/wasm/pkg --release`.\n\n---\n\n#### [ ] 5.2 Integrate WASM into Vite Build\n\n**Requirements**: REQ-5 (AC9, AC10)\n**Files**:\n- `keyrx_ui_v2/vite.config.ts` (modify)\n- `keyrx_ui_v2/package.json` (modify)\n\n**Success Criteria**:\n- vite-plugin-wasm and vite-plugin-top-level-await installed\n- Plugins configured in vite.config.ts\n- WASM module excluded from optimizeDeps\n- Build target set to esnext\n- Monaco and WASM in separate chunks (manualChunks)\n- npm run build includes WASM in dist/\n- Hot reload rebuilds WASM on source changes (dev mode)\n\n**_Prompt**:\nConfigure Vite to support WASM modules (design section 2.5.1). Install dependencies: `npm install --save-dev vite-plugin-wasm vite-plugin-top-level-await`. Modify `keyrx_ui_v2/vite.config.ts` to add wasm() and topLevelAwait() plugins. Set build.target to 'esnext'. Configure build.rollupOptions.output.manualChunks to separate 'vendor', 'monaco', and 'charts' into different bundles. Add optimizeDeps.exclude for '@/wasm/keyrx_core'. Add scripts to package.json: `\"build:wasm\": \"cd ../keyrx_core && wasm-pack build --target web --out-dir ../keyrx_ui_v2/src/wasm/pkg --release\"` and update `\"build\"` to run build:wasm first.\n\n---\n\n#### [ ] 5.3 Implement WASM Validation\n\n**Requirements**: REQ-5 (AC2, AC3, AC4, AC5, AC6)\n**Files**:\n- `keyrx_core/src/lib.rs` (modify)\n- `keyrx_core/src/wasm/validation.rs` (new)\n\n**Success Criteria**:\n- validate_config parses Rhai code using keyrx_compiler\n- Returns JSON array of validation errors with line, column, length, message\n- Errors match daemon validation byte-for-byte (deterministic)\n- Invalid syntax returns parse errors\n- Valid configuration returns empty array\n- Function works in browser WASM environment\n- Unit tests verify validation matches compiler\n\n**_Prompt**:\nImplement WASM validation in keyrx_core. Create `keyrx_core/src/wasm/validation.rs` that uses the existing keyrx_compiler to parse Rhai code. The `validate_config(code: &str) -> String` function should call the compiler's parse function, catch errors, and return a JSON string containing an array of validation errors with fields: line (number), column (number), length (number), message (string). If the code is valid, return \"[]\". Ensure the validation logic is IDENTICAL to what the daemon uses (same parser, same error messages) for deterministic behavior. Export this function from lib.rs with #[wasm_bindgen]. Add unit tests that verify validation results match.\n\n---\n\n#### [ ] 5.4 Implement WASM Simulation\n\n**Requirements**: REQ-5 (AC7, AC8)\n**Files**:\n- `keyrx_core/src/lib.rs` (modify)\n- `keyrx_core/src/wasm/simulator.rs` (new)\n\n**Success Criteria**:\n- simulate parses config and compiles to executable form\n- Accepts JSON array of input events (keyCode, eventType, timestamp)\n- Runs simulation using core engine (same as daemon)\n- Returns JSON with state transitions, output events, latency estimates\n- Simulation is deterministic (same input → same output)\n- Uses virtual clock for time-independent tests\n- Results match daemon behavior byte-for-byte\n- Unit tests verify determinism\n\n**_Prompt**:\nImplement WASM simulation in keyrx_core. Create `keyrx_core/src/wasm/simulator.rs` that compiles the Rhai configuration and simulates key event processing using the SAME core logic as the daemon (keyrx_core DFA and state machine). The `simulate(code: &str, input_json: &str) -> String` function should: (1) parse and compile the config, (2) parse input JSON as KeyEvent array, (3) initialize simulator state, (4) process each input event through the DFA, (5) record state transitions and output events, (6) return JSON with results including state changes, output events, and latency estimates. Use a virtual clock (not wall time) for deterministic timing. Export from lib.rs with #[wasm_bindgen]. Add tests that verify simulation results match daemon behavior.\n\n---\n\n#### [ ] 5.5 WASM Integration Tests\n\n**Requirements**: REQ-5 (AC1-AC10)\n**Files**:\n- `keyrx_ui_v2/tests/wasm/validation.test.ts` (new)\n- `keyrx_ui_v2/tests/wasm/simulation.test.ts` (new)\n\n**Success Criteria**:\n- Test WASM module initializes successfully\n- Test validate_config returns errors for invalid syntax\n- Test validate_config returns empty array for valid config\n- Test validation errors have correct line/column numbers\n- Test validation matches daemon (same config → same errors)\n- Test simulate returns state transitions for valid input\n- Test simulation is deterministic (same input → same output)\n- Test simulation matches daemon behavior\n- Test graceful failure when WASM not available\n\n**_Prompt**:\nCreate comprehensive WASM integration tests. In `keyrx_ui_v2/tests/wasm/validation.test.ts`, test that: (1) WASM init succeeds, (2) validate_config detects syntax errors with correct line/column, (3) valid config returns empty array, (4) validation results match daemon (compile same config with daemon and WASM, compare errors). In `keyrx_ui_v2/tests/wasm/simulation.test.ts`, test that: (1) simulate processes events correctly, (2) same input produces same output (run twice, compare), (3) simulation results match daemon (run same input through daemon and WASM, compare output), (4) virtual clock makes tests time-independent. Use Vitest and import the WASM module directly.\n\n---\n\n## Phase 6: Responsive UI (REQ-6)\n\n#### [ ] 6.1 Implement Responsive Navigation\n\n**Requirements**: REQ-6 (AC1, AC2)\n**Files**:\n- `keyrx_ui_v2/src/components/BottomNav.tsx` (new)\n- `keyrx_ui_v2/src/components/Sidebar.tsx` (new)\n- `keyrx_ui_v2/src/components/Layout.tsx` (modify)\n\n**Success Criteria**:\n- BottomNav renders on viewport < 768px with icon navigation\n- Sidebar renders on viewport >= 768px with fixed left navigation\n- Navigation links highlight active page\n- Both nav components share same routes\n- Smooth transition between mobile/desktop nav\n- Minimum 44x44px tap targets on mobile\n- ARIA labels for accessibility\n\n**_Prompt**:\nImplement responsive navigation components. Create `keyrx_ui_v2/src/components/BottomNav.tsx` that renders a fixed bottom navigation bar with icons for Profiles, Config, Dashboard, Devices (visible only on screens < 768px using Tailwind's `md:hidden`). Create `keyrx_ui_v2/src/components/Sidebar.tsx` that renders a fixed left sidebar with full text links (visible only on screens >= 768px using `hidden md:block`). Both components should use react-router's NavLink for active state. Ensure all nav items have min-h-[44px] min-w-[44px] on mobile for touch accessibility. Update `keyrx_ui_v2/src/components/Layout.tsx` to conditionally render both components. Add ARIA labels and landmarks (nav role).\n\n---\n\n#### [ ] 6.2 Make ConfigPage Responsive\n\n**Requirements**: REQ-6 (AC3, AC4)\n**Files**:\n- `keyrx_ui_v2/src/pages/ConfigPage.tsx` (modify)\n\n**Success Criteria**:\n- Single-column layout on < 768px\n- Multi-column grid layout on >= 1024px\n- Tab buttons stack on mobile, inline on desktop\n- Monaco editor height adapts to viewport\n- KeyboardVisualizer scrolls horizontally on mobile\n- Save button full-width on mobile, auto-width on desktop\n- Validation status panel responsive\n- All interactive elements >= 44px tap target on mobile\n\n**_Prompt**:\nMake ConfigPage responsive. Modify the component to use Tailwind responsive classes: (1) main container `flex-col gap-4 md:gap-6`, (2) tab buttons `grid grid-cols-2 sm:flex sm:gap-2` so they stack 2-per-row on mobile and inline on tablet+, (3) save button `w-full md:w-auto` so it's full-width on mobile, (4) KeyboardVisualizer wrapper `overflow-x-auto md:overflow-x-visible` for horizontal scroll on mobile, (5) validation status panel `text-sm md:text-base`, (6) all buttons `min-h-[44px] md:min-h-0` for touch targets. Test at 3 breakpoints: 375px (mobile), 768px (tablet), 1024px (desktop).\n\n---\n\n#### [ ] 6.3 Make DashboardPage Responsive\n\n**Requirements**: REQ-6 (AC5, AC6)\n**Files**:\n- `keyrx_ui_v2/src/pages/DashboardPage.tsx` (modify)\n\n**Success Criteria**:\n- Components stack vertically on mobile\n- State indicators and chart in 2-column grid on desktop >= 1024px\n- Connection banner responsive text size\n- MetricsChart responsive (ResponsiveContainer)\n- EventTimeline full-width on all breakpoints\n- Pause/Clear buttons grouped appropriately on mobile\n- All interactive elements >= 44px tap target on mobile\n\n**_Prompt**:\nMake DashboardPage responsive. Modify the component layout: (1) main container `flex-col gap-4 p-4 md:p-6`, (2) StateIndicatorPanel and MetricsChart in `grid grid-cols-1 lg:grid-cols-2 gap-4` so they stack on mobile/tablet and side-by-side on desktop, (3) connection banner `text-sm md:text-base`, (4) pause/clear buttons `flex flex-col sm:flex-row gap-2` so they stack on mobile, (5) all buttons `min-h-[44px] md:min-h-0`. MetricsChart already uses ResponsiveContainer so it auto-scales. Test at 3 breakpoints.\n\n---\n\n#### [ ] 6.4 Visual Regression Tests\n\n**Requirements**: REQ-6 (AC8)\n**Files**:\n- `keyrx_ui_v2/e2e/visual/responsive.spec.ts` (new)\n\n**Success Criteria**:\n- Screenshots captured at 375px, 768px, 1024px viewports\n- ConfigPage screenshots at all 3 breakpoints\n- DashboardPage screenshots at all 3 breakpoints\n- ProfilesPage screenshots at all 3 breakpoints\n- Navigation screenshots (BottomNav on mobile, Sidebar on desktop)\n- Baseline images stored in repo\n- CI fails on visual regression\n\n**_Prompt**:\nCreate visual regression tests using Playwright. In `keyrx_ui_v2/e2e/visual/responsive.spec.ts`, write tests that: (1) set viewport to 375px (mobile) and capture screenshots of all pages, (2) set viewport to 768px (tablet) and capture screenshots, (3) set viewport to 1024px (desktop) and capture screenshots. Use `page.setViewportSize({ width, height })` and `page.screenshot()`. Store baseline images in `e2e/visual/baselines/`. Configure Playwright to compare screenshots with threshold tolerance. Test scenarios: ConfigPage with both tabs, DashboardPage with events, ProfilesPage with profiles, Navigation components. Run with `npm run test:visual`.\n\n---\n\n#### [ ] 6.5 TailwindCSS Purge Configuration\n\n**Requirements**: REQ-6 (AC9, AC10)\n**Files**:\n- `keyrx_ui_v2/tailwind.config.js` (modify)\n\n**Success Criteria**:\n- Content paths configured to scan all source files\n- Unused classes purged in production build\n- Custom colors, spacing, breakpoints defined\n- Dark mode enabled (class strategy)\n- Final bundle size < 50KB for Tailwind CSS\n- No unused CSS in production build\n\n**_Prompt**:\nOptimize TailwindCSS configuration in `keyrx_ui_v2/tailwind.config.js`. Set content paths to scan `./src/**/*.{js,jsx,ts,tsx}` and `./index.html`. Configure purge to remove unused styles in production. Define custom theme: extend colors with primary (blue) and secondary (slate) shades, add custom breakpoints if needed, configure dark mode with class strategy. Add safelist for dynamically generated classes if any. Build and verify CSS bundle size is < 50KB gzipped. Run `npm run build` and check `dist/assets/*.css` size.\n\n---\n\n## Phase 7: Testing Infrastructure (REQ-7)\n\n#### [ ] 7.1 Setup Unit Test Infrastructure\n\n**Requirements**: REQ-7 (AC1, AC2, AC10)\n**Files**:\n- `keyrx_ui_v2/vitest.config.ts` (new)\n- `keyrx_ui_v2/package.json` (modify)\n- `keyrx_core/tests/` (new test files)\n\n**Success Criteria**:\n- Vitest configured for React testing\n- @testing-library/react and @testing-library/jest-dom setup\n- Coverage reporting enabled (v8 provider)\n- Coverage thresholds: 80% overall, 90% for keyrx_core\n- Test scripts in package.json: test, test:watch, test:coverage\n- All existing components have unit tests\n- Rust tests run with cargo test\n\n**_Prompt**:\nSetup unit testing infrastructure. Create `keyrx_ui_v2/vitest.config.ts` with Vitest configuration: (1) use jsdom environment for React, (2) setup files for @testing-library/jest-dom, (3) coverage with v8 provider, (4) coverage thresholds (lines: 80%, functions: 80%, branches: 80%), (5) exclude node_modules and dist from coverage. Add test scripts to package.json: `\"test\": \"vitest run\"`, `\"test:watch\": \"vitest\"`, `\"test:coverage\": \"vitest run --coverage\"`. Ensure all existing components (Card, Dropdown, KeyboardVisualizer, etc.) have corresponding .test.tsx files with > 80% coverage. For Rust, ensure `cargo test --workspace` runs all tests and configure tarpaulin for coverage with > 90% threshold for keyrx_core.\n\n---\n\n#### [ ] 7.2 Setup Integration Tests\n\n**Requirements**: REQ-7 (AC3, AC10)\n**Files**:\n- `keyrx_ui_v2/tests/integration/` (new directory)\n- `keyrx_daemon/tests/integration/` (expand)\n\n**Success Criteria**:\n- Integration test framework setup (Vitest for UI, tokio::test for daemon)\n- Test harness can start/stop daemon programmatically\n- Tab switching flow tested end-to-end\n- Validation flow tested (invalid config → errors → valid config → save)\n- WebSocket updates tested (subscribe → event → state update)\n- All integration tests pass\n- Integration tests run in CI\n\n**_Prompt**:\nSetup integration testing infrastructure. For UI, create `keyrx_ui_v2/tests/integration/` directory with test files for key workflows: (1) config-editor.test.tsx tests tab switching and validation flow, (2) dashboard-updates.test.tsx tests WebSocket subscription and state updates, (3) profile-workflow.test.tsx tests create/activate/delete profile. Use a test harness that starts the daemon in test mode (headless, test port) before tests and stops it after. For daemon, expand `keyrx_daemon/tests/integration/` with tests for WebSocket RPC (task 1.1.9) and event broadcasting. Configure CI to run integration tests after unit tests pass.\n\n---\n\n#### [ ] 7.3 Setup E2E Tests with Playwright\n\n**Requirements**: REQ-7 (AC4, AC10)\n**Files**:\n- `keyrx_ui_v2/playwright.config.ts` (new)\n- `keyrx_ui_v2/e2e/` (new directory)\n- `keyrx_ui_v2/package.json` (modify)\n\n**Success Criteria**:\n- Playwright configured with Chromium, Firefox, WebKit\n- E2E tests for full workflows (create profile, edit config, activate, monitor dashboard)\n- Tests run against real daemon (started automatically)\n- Screenshots/videos on failure\n- E2E test scripts in package.json: test:e2e, test:e2e:ui\n- All E2E tests pass\n- E2E tests run in CI\n\n**_Prompt**:\nSetup Playwright E2E testing. Install Playwright: `npm install --save-dev @playwright/test`. Create `keyrx_ui_v2/playwright.config.ts` with configuration: (1) baseURL http://localhost:9867, (2) webServer starts daemon before tests, (3) browsers: chromium, firefox, webkit, (4) screenshots/videos on failure, (5) retries on failure. Create `keyrx_ui_v2/e2e/` with test files: (1) profile-crud.spec.ts tests creating, activating, deleting profiles, (2) config-editor.spec.ts tests editing and saving config with Monaco, (3) dashboard-monitoring.spec.ts tests real-time dashboard updates. Add scripts to package.json: `\"test:e2e\": \"playwright test\"`, `\"test:e2e:ui\": \"playwright test --ui\"`. Configure CI to run E2E tests.\n\n---\n\n#### [ ] 7.4 Setup Accessibility Tests\n\n**Requirements**: REQ-7 (AC5, AC10)\n**Files**:\n- `keyrx_ui_v2/tests/a11y/` (new directory)\n- `keyrx_ui_v2/package.json` (modify)\n\n**Success Criteria**:\n- jest-axe configured for accessibility testing\n- All pages tested for WCAG AA compliance\n- Tests verify zero violations\n- Tests check keyboard navigation\n- Tests verify ARIA labels\n- Focus management tested\n- Color contrast tested\n- Tests fail CI if violations found\n\n**_Prompt**:\nSetup accessibility testing with jest-axe. Install: `npm install --save-dev jest-axe`. Create `keyrx_ui_v2/tests/a11y/` with test files for each page: (1) config-page.test.tsx, (2) dashboard-page.test.tsx, (3) profiles-page.test.tsx, (4) devices-page.test.tsx. Each test should: (1) render the component, (2) run axe(container) to check for violations, (3) assert expect(results).toHaveNoViolations(). Test keyboard navigation with userEvent.tab() to verify focus order. Test ARIA labels are present on interactive elements. Add script to package.json: `\"test:a11y\": \"vitest run tests/a11y\"`. Configure CI to run accessibility tests and fail build on violations.\n\n---\n\n#### [ ] 7.5 Setup Performance Tests\n\n**Requirements**: REQ-7 (AC6, AC10)\n**Files**:\n- `keyrx_ui_v2/tests/performance/` (new directory)\n- `keyrx_ui_v2/package.json` (modify)\n\n**Success Criteria**:\n- Bundle size test verifies < 500KB initial load (gzipped)\n- Lighthouse CI configured\n- Lighthouse score >= 90 for performance, accessibility, best practices\n- Monaco chunk < 2MB verified\n- WASM module < 1MB verified\n- Tests fail CI if thresholds exceeded\n- Performance budget enforced\n\n**_Prompt**:\nSetup performance testing. Create `keyrx_ui_v2/tests/performance/bundle-size.test.ts` that verifies bundle sizes after build: (1) main bundle < 500KB gzipped, (2) Monaco chunk < 2MB, (3) WASM module < 1MB. Use fs and zlib to measure gzipped sizes. Install Lighthouse CI: `npm install --save-dev @lhci/cli`. Create `.lighthouserc.js` config with budgets and assertions: performance >= 90, accessibility >= 90, best-practices >= 90. Configure URLs to test (profiles, config, dashboard). Add scripts to package.json: `\"test:perf\": \"vitest run tests/performance\"`, `\"test:lighthouse\": \"lhci autorun\"`. Configure CI to run performance tests after build.\n\n---\n\n#### [ ] 7.6 Configure Pre-Commit Hooks\n\n**Requirements**: REQ-7 (AC8, AC9, AC10)\n**Files**:\n- `.husky/pre-commit` (new)\n- `package.json` (modify)\n- `.git/hooks/pre-commit` (generated)\n\n**Success Criteria**:\n- Husky installed and configured\n- Pre-commit hook runs: clippy, rustfmt, tests\n- UI pre-commit runs: prettier, eslint, vitest\n- Commit blocked if checks fail\n- Hook runs automatically on git commit\n- Documentation for bypassing hook (--no-verify)\n\n**_Prompt**:\nSetup pre-commit hooks using Husky. Install: `npm install --save-dev husky lint-staged`. Run `npx husky install`. Create `.husky/pre-commit` script that runs: (1) for Rust files: cargo clippy --workspace -- -D warnings, cargo fmt --check, cargo test --workspace, (2) for TypeScript files: prettier --check, eslint, vitest run. Use lint-staged to run checks only on staged files. Configure lint-staged in package.json: `\"*.rs\": [\"cargo fmt --check\", \"cargo clippy -- -D warnings\"], \"*.{ts,tsx}\": [\"prettier --check\", \"eslint\", \"vitest related --run\"]`. Add prepare script to package.json: `\"prepare\": \"husky install\"`. Test that commit is blocked if checks fail.\n\n---\n\n## Phase 8: Build Process Integration (REQ-8)\n\n#### [ ] 8.1 Create WASM Build Script\n\n**Requirements**: REQ-8 (AC1, AC4, AC7)\n**Files**:\n- `scripts/build_wasm.sh` (new)\n\n**Success Criteria**:\n- Script builds keyrx_core with wasm32-unknown-unknown target\n- Uses wasm-pack with --release flag\n- Outputs to keyrx_ui_v2/src/wasm/pkg/\n- Strips debug symbols for size optimization\n- Verifies output files exist (keyrx_core_bg.wasm, keyrx_core.js, keyrx_core.d.ts)\n- Fails with clear error message if wasm-pack not installed\n- Logs build time and output size\n\n**_Prompt**:\nCreate `scripts/build_wasm.sh` that builds the WASM module. The script should: (1) check if wasm-pack is installed (if not, error with install instructions), (2) cd to keyrx_core directory, (3) run `wasm-pack build --target web --out-dir ../keyrx_ui_v2/src/wasm/pkg --release -- --features wasm`, (4) verify output files exist, (5) print build time and wasm file size, (6) exit 1 on failure with clear error message. Use bash set -e for error handling. Add header comment explaining what the script does and dependencies required. Make executable with chmod +x.\n\n---\n\n#### [ ] 8.2 Create UI Build Script\n\n**Requirements**: REQ-8 (AC2, AC5, AC7)\n**Files**:\n- `scripts/build_ui.sh` (new)\n\n**Success Criteria**:\n- Script runs WASM build first (calls build_wasm.sh)\n- Installs npm dependencies if node_modules missing\n- Runs npm run build to bundle UI\n- Verifies dist/index.html exists\n- Fails if WASM build fails\n- Fails if UI build fails\n- Logs build time and bundle size\n- Clears previous dist/ before build\n\n**_Prompt**:\nCreate `scripts/build_ui.sh` that builds the complete UI. The script should: (1) call scripts/build_wasm.sh to build WASM module first, (2) cd to keyrx_ui_v2 directory, (3) check if node_modules exists, if not run npm install, (4) remove previous dist/ directory, (5) run npm run build, (6) verify dist/index.html exists, (7) print bundle size summary (total size, gzipped size), (8) exit 1 on failure with clear error. Use bash set -e and set -o pipefail. Make executable. Test that WASM build failure prevents UI build.\n\n---\n\n#### [ ] 8.3 Integrate UI into Daemon Build\n\n**Requirements**: REQ-8 (AC3, AC6, AC9)\n**Files**:\n- `keyrx_daemon/build.rs` (modify)\n- `keyrx_daemon/src/web/static_files.rs` (already created in task 2.5.3)\n- `keyrx_daemon/Cargo.toml` (modify)\n\n**Success Criteria**:\n- build.rs verifies ../keyrx_ui_v2/dist exists\n- build.rs fails with helpful error if dist missing\n- Cargo.toml includes include_dir dependency\n- static_files.rs embeds UI_DIR with include_dir macro\n- Unit test verifies index.html embedded\n- Daemon build fails if UI not built\n- Embedded UI served correctly on http://localhost:9867/\n\n**_Prompt**:\nIntegrate UI embedding into daemon build (design section 2.5.3). Modify `keyrx_daemon/build.rs` to check if `../keyrx_ui_v2/dist` directory exists, if not print error: \"UI directory not found. Run 'scripts/build_ui.sh' first\" and call panic!. Add `println!(\"cargo:rerun-if-changed=../keyrx_ui_v2/dist\");` to rebuild if UI changes. Add include_dir to Cargo.toml dependencies. Verify `keyrx_daemon/src/web/static_files.rs` (created in design section 2.5.3) correctly embeds UI_DIR and serves files. Add unit test in static_files.rs that asserts UI_DIR.get_file(\"index.html\").is_some(). Test that daemon binary serves UI correctly after build.\n\n---\n\n#### [ ] 8.4 Create Master Build Script\n\n**Requirements**: REQ-8 (AC2, AC7, AC10)\n**Files**:\n- `scripts/build.sh` (modify)\n- `Makefile` (modify)\n\n**Success Criteria**:\n- Script builds in sequence: WASM → UI → daemon\n- Each step's output logged\n- Fails fast if any step fails\n- Prints summary at end (build time, binary sizes)\n- Makefile has `make build` target that calls script\n- Makefile has `make clean` target that removes all build artifacts\n- Script works from any directory (uses absolute paths)\n\n**_Prompt**:\nCreate master build script that orchestrates the complete build. Modify `scripts/build.sh` to: (1) call scripts/build_wasm.sh, (2) call scripts/build_ui.sh (which internally calls build_wasm, but that's idempotent), (3) build daemon with `cargo build --release -p keyrx_daemon`, (4) verify output binaries exist in target/release/, (5) print summary with build times and file sizes. Use bash set -e. Add colors for success/error messages (green/red). Update Makefile to add `build` target that calls scripts/build.sh and `clean` target that removes target/, keyrx_ui_v2/dist/, and keyrx_ui_v2/src/wasm/pkg/. Test that `make build` produces working binaries.\n\n---\n\n#### [ ] 8.5 Create Verification Script\n\n**Requirements**: REQ-8 (AC8, AC10)\n**Files**:\n- `scripts/verify.sh` (modify)\n\n**Success Criteria**:\n- Script runs: cargo clippy (all crates, -D warnings)\n- Script runs: cargo fmt --check\n- Script runs: cargo test --workspace\n- Script runs: npm test (UI unit tests)\n- Script runs: npm run test:e2e (UI E2E tests)\n- Script runs: cargo tarpaulin (coverage >= 80%)\n- Fails if any check fails\n- Prints summary of all checks at end\n- Makefile has `make verify` target\n\n**_Prompt**:\nCreate comprehensive verification script. Modify `scripts/verify.sh` to run quality checks in order: (1) `cargo fmt --check` for all Rust code, (2) `cargo clippy --workspace -- -D warnings` to catch warnings, (3) `cargo test --workspace` for unit/integration tests, (4) `cargo tarpaulin --workspace --out Stdout --exclude-files 'keyrx_ui*/*'` for coverage >= 80%, (5) cd to keyrx_ui_v2 and run `npm test -- --coverage` for UI unit tests with >= 80% coverage, (6) `npm run test:e2e` for Playwright E2E tests. Use colored output (green checkmark for pass, red X for fail). Print summary table at end showing which checks passed/failed. Exit 1 if any check fails. Update Makefile with `verify` target. Test that script catches violations.\n\n---\n\n#### [ ] 8.6 Configure CI/CD Pipeline\n\n**Requirements**: REQ-8 (AC10)\n**Files**:\n- `.github/workflows/ci.yml` (modify)\n- `.github/workflows/release.yml` (modify)\n\n**Success Criteria**:\n- CI workflow runs on push and pull_request\n- CI builds WASM → UI → daemon in sequence\n- CI runs verification script (all tests)\n- CI uploads coverage reports\n- CI caches dependencies (cargo, npm)\n- Release workflow builds all targets (Linux, Windows)\n- Release workflow creates GitHub release with binaries\n- CI fails build if any step fails\n\n**_Prompt**:\nConfigure GitHub Actions CI/CD pipeline. Modify `.github/workflows/ci.yml` to: (1) checkout code, (2) setup Rust with stable toolchain and wasm32-unknown-unknown target, (3) setup Node.js 18, (4) install wasm-pack, (5) cache cargo and npm dependencies, (6) run scripts/build.sh to build everything, (7) run scripts/verify.sh to run all tests and checks, (8) upload coverage reports to artifact, (9) fail build if any step fails. Modify `.github/workflows/release.yml` (triggered on tag push) to: (1) build for Linux and Windows targets, (2) create release artifacts (binaries, UI bundle), (3) create GitHub release with changelog, (4) upload artifacts to release. Test CI by pushing to a branch and verifying all steps pass.\n\n---\n\n## Summary\n\n**Total Tasks**: 62 atomic tasks across 8 phases\n\n**Estimated Effort**:\n- Phase 1 (RPC API): 9 tasks, ~2 weeks\n- Phase 2 (Monaco Editor): 3 tasks, ~1 week\n- Phase 3 (Dashboard): 5 tasks, ~1 week\n- Phase 4 (Config Tabs): 2 tasks, ~0.5 weeks\n- Phase 5 (WASM): 5 tasks, ~1 week\n- Phase 6 (Responsive UI): 5 tasks, ~1 week\n- Phase 7 (Testing): 6 tasks, ~1.5 weeks\n- Phase 8 (Build): 6 tasks, ~1 week\n\n**Total**: ~9-10 weeks with 1 developer, or ~6 weeks with parallel development (backend + frontend teams)\n\n**Critical Path**:\n1. Phase 1 (RPC API) must complete first - both backend and frontend\n2. Phase 2-4 can happen in parallel after Phase 1\n3. Phase 5 (WASM) can happen in parallel with Phase 1-4\n4. Phase 6-7 after Phase 2-5 complete\n5. Phase 8 throughout (build infrastructure supports all phases)\n\n**Success Criteria**:\nAll tasks marked `[x]` and all acceptance criteria from requirements verified.\n",
  "fileStats": {
    "size": 57834,
    "lines": 1042,
    "lastModified": "2025-12-31T23:34:10.432Z"
  },
  "comments": []
}