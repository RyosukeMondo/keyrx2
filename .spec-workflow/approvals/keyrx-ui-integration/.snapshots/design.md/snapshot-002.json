{
  "id": "snapshot_1767224915418_84x5ceql5",
  "approvalId": "approval_1767224066074_q1tkqj3vo",
  "approvalTitle": "keyrx-ui-integration Design Document",
  "version": 2,
  "timestamp": "2025-12-31T23:48:35.418Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## 1. System Architecture Overview\n\n### 1.1 High-Level Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                        Browser (Client)                      â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  React Application (keyrx_ui_v2)                            â”‚\nâ”‚  â”œâ”€â”€ Pages (Router)                                         â”‚\nâ”‚  â”‚   â”œâ”€â”€ ConfigPage (Visual + Code Editor Tabs)            â”‚\nâ”‚  â”‚   â”œâ”€â”€ DashboardPage (Real-time Monitoring)              â”‚\nâ”‚  â”‚   â”œâ”€â”€ ProfilesPage                                       â”‚\nâ”‚  â”‚   â””â”€â”€ DevicesPage                                        â”‚\nâ”‚  â”œâ”€â”€ Components                                             â”‚\nâ”‚  â”‚   â”œâ”€â”€ KeyboardVisualizer                                â”‚\nâ”‚  â”‚   â”œâ”€â”€ MonacoEditor (lazy-loaded)                        â”‚\nâ”‚  â”‚   â”œâ”€â”€ DashboardEventTimeline                            â”‚\nâ”‚  â”‚   â””â”€â”€ MetricsChart                                       â”‚\nâ”‚  â”œâ”€â”€ Hooks                                                  â”‚\nâ”‚  â”‚   â”œâ”€â”€ useUnifiedApi (WebSocket RPC client)              â”‚\nâ”‚  â”‚   â””â”€â”€ useWasm (WASM validation)                         â”‚\nâ”‚  â””â”€â”€ WASM Module (keyrx_core compiled to wasm32)           â”‚\nâ”‚      â”œâ”€â”€ validate_config()                                 â”‚\nâ”‚      â””â”€â”€ simulate()                                         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                              â”‚\n                              â”œâ”€ HTTP (initial page load)\n                              â””â”€ WebSocket (ws://localhost:9867/api)\n                              â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                   Daemon (keyrx_daemon)                      â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Axum Web Server                                            â”‚\nâ”‚  â”œâ”€â”€ Static File Handler (embedded UI)                     â”‚\nâ”‚  â”œâ”€â”€ WebSocket RPC Handler                                 â”‚\nâ”‚  â”‚   â”œâ”€â”€ Message Router (method dispatch)                  â”‚\nâ”‚  â”‚   â”œâ”€â”€ Request/Response Correlation (UUID tracking)      â”‚\nâ”‚  â”‚   â””â”€â”€ Subscription Manager (channels)                   â”‚\nâ”‚  â””â”€â”€ Daemon State Bridge                                    â”‚\nâ”‚      â”œâ”€â”€ Profile Manager                                    â”‚\nâ”‚      â”œâ”€â”€ Device Manager                                     â”‚\nâ”‚      â”œâ”€â”€ Config Manager                                     â”‚\nâ”‚      â””â”€â”€ Event Stream                                       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### 1.2 Architectural Principles\n\n**Single Source of Truth (SSOT)**:\n- Configuration: `.krx` binary files (rkyv-serialized)\n- State: Daemon holds authoritative state, UI subscribes to changes\n- No client-side caching of server state (React Query handles staleness)\n\n**Real-Time by Default**:\n- All state changes broadcast via WebSocket events\n- UI subscribes to relevant channels and updates reactively\n- No polling required\n\n**Type Safety End-to-End**:\n- Rust types (keyrx_daemon) â†’ JSON schema â†’ TypeScript types (UI)\n- Code generation for RPC method types\n- Compile-time verification of message structure\n\n**Deterministic Behavior**:\n- WASM validation matches daemon validation byte-for-byte\n- Same configuration always produces same output\n- Enables automated testing and AI verification\n\n## 2. Component Design\n\n### 2.1 Unified WebSocket RPC API\n\n#### 2.1.1 Message Protocol\n\n**Client â†’ Server Messages:**\n\n```typescript\n// Query (read-only, no side effects)\n{\n  type: \"query\",\n  id: \"uuid-v4\",\n  method: \"getProfiles\" | \"getDevices\" | \"getConfig\" | \"getLayers\" | \"getLatency\" | \"getEvents\",\n  params?: any\n}\n\n// Command (write operation, has side effects)\n{\n  type: \"command\",\n  id: \"uuid-v4\",\n  method: \"createProfile\" | \"activateProfile\" | \"deleteProfile\" | \"duplicateProfile\" | \"renameProfile\" |\n          \"renameDevice\" | \"setScopeDevice\" | \"forgetDevice\" |\n          \"updateConfig\" | \"setKeyMapping\" | \"deleteKeyMapping\" |\n          \"clearEvents\" | \"simulate\" | \"resetSimulator\",\n  params: any\n}\n\n// Subscribe (start receiving events)\n{\n  type: \"subscribe\",\n  id: \"uuid-v4\",\n  channel: \"daemon-state\" | \"events\" | \"latency\",\n  params?: any\n}\n\n// Unsubscribe (stop receiving events)\n{\n  type: \"unsubscribe\",\n  id: \"uuid-v4\",\n  channel: string\n}\n```\n\n**Server â†’ Client Messages:**\n\n```typescript\n// Response (reply to query/command)\n{\n  type: \"response\",\n  id: \"uuid-v4\",  // Matches request ID\n  result?: any,\n  error?: {\n    code: number,\n    message: string,\n    data?: any\n  }\n}\n\n// Event (subscription broadcast)\n{\n  type: \"event\",\n  channel: \"daemon-state\" | \"events\" | \"latency\",\n  data: any\n}\n\n// Connected (handshake confirmation)\n{\n  type: \"connected\",\n  version: \"1.0.0\",\n  timestamp: number\n}\n```\n\n#### 2.1.2 RPC Methods\n\n**Profile Operations:**\n- `getProfiles()` â†’ `Profile[]`\n- `createProfile(name: string, basedOn?: string)` â†’ `Profile`\n- `activateProfile(name: string)` â†’ `void`\n- `deleteProfile(name: string)` â†’ `void`\n- `duplicateProfile(name: string, newName: string)` â†’ `Profile`\n- `renameProfile(oldName: string, newName: string)` â†’ `Profile`\n\n**Device Operations:**\n- `getDevices()` â†’ `Device[]`\n- `renameDevice(serialNumber: string, name: string)` â†’ `Device`\n- `setScopeDevice(serialNumber: string)` â†’ `void`\n- `forgetDevice(serialNumber: string)` â†’ `void`\n\n**Config Operations:**\n- `getConfig(profileName: string)` â†’ `{ code: string, hash: string }`\n- `updateConfig(profileName: string, code: string)` â†’ `{ hash: string }`\n- `setKeyMapping(profileName: string, keyCode: number, mapping: KeyMapping)` â†’ `void`\n- `deleteKeyMapping(profileName: string, keyCode: number)` â†’ `void`\n- `getLayers(profileName: string)` â†’ `Layer[]`\n\n**Metrics Operations:**\n- `getLatency()` â†’ `LatencyMetrics`\n- `getEvents(limit?: number, offset?: number)` â†’ `KeyEvent[]`\n- `clearEvents()` â†’ `void`\n\n**Simulator Operations:**\n- `simulate(code: string, input: KeyEvent[])` â†’ `SimulationResult`\n- `resetSimulator()` â†’ `void`\n\n#### 2.1.3 Subscription Channels\n\n**daemon-state:**\n```typescript\n{\n  modifiers: number[],  // Active modifier IDs\n  locks: number[],      // Active lock IDs\n  layer: number,        // Current layer ID\n  timestamp: number     // Microseconds since epoch\n}\n```\n\n**events:**\n```typescript\n{\n  timestamp: number,    // Microseconds\n  keyCode: number,\n  eventType: \"press\" | \"release\" | \"tap\" | \"hold\",\n  latency: number,      // Microseconds\n  layer: number\n}\n```\n\n**latency:**\n```typescript\n{\n  min: number,          // Microseconds\n  avg: number,\n  max: number,\n  p50: number,\n  p95: number,\n  p99: number,\n  count: number,\n  timestamp: number\n}\n```\n\n#### 2.1.4 Rust Implementation\n\n**File Structure:**\n```\nkeyrx_daemon/src/web/\nâ”œâ”€â”€ mod.rs              // Axum server setup\nâ”œâ”€â”€ rpc_types.rs        // Message type definitions\nâ”œâ”€â”€ ws_rpc.rs           // WebSocket RPC handler\nâ”œâ”€â”€ handlers/           // RPC method implementations\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ profile.rs      // Profile RPC methods\nâ”‚   â”œâ”€â”€ device.rs       // Device RPC methods\nâ”‚   â”œâ”€â”€ config.rs       // Config RPC methods\nâ”‚   â””â”€â”€ metrics.rs      // Metrics RPC methods\nâ””â”€â”€ subscriptions.rs    // Subscription channel manager\n```\n\n**Core Types:**\n\n```rust\n// keyrx_daemon/src/web/rpc_types.rs\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"lowercase\")]\npub enum ClientMessage {\n    Query {\n        id: String,\n        method: String,\n        #[serde(default)]\n        params: serde_json::Value,\n    },\n    Command {\n        id: String,\n        method: String,\n        params: serde_json::Value,\n    },\n    Subscribe {\n        id: String,\n        channel: String,\n        #[serde(default)]\n        params: serde_json::Value,\n    },\n    Unsubscribe {\n        id: String,\n        channel: String,\n    },\n}\n\n#[derive(Debug, Serialize)]\n#[serde(tag = \"type\", rename_all = \"lowercase\")]\npub enum ServerMessage {\n    Response {\n        id: String,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        result: Option<serde_json::Value>,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        error: Option<RpcError>,\n    },\n    Event {\n        channel: String,\n        data: serde_json::Value,\n    },\n    Connected {\n        version: String,\n        timestamp: u64,\n    },\n}\n\n#[derive(Debug, Serialize)]\npub struct RpcError {\n    pub code: i32,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option<serde_json::Value>,\n}\n\n// Standard JSON-RPC error codes\npub const PARSE_ERROR: i32 = -32700;\npub const INVALID_REQUEST: i32 = -32600;\npub const METHOD_NOT_FOUND: i32 = -32601;\npub const INVALID_PARAMS: i32 = -32602;\npub const INTERNAL_ERROR: i32 = -32603;\n```\n\n**WebSocket Handler:**\n\n```rust\n// keyrx_daemon/src/web/ws_rpc.rs\nuse axum::{\n    extract::{\n        ws::{Message, WebSocket},\n        State, WebSocketUpgrade,\n    },\n    response::IntoResponse,\n};\nuse tokio::sync::broadcast;\nuse std::sync::Arc;\n\npub async fn ws_handler(\n    ws: WebSocketUpgrade,\n    State(state): State<Arc<AppState>>,\n) -> impl IntoResponse {\n    ws.on_upgrade(|socket| handle_socket(socket, state))\n}\n\nasync fn handle_socket(socket: WebSocket, state: Arc<AppState>) {\n    let (mut sender, mut receiver) = socket.split();\n    let mut subscriptions = Vec::new();\n\n    // Send handshake\n    let handshake = ServerMessage::Connected {\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        timestamp: std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_micros() as u64,\n    };\n    if sender.send(Message::Text(serde_json::to_string(&handshake).unwrap())).await.is_err() {\n        return;\n    }\n\n    // Message loop\n    while let Some(msg) = receiver.next().await {\n        let msg = match msg {\n            Ok(Message::Text(text)) => text,\n            Ok(Message::Close(_)) => break,\n            _ => continue,\n        };\n\n        let client_msg: ClientMessage = match serde_json::from_str(&msg) {\n            Ok(m) => m,\n            Err(e) => {\n                let error = ServerMessage::Response {\n                    id: \"unknown\".to_string(),\n                    result: None,\n                    error: Some(RpcError {\n                        code: PARSE_ERROR,\n                        message: format!(\"Parse error: {}\", e),\n                        data: None,\n                    }),\n                };\n                let _ = sender.send(Message::Text(serde_json::to_string(&error).unwrap())).await;\n                continue;\n            }\n        };\n\n        let response = match client_msg {\n            ClientMessage::Query { id, method, params } => {\n                handle_query(&state, &id, &method, params).await\n            }\n            ClientMessage::Command { id, method, params } => {\n                handle_command(&state, &id, &method, params).await\n            }\n            ClientMessage::Subscribe { id, channel, params } => {\n                handle_subscribe(&state, &mut subscriptions, &id, &channel, params).await\n            }\n            ClientMessage::Unsubscribe { id, channel } => {\n                handle_unsubscribe(&mut subscriptions, &id, &channel).await\n            }\n        };\n\n        if let Some(resp) = response {\n            let _ = sender.send(Message::Text(serde_json::to_string(&resp).unwrap())).await;\n        }\n    }\n}\n\nasync fn handle_query(\n    state: &AppState,\n    id: &str,\n    method: &str,\n    params: serde_json::Value,\n) -> Option<ServerMessage> {\n    let result = match method {\n        \"getProfiles\" => handlers::profile::get_profiles(state).await,\n        \"getDevices\" => handlers::device::get_devices(state).await,\n        \"getConfig\" => handlers::config::get_config(state, params).await,\n        \"getLayers\" => handlers::config::get_layers(state, params).await,\n        \"getLatency\" => handlers::metrics::get_latency(state).await,\n        \"getEvents\" => handlers::metrics::get_events(state, params).await,\n        _ => Err(RpcError {\n            code: METHOD_NOT_FOUND,\n            message: format!(\"Method not found: {}\", method),\n            data: None,\n        }),\n    };\n\n    Some(ServerMessage::Response {\n        id: id.to_string(),\n        result: result.ok(),\n        error: result.err(),\n    })\n}\n\nasync fn handle_command(\n    state: &AppState,\n    id: &str,\n    method: &str,\n    params: serde_json::Value,\n) -> Option<ServerMessage> {\n    let result = match method {\n        \"createProfile\" => handlers::profile::create_profile(state, params).await,\n        \"activateProfile\" => handlers::profile::activate_profile(state, params).await,\n        \"deleteProfile\" => handlers::profile::delete_profile(state, params).await,\n        \"updateConfig\" => handlers::config::update_config(state, params).await,\n        \"setKeyMapping\" => handlers::config::set_key_mapping(state, params).await,\n        // ... other methods\n        _ => Err(RpcError {\n            code: METHOD_NOT_FOUND,\n            message: format!(\"Method not found: {}\", method),\n            data: None,\n        }),\n    };\n\n    Some(ServerMessage::Response {\n        id: id.to_string(),\n        result: result.ok(),\n        error: result.err(),\n    })\n}\n```\n\n#### 2.1.5 TypeScript Implementation\n\n**File Structure:**\n```\nkeyrx_ui_v2/src/\nâ”œâ”€â”€ api/\nâ”‚   â”œâ”€â”€ rpc.ts              // Type-safe RPC client\nâ”‚   â””â”€â”€ types.ts            // RPC method types\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ useUnifiedApi.ts    // WebSocket RPC hook\nâ””â”€â”€ types/\n    â””â”€â”€ rpc.ts              // Message type definitions\n```\n\n**RPC Types:**\n\n```typescript\n// keyrx_ui_v2/src/types/rpc.ts\nexport type RpcMethod =\n  // Queries\n  | \"getProfiles\"\n  | \"getDevices\"\n  | \"getConfig\"\n  | \"getLayers\"\n  | \"getLatency\"\n  | \"getEvents\"\n  // Commands\n  | \"createProfile\"\n  | \"activateProfile\"\n  | \"deleteProfile\"\n  | \"duplicateProfile\"\n  | \"renameProfile\"\n  | \"renameDevice\"\n  | \"setScopeDevice\"\n  | \"forgetDevice\"\n  | \"updateConfig\"\n  | \"setKeyMapping\"\n  | \"deleteKeyMapping\"\n  | \"clearEvents\"\n  | \"simulate\"\n  | \"resetSimulator\";\n\nexport type SubscriptionChannel = \"daemon-state\" | \"events\" | \"latency\";\n\nexport interface ClientMessage {\n  type: \"query\" | \"command\" | \"subscribe\" | \"unsubscribe\";\n  id: string;\n  method?: RpcMethod;\n  channel?: SubscriptionChannel;\n  params?: any;\n}\n\nexport interface ServerMessage {\n  type: \"response\" | \"event\" | \"connected\";\n  id?: string;\n  channel?: string;\n  result?: any;\n  error?: RpcError;\n  data?: any;\n  version?: string;\n  timestamp?: number;\n}\n\nexport interface RpcError {\n  code: number;\n  message: string;\n  data?: any;\n}\n\nexport interface DaemonState {\n  modifiers: number[];\n  locks: number[];\n  layer: number;\n  timestamp: number;\n}\n\nexport interface KeyEvent {\n  timestamp: number;\n  keyCode: number;\n  eventType: \"press\" | \"release\" | \"tap\" | \"hold\";\n  latency: number;\n  layer: number;\n}\n\nexport interface LatencyMetrics {\n  min: number;\n  avg: number;\n  max: number;\n  p50: number;\n  p95: number;\n  p99: number;\n  count: number;\n  timestamp: number;\n}\n```\n\n**useUnifiedApi Hook:**\n\n```typescript\n// keyrx_ui_v2/src/hooks/useUnifiedApi.ts\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport useWebSocket, { ReadyState } from 'react-use-websocket';\nimport { v4 as uuidv4 } from 'uuid';\nimport type {\n  ClientMessage,\n  ServerMessage,\n  RpcMethod,\n  SubscriptionChannel,\n} from '@/types/rpc';\n\ninterface PendingRequest {\n  resolve: (value: any) => void;\n  reject: (error: Error) => void;\n  timeout: NodeJS.Timeout;\n}\n\nexport function useUnifiedApi(url: string = 'ws://localhost:9867/api') {\n  const [isConnected, setIsConnected] = useState(false);\n  const pendingRequests = useRef<Map<string, PendingRequest>>(new Map());\n  const subscriptions = useRef<Map<string, (data: any) => void>>(new Map());\n\n  const { sendJsonMessage, lastJsonMessage, readyState } = useWebSocket<ServerMessage>(\n    url,\n    {\n      shouldReconnect: () => true,\n      reconnectInterval: 3000,\n      reconnectAttempts: 10,\n    }\n  );\n\n  // Handle incoming messages\n  useEffect(() => {\n    if (!lastJsonMessage) return;\n\n    const msg = lastJsonMessage;\n\n    if (msg.type === 'connected') {\n      setIsConnected(true);\n      console.info('[RPC] Connected to daemon', msg);\n      return;\n    }\n\n    if (msg.type === 'response' && msg.id) {\n      const pending = pendingRequests.current.get(msg.id);\n      if (pending) {\n        clearTimeout(pending.timeout);\n        pendingRequests.current.delete(msg.id);\n\n        if (msg.error) {\n          pending.reject(new Error(`${msg.error.message} (code: ${msg.error.code})`));\n        } else {\n          pending.resolve(msg.result);\n        }\n      }\n      return;\n    }\n\n    if (msg.type === 'event' && msg.channel) {\n      const handler = subscriptions.current.get(msg.channel);\n      if (handler) {\n        handler(msg.data);\n      }\n    }\n  }, [lastJsonMessage]);\n\n  // Update connection status\n  useEffect(() => {\n    setIsConnected(readyState === ReadyState.OPEN);\n  }, [readyState]);\n\n  // Query method (read-only)\n  const query = useCallback(\n    <T = any>(method: RpcMethod, params?: any): Promise<T> => {\n      return new Promise((resolve, reject) => {\n        const id = uuidv4();\n        const timeout = setTimeout(() => {\n          pendingRequests.current.delete(id);\n          reject(new Error(`Request timeout: ${method}`));\n        }, 30000);\n\n        pendingRequests.current.set(id, { resolve, reject, timeout });\n\n        const message: ClientMessage = {\n          type: 'query',\n          id,\n          method,\n          params,\n        };\n\n        sendJsonMessage(message);\n      });\n    },\n    [sendJsonMessage]\n  );\n\n  // Command method (write operation)\n  const command = useCallback(\n    <T = any>(method: RpcMethod, params: any): Promise<T> => {\n      return new Promise((resolve, reject) => {\n        const id = uuidv4();\n        const timeout = setTimeout(() => {\n          pendingRequests.current.delete(id);\n          reject(new Error(`Request timeout: ${method}`));\n        }, 30000);\n\n        pendingRequests.current.set(id, { resolve, reject, timeout });\n\n        const message: ClientMessage = {\n          type: 'command',\n          id,\n          method,\n          params,\n        };\n\n        sendJsonMessage(message);\n      });\n    },\n    [sendJsonMessage]\n  );\n\n  // Subscribe to channel\n  const subscribe = useCallback(\n    (channel: SubscriptionChannel, handler: (data: any) => void): void => {\n      subscriptions.current.set(channel, handler);\n\n      const message: ClientMessage = {\n        type: 'subscribe',\n        id: uuidv4(),\n        channel,\n      };\n\n      sendJsonMessage(message);\n    },\n    [sendJsonMessage]\n  );\n\n  // Unsubscribe from channel\n  const unsubscribe = useCallback(\n    (channel: SubscriptionChannel): void => {\n      subscriptions.current.delete(channel);\n\n      const message: ClientMessage = {\n        type: 'unsubscribe',\n        id: uuidv4(),\n        channel,\n      };\n\n      sendJsonMessage(message);\n    },\n    [sendJsonMessage]\n  );\n\n  return {\n    query,\n    command,\n    subscribe,\n    unsubscribe,\n    isConnected,\n    readyState,\n  };\n}\n```\n\n**Type-Safe RPC Client:**\n\n```typescript\n// keyrx_ui_v2/src/api/rpc.ts\nimport type { Profile, Device, Layer, KeyMapping } from './types';\nimport type { DaemonState, KeyEvent, LatencyMetrics } from '@/types/rpc';\n\nexport class RpcClient {\n  constructor(private api: ReturnType<typeof useUnifiedApi>) {}\n\n  // Profile methods\n  async getProfiles(): Promise<Profile[]> {\n    return this.api.query('getProfiles');\n  }\n\n  async createProfile(name: string, basedOn?: string): Promise<Profile> {\n    return this.api.command('createProfile', { name, basedOn });\n  }\n\n  async activateProfile(name: string): Promise<void> {\n    return this.api.command('activateProfile', { name });\n  }\n\n  async deleteProfile(name: string): Promise<void> {\n    return this.api.command('deleteProfile', { name });\n  }\n\n  async duplicateProfile(name: string, newName: string): Promise<Profile> {\n    return this.api.command('duplicateProfile', { name, newName });\n  }\n\n  async renameProfile(oldName: string, newName: string): Promise<Profile> {\n    return this.api.command('renameProfile', { oldName, newName });\n  }\n\n  // Device methods\n  async getDevices(): Promise<Device[]> {\n    return this.api.query('getDevices');\n  }\n\n  async renameDevice(serialNumber: string, name: string): Promise<Device> {\n    return this.api.command('renameDevice', { serialNumber, name });\n  }\n\n  // Config methods\n  async getConfig(profileName: string): Promise<{ code: string; hash: string }> {\n    return this.api.query('getConfig', { profileName });\n  }\n\n  async updateConfig(profileName: string, code: string): Promise<{ hash: string }> {\n    return this.api.command('updateConfig', { profileName, code });\n  }\n\n  async getLayers(profileName: string): Promise<Layer[]> {\n    return this.api.query('getLayers', { profileName });\n  }\n\n  // Metrics methods\n  async getLatency(): Promise<LatencyMetrics> {\n    return this.api.query('getLatency');\n  }\n\n  async getEvents(limit?: number, offset?: number): Promise<KeyEvent[]> {\n    return this.api.query('getEvents', { limit, offset });\n  }\n\n  // Subscriptions\n  onDaemonState(handler: (state: DaemonState) => void): void {\n    this.api.subscribe('daemon-state', handler);\n  }\n\n  onEvents(handler: (event: KeyEvent) => void): void {\n    this.api.subscribe('events', handler);\n  }\n\n  onLatency(handler: (metrics: LatencyMetrics) => void): void {\n    this.api.subscribe('latency', handler);\n  }\n}\n```\n\n### 2.2 Monaco Code Editor Integration\n\n#### 2.2.1 Component Architecture\n\n```typescript\n// keyrx_ui_v2/src/components/MonacoEditor.tsx\nimport React, { useRef, useEffect, useState } from 'react';\nimport Editor, { Monaco } from '@monaco-editor/react';\nimport type * as monacoEditor from 'monaco-editor';\nimport { useWasm } from '@/hooks/useWasm';\n\ninterface MonacoEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n  onValidate?: (errors: ValidationError[]) => void;\n  readOnly?: boolean;\n}\n\nexport const MonacoEditor: React.FC<MonacoEditorProps> = ({\n  value,\n  onChange,\n  onValidate,\n  readOnly = false,\n}) => {\n  const editorRef = useRef<monacoEditor.editor.IStandaloneCodeEditor | null>(null);\n  const monacoRef = useRef<Monaco | null>(null);\n  const { validateConfig, isWasmReady } = useWasm();\n  const [markers, setMarkers] = useState<monacoEditor.editor.IMarkerData[]>([]);\n\n  // Register Rhai language\n  const handleEditorWillMount = (monaco: Monaco) => {\n    monacoRef.current = monaco;\n\n    // Register Rhai language\n    monaco.languages.register({ id: 'rhai' });\n\n    // Define syntax highlighting\n    monaco.languages.setMonarchTokensProvider('rhai', {\n      keywords: [\n        'let', 'const', 'if', 'else', 'while', 'for', 'loop', 'break', 'continue',\n        'return', 'fn', 'private', 'true', 'false', 'import', 'export', 'as',\n      ],\n      operators: [\n        '=', '>', '<', '!', '~', '?', ':',\n        '==', '<=', '>=', '!=', '&&', '||', '++', '--',\n        '+', '-', '*', '/', '&', '|', '^', '%', '<<',\n        '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=',\n        '^=', '%=', '<<=', '>>=', '>>>=',\n      ],\n      tokenizer: {\n        root: [\n          [/[a-z_$][\\w$]*/, {\n            cases: {\n              '@keywords': 'keyword',\n              '@default': 'identifier',\n            },\n          }],\n          [/[A-Z][\\w$]*/, 'type.identifier'],\n          [/\"([^\"\\\\]|\\\\.)*$/, 'string.invalid'],\n          [/\"/, 'string', '@string'],\n          [/\\d+/, 'number'],\n          [/\\/\\/.*$/, 'comment'],\n        ],\n        string: [\n          [/[^\\\\\"]+/, 'string'],\n          [/\"/, 'string', '@pop'],\n        ],\n      },\n    });\n\n    // Configure theme\n    monaco.editor.defineTheme('rhai-dark', {\n      base: 'vs-dark',\n      inherit: true,\n      rules: [\n        { token: 'keyword', foreground: 'C586C0' },\n        { token: 'identifier', foreground: '9CDCFE' },\n        { token: 'type.identifier', foreground: '4EC9B0' },\n        { token: 'string', foreground: 'CE9178' },\n        { token: 'number', foreground: 'B5CEA8' },\n        { token: 'comment', foreground: '6A9955' },\n      ],\n      colors: {\n        'editor.background': '#1E1E1E',\n      },\n    });\n  };\n\n  // Handle editor mount\n  const handleEditorDidMount = (\n    editor: monacoEditor.editor.IStandaloneCodeEditor,\n    monaco: Monaco\n  ) => {\n    editorRef.current = editor;\n\n    // Configure editor options\n    editor.updateOptions({\n      minimap: { enabled: false },\n      fontSize: 14,\n      lineHeight: 21,\n      tabSize: 2,\n      insertSpaces: true,\n      automaticLayout: true,\n      scrollBeyondLastLine: false,\n      renderWhitespace: 'selection',\n      rulers: [80, 120],\n    });\n\n    // F8: Go to next error\n    editor.addCommand(monaco.KeyCode.F8, () => {\n      const model = editor.getModel();\n      if (!model) return;\n\n      const markers = monaco.editor.getModelMarkers({ resource: model.uri });\n      if (markers.length === 0) return;\n\n      const position = editor.getPosition();\n      if (!position) return;\n\n      // Find next marker after current position\n      const nextMarker = markers.find(\n        (m) =>\n          m.startLineNumber > position.lineNumber ||\n          (m.startLineNumber === position.lineNumber &&\n            m.startColumn > position.column)\n      ) || markers[0];\n\n      editor.setPosition({\n        lineNumber: nextMarker.startLineNumber,\n        column: nextMarker.startColumn,\n      });\n      editor.revealLineInCenter(nextMarker.startLineNumber);\n    });\n  };\n\n  // Debounced validation\n  useEffect(() => {\n    if (!isWasmReady) return;\n\n    const timeoutId = setTimeout(async () => {\n      const errors = await validateConfig(value);\n\n      const newMarkers: monacoEditor.editor.IMarkerData[] = errors.map((err) => ({\n        severity: monacoRef.current!.MarkerSeverity.Error,\n        startLineNumber: err.line,\n        startColumn: err.column,\n        endLineNumber: err.line,\n        endColumn: err.column + (err.length || 1),\n        message: err.message,\n      }));\n\n      setMarkers(newMarkers);\n      onValidate?.(errors);\n\n      if (editorRef.current && monacoRef.current) {\n        const model = editorRef.current.getModel();\n        if (model) {\n          monacoRef.current.editor.setModelMarkers(model, 'rhai', newMarkers);\n        }\n      }\n    }, 500);\n\n    return () => clearTimeout(timeoutId);\n  }, [value, isWasmReady, validateConfig, onValidate]);\n\n  return (\n    <Editor\n      height=\"600px\"\n      language=\"rhai\"\n      theme=\"rhai-dark\"\n      value={value}\n      onChange={(val) => onChange(val || '')}\n      beforeMount={handleEditorWillMount}\n      onMount={handleEditorDidMount}\n      options={{\n        readOnly,\n      }}\n    />\n  );\n};\n```\n\n#### 2.2.2 WASM Integration\n\n```typescript\n// keyrx_ui_v2/src/hooks/useWasm.ts\nimport { useState, useEffect, useCallback } from 'react';\nimport init, { validate_config, simulate } from '@/wasm/keyrx_core';\n\nexport interface ValidationError {\n  line: number;\n  column: number;\n  length: number;\n  message: string;\n}\n\nexport function useWasm() {\n  const [isWasmReady, setIsWasmReady] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    init()\n      .then(() => {\n        setIsWasmReady(true);\n        console.info('[WASM] Initialized successfully');\n      })\n      .catch((err) => {\n        setError(err);\n        console.error('[WASM] Initialization failed:', err);\n      });\n  }, []);\n\n  const validateConfig = useCallback(\n    async (code: string): Promise<ValidationError[]> => {\n      if (!isWasmReady) {\n        console.warn('[WASM] Not ready, skipping validation');\n        return [];\n      }\n\n      try {\n        const result = validate_config(code);\n        return JSON.parse(result);\n      } catch (err) {\n        console.error('[WASM] Validation error:', err);\n        return [];\n      }\n    },\n    [isWasmReady]\n  );\n\n  const runSimulation = useCallback(\n    async (code: string, input: any[]): Promise<any> => {\n      if (!isWasmReady) {\n        throw new Error('WASM not ready');\n      }\n\n      try {\n        const result = simulate(code, JSON.stringify(input));\n        return JSON.parse(result);\n      } catch (err) {\n        console.error('[WASM] Simulation error:', err);\n        throw err;\n      }\n    },\n    [isWasmReady]\n  );\n\n  return {\n    isWasmReady,\n    error,\n    validateConfig,\n    runSimulation,\n  };\n}\n```\n\n### 2.3 Real-Time Dashboard\n\n#### 2.3.1 Dashboard Page Architecture\n\n```typescript\n// keyrx_ui_v2/src/pages/DashboardPage.tsx\nimport React, { useState, useEffect } from 'react';\nimport { useUnifiedApi } from '@/hooks/useUnifiedApi';\nimport { RpcClient } from '@/api/rpc';\nimport { StateIndicatorPanel } from '@/components/StateIndicatorPanel';\nimport { MetricsChart } from '@/components/MetricsChart';\nimport { DashboardEventTimeline } from '@/components/DashboardEventTimeline';\nimport type { DaemonState, KeyEvent, LatencyMetrics } from '@/types/rpc';\n\nexport const DashboardPage: React.FC = () => {\n  const api = useUnifiedApi();\n  const rpc = new RpcClient(api);\n\n  const [daemonState, setDaemonState] = useState<DaemonState | null>(null);\n  const [events, setEvents] = useState<KeyEvent[]>([]);\n  const [latencyHistory, setLatencyHistory] = useState<LatencyMetrics[]>([]);\n  const [isPaused, setIsPaused] = useState(false);\n\n  // Subscribe to real-time updates\n  useEffect(() => {\n    if (!api.isConnected) return;\n\n    rpc.onDaemonState((state) => {\n      setDaemonState(state);\n    });\n\n    rpc.onEvents((event) => {\n      if (!isPaused) {\n        setEvents((prev) => {\n          const updated = [event, ...prev];\n          return updated.slice(0, 100); // Keep max 100 events (FIFO)\n        });\n      }\n    });\n\n    rpc.onLatency((metrics) => {\n      setLatencyHistory((prev) => {\n        const updated = [...prev, metrics];\n        // Keep 60 seconds of data (assuming 1s interval)\n        return updated.slice(-60);\n      });\n    });\n\n    return () => {\n      api.unsubscribe('daemon-state');\n      api.unsubscribe('events');\n      api.unsubscribe('latency');\n    };\n  }, [api.isConnected, isPaused]);\n\n  return (\n    <div className=\"flex flex-col gap-4 p-4 md:p-6\">\n      {/* Connection Banner */}\n      <div\n        className={`px-4 py-3 rounded-md font-medium ${\n          api.isConnected\n            ? 'bg-green-900/20 text-green-400 border border-green-700'\n            : 'bg-red-900/20 text-red-400 border border-red-700'\n        }`}\n      >\n        {api.isConnected ? 'ğŸŸ¢ Connected to daemon' : 'ğŸ”´ Disconnected (reconnecting...)'}\n      </div>\n\n      {/* State Indicators */}\n      <StateIndicatorPanel state={daemonState} />\n\n      {/* Metrics Chart */}\n      <MetricsChart data={latencyHistory} />\n\n      {/* Event Timeline */}\n      <DashboardEventTimeline\n        events={events}\n        isPaused={isPaused}\n        onTogglePause={() => setIsPaused(!isPaused)}\n        onClear={() => setEvents([])}\n      />\n    </div>\n  );\n};\n```\n\n#### 2.3.2 State Indicator Component\n\n```typescript\n// keyrx_ui_v2/src/components/StateIndicatorPanel.tsx\nimport React from 'react';\nimport type { DaemonState } from '@/types/rpc';\n\ninterface StateIndicatorPanelProps {\n  state: DaemonState | null;\n}\n\nexport const StateIndicatorPanel: React.FC<StateIndicatorPanelProps> = ({ state }) => {\n  if (!state) {\n    return (\n      <div className=\"bg-slate-800 rounded-lg p-4\">\n        <p className=\"text-slate-400\">Waiting for daemon state...</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bg-slate-800 rounded-lg p-4\">\n      <h2 className=\"text-lg font-medium text-slate-100 mb-4\">Daemon State</h2>\n\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n        {/* Modifiers */}\n        <div>\n          <h3 className=\"text-sm font-medium text-slate-300 mb-2\">Modifiers</h3>\n          <div className=\"flex flex-wrap gap-2\">\n            {state.modifiers.length === 0 ? (\n              <span className=\"text-slate-500 text-sm\">None</span>\n            ) : (\n              state.modifiers.map((id) => (\n                <span\n                  key={id}\n                  className=\"px-2 py-1 bg-blue-600 text-white text-xs rounded\"\n                >\n                  MOD_{id}\n                </span>\n              ))\n            )}\n          </div>\n        </div>\n\n        {/* Locks */}\n        <div>\n          <h3 className=\"text-sm font-medium text-slate-300 mb-2\">Locks</h3>\n          <div className=\"flex flex-wrap gap-2\">\n            {state.locks.length === 0 ? (\n              <span className=\"text-slate-500 text-sm\">None</span>\n            ) : (\n              state.locks.map((id) => (\n                <span\n                  key={id}\n                  className=\"px-2 py-1 bg-orange-600 text-white text-xs rounded\"\n                >\n                  LOCK_{id}\n                </span>\n              ))\n            )}\n          </div>\n        </div>\n\n        {/* Layer */}\n        <div>\n          <h3 className=\"text-sm font-medium text-slate-300 mb-2\">Active Layer</h3>\n          <span className=\"px-3 py-2 bg-green-600 text-white text-sm rounded font-medium\">\n            Layer {state.layer}\n          </span>\n        </div>\n      </div>\n    </div>\n  );\n};\n```\n\n#### 2.3.3 Metrics Chart Component\n\n```typescript\n// keyrx_ui_v2/src/components/MetricsChart.tsx\nimport React from 'react';\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n  ReferenceLine,\n} from 'recharts';\nimport type { LatencyMetrics } from '@/types/rpc';\n\ninterface MetricsChartProps {\n  data: LatencyMetrics[];\n}\n\nexport const MetricsChart: React.FC<MetricsChartProps> = ({ data }) => {\n  const chartData = data.map((m, idx) => ({\n    index: idx,\n    avg: m.avg / 1000, // Convert to milliseconds\n    p95: m.p95 / 1000,\n    p99: m.p99 / 1000,\n  }));\n\n  return (\n    <div className=\"bg-slate-800 rounded-lg p-4\">\n      <h2 className=\"text-lg font-medium text-slate-100 mb-4\">Latency Metrics</h2>\n\n      <ResponsiveContainer width=\"100%\" height={300}>\n        <LineChart data={chartData}>\n          <CartesianGrid strokeDasharray=\"3 3\" stroke=\"#374151\" />\n          <XAxis dataKey=\"index\" stroke=\"#9CA3AF\" />\n          <YAxis stroke=\"#9CA3AF\" label={{ value: 'ms', angle: -90, position: 'insideLeft' }} />\n          <Tooltip\n            contentStyle={{ backgroundColor: '#1F2937', border: 'none', borderRadius: '8px' }}\n            labelStyle={{ color: '#F3F4F6' }}\n          />\n          <Legend />\n          <ReferenceLine y={5} stroke=\"#EF4444\" strokeDasharray=\"3 3\" label=\"Target (5ms)\" />\n          <Line type=\"monotone\" dataKey=\"avg\" stroke=\"#3B82F6\" name=\"Average\" />\n          <Line type=\"monotone\" dataKey=\"p95\" stroke=\"#F59E0B\" name=\"P95\" />\n          <Line type=\"monotone\" dataKey=\"p99\" stroke=\"#EF4444\" name=\"P99\" />\n        </LineChart>\n      </ResponsiveContainer>\n    </div>\n  );\n};\n```\n\n### 2.4 Tab-Based Configuration Editor\n\n```typescript\n// keyrx_ui_v2/src/pages/ConfigPage.tsx (updated)\nimport React, { useState, useCallback } from 'react';\nimport { Card } from '@/components/Card';\nimport { KeyboardVisualizer } from '@/components/KeyboardVisualizer';\nimport { MonacoEditor } from '@/components/MonacoEditor';\nimport { RpcClient } from '@/api/rpc';\nimport { useUnifiedApi } from '@/hooks/useUnifiedApi';\n\ntype EditorTab = 'visual' | 'code';\n\nexport const ConfigPage: React.FC<{ profileName: string }> = ({ profileName }) => {\n  const api = useUnifiedApi();\n  const rpc = new RpcClient(api);\n\n  const [activeTab, setActiveTab] = useState<EditorTab>('visual');\n  const [configCode, setConfigCode] = useState('');\n  const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);\n  const [isSaving, setIsSaving] = useState(false);\n\n  // Load config on mount\n  useEffect(() => {\n    if (api.isConnected) {\n      rpc.getConfig(profileName).then((config) => {\n        setConfigCode(config.code);\n      });\n    }\n  }, [profileName, api.isConnected]);\n\n  // Save configuration\n  const handleSave = useCallback(async () => {\n    if (validationErrors.length > 0) {\n      alert('Cannot save: Configuration has validation errors');\n      return;\n    }\n\n    setIsSaving(true);\n    try {\n      await rpc.updateConfig(profileName, configCode);\n      console.info('Configuration saved successfully');\n    } catch (err) {\n      console.error('Failed to save configuration:', err);\n      alert(`Failed to save: ${err.message}`);\n    } finally {\n      setIsSaving(false);\n    }\n  }, [profileName, configCode, validationErrors]);\n\n  // Keyboard shortcut: Ctrl+S / Cmd+S\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if ((e.ctrlKey || e.metaKey) && e.key === 's') {\n        e.preventDefault();\n        handleSave();\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handleSave]);\n\n  return (\n    <div className=\"flex flex-col gap-4 p-4 md:p-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <h1 className=\"text-2xl font-semibold text-slate-100\">\n          Configuration Editor - {profileName}\n        </h1>\n        <button\n          onClick={handleSave}\n          disabled={isSaving || validationErrors.length > 0}\n          className=\"px-4 py-2 bg-primary-500 text-white rounded-md hover:bg-primary-600 disabled:opacity-50 disabled:cursor-not-allowed\"\n        >\n          {isSaving ? 'Saving...' : 'Save (Ctrl+S)'}\n        </button>\n      </div>\n\n      {/* Validation Status */}\n      {validationErrors.length > 0 && (\n        <div className=\"px-4 py-3 bg-red-900/20 text-red-400 border border-red-700 rounded-md\">\n          âš ï¸ {validationErrors.length} validation error{validationErrors.length > 1 ? 's' : ''} found\n        </div>\n      )}\n\n      {/* Tab Selector */}\n      <div className=\"flex gap-2 border-b border-slate-700\">\n        <button\n          onClick={() => setActiveTab('visual')}\n          className={`px-4 py-2 font-medium transition-colors ${\n            activeTab === 'visual'\n              ? 'bg-primary-500 text-white border-b-2 border-primary-500'\n              : 'text-slate-400 hover:text-slate-300'\n          }`}\n        >\n          Visual Editor\n        </button>\n        <button\n          onClick={() => setActiveTab('code')}\n          className={`px-4 py-2 font-medium transition-colors ${\n            activeTab === 'code'\n              ? 'bg-primary-500 text-white border-b-2 border-primary-500'\n              : 'text-slate-400 hover:text-slate-300'\n          }`}\n        >\n          Code Editor\n        </button>\n      </div>\n\n      {/* Editor Content */}\n      <Card variant=\"default\" padding=\"lg\">\n        {activeTab === 'visual' ? (\n          <KeyboardVisualizer\n            layout=\"ANSI_104\"\n            keyMappings={new Map()}\n            onKeyClick={(keyCode) => console.log('Key clicked:', keyCode)}\n          />\n        ) : (\n          <MonacoEditor\n            value={configCode}\n            onChange={setConfigCode}\n            onValidate={setValidationErrors}\n          />\n        )}\n      </Card>\n    </div>\n  );\n};\n```\n\n### 2.5 Build Process Integration\n\n#### 2.5.1 WASM Build Configuration\n\n```toml\n# keyrx_core/Cargo.toml\n[package]\nname = \"keyrx_core\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"rlib\"]\n\n[dependencies]\nrkyv = { version = \"0.7\", default-features = false }\nserde = { version = \"1.0\", default-features = false, features = [\"derive\"] }\nwasm-bindgen = { version = \"0.2\", optional = true }\nserde-wasm-bindgen = { version = \"0.6\", optional = true }\n\n[features]\ndefault = [\"std\"]\nstd = []\nwasm = [\"wasm-bindgen\", \"serde-wasm-bindgen\"]\n\n[profile.release]\nopt-level = \"z\"     # Optimize for size\nlto = true          # Enable Link Time Optimization\ncodegen-units = 1   # Single codegen unit for better optimization\nstrip = true        # Strip debug symbols\n```\n\n```javascript\n// keyrx_ui_v2/vite.config.ts\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport wasm from 'vite-plugin-wasm';\nimport topLevelAwait from 'vite-plugin-top-level-await';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    wasm(),\n    topLevelAwait(),\n  ],\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n  build: {\n    target: 'esnext',\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          'vendor': ['react', 'react-dom', 'react-router-dom'],\n          'monaco': ['@monaco-editor/react', 'monaco-editor'],\n          'charts': ['recharts'],\n        },\n      },\n    },\n  },\n  optimizeDeps: {\n    exclude: ['@/wasm/keyrx_core'],\n  },\n});\n```\n\n#### 2.5.2 Build Script\n\n```bash\n#!/usr/bin/env bash\n# scripts/build_ui.sh\n\nset -e\n\necho \"[1/4] Building WASM module...\"\ncd keyrx_core\nwasm-pack build --target web --out-dir ../keyrx_ui_v2/src/wasm/pkg --release\ncd ..\n\necho \"[2/4] Installing UI dependencies...\"\ncd keyrx_ui_v2\nnpm install\n\necho \"[3/4] Building UI...\"\nnpm run build\n\necho \"[4/4] Verifying build...\"\nif [ ! -f \"dist/index.html\" ]; then\n  echo \"ERROR: UI build failed - dist/index.html not found\"\n  exit 1\nfi\n\necho \"âœ“ UI build complete: keyrx_ui_v2/dist/\"\n```\n\n#### 2.5.3 Daemon Embedding\n\n```rust\n// keyrx_daemon/build.rs\nuse std::path::Path;\n\nfn main() {\n    // Verify UI dist directory exists\n    let ui_dist = Path::new(\"../keyrx_ui_v2/dist\");\n    if !ui_dist.exists() {\n        panic!(\n            \"UI directory not found: {}\\nRun 'scripts/build_ui.sh' first\",\n            ui_dist.display()\n        );\n    }\n\n    // Trigger rebuild if UI files change\n    println!(\"cargo:rerun-if-changed=../keyrx_ui_v2/dist\");\n}\n```\n\n```rust\n// keyrx_daemon/src/web/static_files.rs\nuse axum::{\n    http::{header, StatusCode, Uri},\n    response::{Html, IntoResponse, Response},\n};\nuse include_dir::{include_dir, Dir};\n\nstatic UI_DIR: Dir = include_dir!(\"$CARGO_MANIFEST_DIR/../keyrx_ui_v2/dist\");\n\npub async fn serve_static(uri: Uri) -> impl IntoResponse {\n    let path = uri.path().trim_start_matches('/');\n\n    // Default to index.html for SPA routing\n    let path = if path.is_empty() || !path.contains('.') {\n        \"index.html\"\n    } else {\n        path\n    };\n\n    match UI_DIR.get_file(path) {\n        Some(file) => {\n            let mime = mime_guess::from_path(path).first_or_octet_stream();\n            let body = file.contents();\n\n            Response::builder()\n                .status(StatusCode::OK)\n                .header(header::CONTENT_TYPE, mime.as_ref())\n                .body(body.into())\n                .unwrap()\n        }\n        None if path != \"index.html\" => {\n            // Fallback to index.html for client-side routing\n            serve_static(\"/\".parse().unwrap()).await.into_response()\n        }\n        None => (StatusCode::NOT_FOUND, \"Not Found\").into_response(),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ui_embedded() {\n        assert!(UI_DIR.get_file(\"index.html\").is_some(), \"index.html not found in embedded UI\");\n    }\n}\n```\n\n## 3. Data Flow\n\n### 3.1 Configuration Edit Flow\n\n```\nUser Types in Monaco Editor\n         â”‚\n         â”œâ”€ (500ms debounce)\n         â”‚\n         â–¼\nWASM validate_config(code)\n         â”‚\n         â”œâ”€ Success â†’ Clear markers\n         â””â”€ Errors â†’ Set error markers\n         â”‚\n         â–¼\nUser Presses Ctrl+S\n         â”‚\n         â”œâ”€ IF errors > 0 â†’ Block save\n         â””â”€ IF errors = 0 â†’ Send RPC command\n         â”‚\n         â–¼\ncommand(\"updateConfig\", { profileName, code })\n         â”‚\n         â–¼\nDaemon validates & saves .krx file\n         â”‚\n         â”œâ”€ Success â†’ Return { hash }\n         â””â”€ Error â†’ Return RpcError\n         â”‚\n         â–¼\nUI displays success/error message\n```\n\n### 3.2 Real-Time Event Flow\n\n```\nHardware Key Press\n         â”‚\n         â–¼\nPlatform Layer (evdev/Raw Input)\n         â”‚\n         â–¼\nDaemon Processes Event (keyrx_core)\n         â”‚\n         â”œâ”€ Update internal state\n         â”œâ”€ Record latency metric\n         â””â”€ Broadcast events\n         â”‚\n         â”œâ”€ Channel: \"daemon-state\" â†’ { modifiers, locks, layer }\n         â”œâ”€ Channel: \"events\" â†’ { keyCode, eventType, latency }\n         â””â”€ Channel: \"latency\" â†’ { min, avg, max, p95, p99 }\n         â”‚\n         â–¼\nAll Subscribed WebSocket Clients Receive Events\n         â”‚\n         â–¼\nUI React State Updates\n         â”‚\n         â”œâ”€ StateIndicatorPanel re-renders\n         â”œâ”€ MetricsChart appends data point\n         â””â”€ DashboardEventTimeline prepends event\n```\n\n### 3.3 Profile Activation Flow\n\n```\nUser Clicks \"Activate\" on ProfilesPage\n         â”‚\n         â–¼\ncommand(\"activateProfile\", { name })\n         â”‚\n         â–¼\nDaemon Loads .krx Binary\n         â”‚\n         â”œâ”€ Read file from ~/.config/keyrx/profiles/{name}.krx\n         â”œâ”€ Deserialize with rkyv (zero-copy)\n         â””â”€ Swap active configuration atomically\n         â”‚\n         â–¼\nDaemon Broadcasts \"daemon-state\" Event\n         â”‚\n         â–¼\nAll Subscribed Clients Update UI\n         â”‚\n         â”œâ”€ ProfilesPage shows new active profile\n         â””â”€ DashboardPage updates state indicators\n```\n\n## 4. Security Design\n\n### 4.1 WebSocket Security\n\n**Origin Validation:**\n```rust\n// keyrx_daemon/src/web/mod.rs\nuse axum::extract::ws::WebSocketUpgrade;\n\npub async fn ws_handler(\n    ws: WebSocketUpgrade,\n    headers: HeaderMap,\n) -> Result<impl IntoResponse, StatusCode> {\n    // Only allow localhost connections\n    let origin = headers.get(\"origin\")\n        .and_then(|v| v.to_str().ok())\n        .unwrap_or(\"\");\n\n    if !origin.starts_with(\"http://localhost\") && !origin.starts_with(\"http://127.0.0.1\") {\n        return Err(StatusCode::FORBIDDEN);\n    }\n\n    Ok(ws.on_upgrade(|socket| handle_socket(socket)))\n}\n```\n\n**Content Security Policy:**\n```html\n<!-- keyrx_ui_v2/index.html -->\n<meta http-equiv=\"Content-Security-Policy\" content=\"\n  default-src 'self';\n  script-src 'self' 'wasm-unsafe-eval';\n  style-src 'self' 'unsafe-inline';\n  connect-src 'self' ws://localhost:9867;\n  img-src 'self' data:;\n\">\n```\n\n### 4.2 Input Validation\n\n```rust\n// keyrx_daemon/src/web/handlers/config.rs\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct UpdateConfigParams {\n    #[serde(rename = \"profileName\")]\n    profile_name: String,\n    code: String,\n}\n\npub async fn update_config(\n    state: &AppState,\n    params: serde_json::Value,\n) -> Result<serde_json::Value, RpcError> {\n    let params: UpdateConfigParams = serde_json::from_value(params).map_err(|e| RpcError {\n        code: INVALID_PARAMS,\n        message: format!(\"Invalid parameters: {}\", e),\n        data: None,\n    })?;\n\n    // Validate profile name (no path traversal)\n    if params.profile_name.contains(\"..\") || params.profile_name.contains('/') {\n        return Err(RpcError {\n            code: INVALID_PARAMS,\n            message: \"Invalid profile name\".to_string(),\n            data: None,\n        });\n    }\n\n    // Validate code length (max 1MB)\n    if params.code.len() > 1_000_000 {\n        return Err(RpcError {\n            code: INVALID_PARAMS,\n            message: \"Configuration too large (max 1MB)\".to_string(),\n            data: None,\n        });\n    }\n\n    // Validate with keyrx_core compiler\n    let config = keyrx_compiler::parse(&params.code).map_err(|e| RpcError {\n        code: INVALID_PARAMS,\n        message: format!(\"Configuration validation failed: {}\", e),\n        data: None,\n    })?;\n\n    // Save configuration\n    state.profile_manager.save_config(&params.profile_name, &config).await?;\n\n    Ok(serde_json::json!({ \"hash\": config.hash() }))\n}\n```\n\n## 5. Performance Optimizations\n\n### 5.1 Code Splitting\n\n```javascript\n// keyrx_ui_v2/src/App.tsx\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst ProfilesPage = lazy(() => import('./pages/ProfilesPage'));\nconst ConfigPage = lazy(() => import('./pages/ConfigPage'));\nconst DashboardPage = lazy(() => import('./pages/DashboardPage'));\nconst DevicesPage = lazy(() => import('./pages/DevicesPage'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<LoadingSkeleton />}>\n        <Routes>\n          <Route path=\"/\" element={<ProfilesPage />} />\n          <Route path=\"/config/:profile\" element={<ConfigPage />} />\n          <Route path=\"/dashboard\" element={<DashboardPage />} />\n          <Route path=\"/devices\" element={<DevicesPage />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n```\n\n### 5.2 Virtual Scrolling\n\n```typescript\n// keyrx_ui_v2/src/components/DashboardEventTimeline.tsx\nimport { FixedSizeList as List } from 'react-window';\n\nexport const DashboardEventTimeline: React.FC<{ events: KeyEvent[] }> = ({ events }) => {\n  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {\n    const event = events[index];\n    return (\n      <div style={style} className=\"border-b border-slate-700 px-4 py-2\">\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-sm text-slate-300\">{formatKeyCode(event.keyCode)}</span>\n          <span className=\"text-xs text-slate-400\">{formatTimestamp(event.timestamp)}</span>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <List\n      height={400}\n      itemCount={events.length}\n      itemSize={50}\n      width=\"100%\"\n    >\n      {Row}\n    </List>\n  );\n};\n```\n\n### 5.3 Debounced Validation\n\n```typescript\n// Already implemented in MonacoEditor component (see 2.2.1)\n// 500ms debounce prevents excessive WASM calls while typing\n```\n\n## 6. Testing Strategy\n\n### 6.1 Unit Tests\n\n**Frontend (Vitest):**\n```typescript\n// keyrx_ui_v2/src/hooks/useUnifiedApi.test.ts\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { useUnifiedApi } from './useUnifiedApi';\n\ndescribe('useUnifiedApi', () => {\n  it('should connect to WebSocket', async () => {\n    const { result } = renderHook(() => useUnifiedApi('ws://localhost:9867/api'));\n\n    await waitFor(() => {\n      expect(result.current.isConnected).toBe(true);\n    });\n  });\n\n  it('should send query and receive response', async () => {\n    const { result } = renderHook(() => useUnifiedApi('ws://localhost:9867/api'));\n\n    await waitFor(() => expect(result.current.isConnected).toBe(true));\n\n    const profiles = await result.current.query('getProfiles');\n    expect(Array.isArray(profiles)).toBe(true);\n  });\n});\n```\n\n**Backend (Rust):**\n```rust\n// keyrx_daemon/src/web/ws_rpc_test.rs\n#[tokio::test]\nasync fn test_rpc_query_get_profiles() {\n    let state = Arc::new(AppState::default());\n    let params = serde_json::json!({});\n\n    let response = handle_query(&state, \"test-id\", \"getProfiles\", params).await;\n\n    assert!(response.is_some());\n    let msg = response.unwrap();\n    assert!(matches!(msg, ServerMessage::Response { .. }));\n}\n```\n\n### 6.2 Integration Tests\n\n```typescript\n// keyrx_ui_v2/tests/integration/config-editor.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { ConfigPage } from '@/pages/ConfigPage';\n\ndescribe('ConfigPage Integration', () => {\n  it('should switch between visual and code editor tabs', async () => {\n    render(<ConfigPage profileName=\"Default\" />);\n\n    // Initially visual tab is active\n    expect(screen.getByText('Visual Editor')).toHaveClass('bg-primary-500');\n\n    // Click code editor tab\n    await userEvent.click(screen.getByText('Code Editor'));\n\n    // Monaco editor should render\n    await waitFor(() => {\n      expect(screen.getByRole('textbox')).toBeInTheDocument();\n    });\n  });\n\n  it('should prevent save when validation errors exist', async () => {\n    render(<ConfigPage profileName=\"Default\" />);\n\n    // Switch to code editor\n    await userEvent.click(screen.getByText('Code Editor'));\n\n    // Type invalid code\n    const editor = screen.getByRole('textbox');\n    await userEvent.type(editor, 'invalid syntax here');\n\n    // Wait for validation\n    await waitFor(() => {\n      expect(screen.getByText(/validation error/i)).toBeInTheDocument();\n    });\n\n    // Save button should be disabled\n    expect(screen.getByText(/save/i)).toBeDisabled();\n  });\n});\n```\n\n### 6.3 E2E Tests (Playwright)\n\n```typescript\n// keyrx_ui_v2/e2e/dashboard.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest('dashboard displays real-time updates', async ({ page }) => {\n  await page.goto('http://localhost:9867/dashboard');\n\n  // Wait for connection\n  await expect(page.locator('text=Connected to daemon')).toBeVisible();\n\n  // State indicators should be present\n  await expect(page.locator('text=Daemon State')).toBeVisible();\n\n  // Metrics chart should render\n  await expect(page.locator('text=Latency Metrics')).toBeVisible();\n\n  // Event timeline should be empty initially\n  const timeline = page.locator('[data-testid=\"event-timeline\"]');\n  await expect(timeline).toBeVisible();\n});\n```\n\n### 6.4 Accessibility Tests\n\n```typescript\n// keyrx_ui_v2/tests/a11y/config-page.test.tsx\nimport { render } from '@testing-library/react';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport { ConfigPage } from '@/pages/ConfigPage';\n\nexpect.extend(toHaveNoViolations);\n\ntest('ConfigPage has no accessibility violations', async () => {\n  const { container } = render(<ConfigPage profileName=\"Default\" />);\n  const results = await axe(container);\n  expect(results).toHaveNoViolations();\n});\n```\n\n### 6.5 Visual Regression Tests\n\n```typescript\n// keyrx_ui_v2/e2e/visual/dashboard.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest('dashboard matches screenshot', async ({ page }) => {\n  await page.goto('http://localhost:9867/dashboard');\n  await page.waitForSelector('text=Connected to daemon');\n\n  await expect(page).toHaveScreenshot('dashboard-connected.png', {\n    fullPage: true,\n    animations: 'disabled',\n  });\n});\n```\n\n## 7. Deployment and Build Pipeline\n\n### 7.1 CI/CD Workflow\n\n```yaml\n# .github/workflows/ui-tests.yml\nname: UI Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n\n      - name: Setup Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          target: wasm32-unknown-unknown\n\n      - name: Install wasm-pack\n        run: cargo install wasm-pack\n\n      - name: Build WASM\n        run: |\n          cd keyrx_core\n          wasm-pack build --target web --out-dir ../keyrx_ui_v2/src/wasm/pkg --release\n\n      - name: Install dependencies\n        run: |\n          cd keyrx_ui_v2\n          npm ci\n\n      - name: Run tests\n        run: |\n          cd keyrx_ui_v2\n          npm test -- --coverage\n\n      - name: Run E2E tests\n        run: |\n          cd keyrx_ui_v2\n          npx playwright install\n          npm run test:e2e\n\n      - name: Build UI\n        run: |\n          cd keyrx_ui_v2\n          npm run build\n\n      - name: Verify bundle size\n        run: |\n          cd keyrx_ui_v2/dist\n          SIZE=$(du -sb . | cut -f1)\n          MAX_SIZE=512000  # 500KB\n          if [ $SIZE -gt $MAX_SIZE ]; then\n            echo \"Bundle size $SIZE exceeds limit $MAX_SIZE\"\n            exit 1\n          fi\n```\n\n## 8. Migration Strategy\n\n### 8.1 Phased Rollout\n\n**Phase 0: Backend RPC Implementation (Week 1)**\n- Implement Rust RPC types and handlers\n- Add WebSocket endpoint with RPC router\n- Test with curl/wscat\n- No UI changes yet\n\n**Phase 1: Frontend RPC Client (Week 2)**\n- Implement TypeScript RPC types\n- Create useUnifiedApi hook\n- Test with mock WebSocket server\n- Parallel to backend work\n\n**Phase 2: Migrate Existing Pages (Week 3-4)**\n- Convert ProfilesPage to use RPC\n- Convert DevicesPage to use RPC\n- Remove old REST API calls\n- Keep existing UI components\n\n**Phase 3: Monaco + Dashboard (Week 5)**\n- Integrate Monaco editor with tabs\n- Build real-time dashboard\n- WASM validation integration\n\n**Phase 4: Polish + Testing (Week 6)**\n- Accessibility audit\n- Performance optimization\n- Visual regression tests\n- Documentation\n\n### 8.2 Rollback Plan\n\n**If RPC API fails:**\n- Keep old REST endpoints alongside RPC\n- Use feature flag to switch between APIs\n- Monitor error rates in production\n- Gradual rollout to subset of users first\n\n**Compatibility layer:**\n```typescript\n// Adapter that supports both REST and RPC\nexport function createApiClient(useRpc: boolean) {\n  if (useRpc) {\n    return new RpcClient(useUnifiedApi());\n  } else {\n    return new RestClient();  // Old implementation\n  }\n}\n```\n\n## 9. Success Metrics\n\n### 9.1 Technical Metrics\n\n- âœ… All tests pass (unit, integration, E2E, visual, accessibility)\n- âœ… Code coverage â‰¥ 80% overall\n- âœ… Bundle size < 500KB initial load (gzipped)\n- âœ… Monaco editor chunk < 2MB\n- âœ… WASM module < 1MB\n- âœ… Lighthouse score â‰¥ 90\n\n### 9.2 Performance Metrics\n\n- âœ… WebSocket connection < 500ms\n- âœ… Dashboard update latency < 100ms\n- âœ… WASM validation < 200ms for typical config\n- âœ… Monaco initialization < 1 second\n- âœ… Page load (FCP) < 2 seconds\n\n### 9.3 User Experience Metrics\n\n- âœ… Configuration change time < 5 seconds (edit â†’ save â†’ deploy)\n- âœ… WASM simulation matches daemon behavior byte-for-byte\n- âœ… Validation errors caught before deployment\n- âœ… All features accessible via keyboard navigation\n- âœ… Mobile-responsive on 3 breakpoints (375px, 768px, 1024px)\n",
  "fileStats": {
    "size": 58691,
    "lines": 2101,
    "lastModified": "2025-12-31T23:28:49.355Z"
  },
  "comments": []
}