{
  "id": "snapshot_1767426058344_1y3cbow0k",
  "approvalId": "approval_1767425555825_ckxbe34td",
  "approvalTitle": "Design Document - Web UI Bugfix and Enhancement",
  "version": 2,
  "timestamp": "2026-01-03T07:40:58.344Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Web UI Bugfix and Enhancement\n\n## Overview\n\nThis design addresses 8 critical bugs and missing features in the existing `keyrx_ui/` web interface by **modifying existing components** and **adding new drag-and-drop configuration functionality**. The design emphasizes code reuse, modular architecture, and minimal changes to achieve maximum impact.\n\n**Key Principles**:\n1. **Fix bugs in existing files** (not create duplicates)\n2. **Reuse existing hooks and components** (useAutoSave, KeyboardVisualizer, DeviceScopeToggle)\n3. **Add new drag-and-drop layer** on top of existing config system\n4. **Maintain backward compatibility** with existing API endpoints\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**React + WASM Architecture**:\n- Continue using React 18+ with TypeScript 5+ for type safety\n- Leverage existing WASM integration (`useWasm` hook) for simulator\n- Use existing axum web server endpoints (no backend changes needed for most fixes)\n\n**Existing Dependencies to Leverage**:\n- `@tanstack/react-query`: Already installed, use for server state management\n- `zustand`: Already installed for UI state (avoid for server state)\n- `react-router-dom`: Already installed for navigation\n\n**New Dependencies Required**:\n- `@dnd-kit/core` + `@dnd-kit/utilities`: For keyboard-accessible drag-and-drop (14KB gzipped, aligns with bundle budget)\n- `@headlessui/react`: Already used (DeviceScopeToggle uses it), no new dependency\n\n### Project Structure (structure.md)\n\n**File Organization**:\n```\nkeyrx_ui/src/\nâ”œâ”€â”€ pages/              # Modify existing: HomePage, DevicesPage, ProfilesPage, ConfigPage, MetricsPage, SimulatorPage\nâ”œâ”€â”€ components/         # Modify existing: DeviceListCard, ActiveProfileCard\nâ”‚   â””â”€â”€ config/         # NEW: ConfigPage-specific components\nâ”‚       â”œâ”€â”€ KeyMappingDialog.tsx\nâ”‚       â”œâ”€â”€ DragKeyPalette.tsx\nâ”‚       â””â”€â”€ ProfileHeader.tsx\nâ”œâ”€â”€ hooks/              # Reuse existing: useAutoSave, useProfiles, useDevices, useWasm\nâ”‚   â””â”€â”€ useDragAndDrop.ts  # NEW: Drag-and-drop state management\nâ”œâ”€â”€ api/                # Reuse existing: devices.ts, profiles.ts, config.ts\nâ”œâ”€â”€ types/              # Extend existing types\nâ”‚   â””â”€â”€ config.ts       # NEW: KeyMapping, Layer, AssignableKey types\nâ””â”€â”€ utils/              # Reuse existing: cn, errorUtils, keyCodeMapping\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n1. **useAutoSave** (`src/hooks/useAutoSave.ts`)\n   - **Already implemented** with debouncing (500ms), retry logic (3 attempts), error handling\n   - **Reuse in**: DevicesPage (layout auto-save), ConfigPage (key mapping auto-save)\n   - **Status**: No changes needed, already works correctly\n\n2. **KeyboardVisualizer** (`src/components/KeyboardVisualizer.tsx`)\n   - **Already renders** visual keyboard layout with configurable layouts (ANSI, ISO, JIS, HHKB, Numpad)\n   - **Modify for**: Drag-and-drop targets, display key mappings, layer visualization\n   - **Changes**: Add `onKeyDrop` callback, highlight drop zones, show mapping labels\n\n3. **DeviceScopeToggle** (`src/components/DeviceScopeToggle.tsx`)\n   - **Already implemented** with global/device-specific toggle and device selector dropdown\n   - **Reuse in**: ConfigPage without modifications\n   - **Status**: No changes needed\n\n4. **useProfiles** (`src/hooks/useProfiles.ts`)\n   - **Already fetches** profiles from API with React Query\n   - **Extend**: Add `refetchOnActivation` option to update active profile state\n   - **Changes**: Minor - ensure cache invalidation on activation\n\n5. **useWasm** (`src/hooks/useWasm.ts`)\n   - **Already loads** keyrx_core WASM module and provides validation\n   - **Reuse in**: SimulatorPage for event processing\n   - **Status**: No changes needed\n\n6. **Modal** (`src/components/Modal.tsx`)\n   - **Already implemented** accessible modal with focus trap, Escape key handling\n   - **Reuse in**: KeyMappingDialog, error dialogs\n   - **Status**: No changes needed\n\n7. **Card, Button, Dropdown, Input** (`src/components/*.tsx`)\n   - **Already implemented** with consistent design tokens\n   - **Reuse in**: All new components\n   - **Status**: No changes needed\n\n### Existing API Endpoints to Use\n\n**No new backend endpoints needed** for bugfixes. Existing endpoints cover all functionality:\n\n1. `GET /api/devices` - Fetch device list (exists, used by DevicesPage)\n2. `PUT /api/devices/:serial/layout` - Save device layout (via RPC `setDeviceLayout`)\n3. `GET /api/profiles` - Fetch profiles with `isActive` flag (exists)\n4. `POST /api/profiles/:name/activate` - Activate profile (exists)\n5. `GET /api/config/:profile` - Fetch profile configuration (exists)\n6. `PUT /api/config/:profile/key` - Save key mapping (exists)\n7. `GET /api/metrics` - Fetch latency metrics (exists)\n8. `WS /ws` - WebSocket for real-time updates (exists)\n\n**All bugfixes use existing APIs.** Only frontend changes required.\n\n## Architecture\n\n### Overall System Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Frontend (React + TypeScript)\"\n        HP[HomePage]\n        DP[DevicesPage]\n        PP[ProfilesPage]\n        CP[ConfigPage]\n        MP[MetricsPage]\n        SP[SimulatorPage]\n\n        HP --> DLC[DeviceListCard - FIXED]\n        HP --> APC[ActiveProfileCard]\n\n        DP --> UAS[useAutoSave - REUSED]\n\n        PP --> UP[useProfiles - EXTENDED]\n\n        CP --> KV[KeyboardVisualizer - MODIFIED]\n        CP --> KMD[KeyMappingDialog - NEW]\n        CP --> DKP[DragKeyPalette - NEW]\n        CP --> DST[DeviceScopeToggle - REUSED]\n\n        SP --> UW[useWasm - REUSED]\n        SP --> KV2[KeyboardVisualizer - REUSED]\n    end\n\n    subgraph \"API Layer (Existing)\"\n        API[REST API]\n        WS[WebSocket]\n    end\n\n    subgraph \"Backend (axum + keyrx_daemon)\"\n        Daemon[keyrx_daemon]\n    end\n\n    HP --> API\n    DP --> API\n    PP --> API\n    CP --> API\n    MP --> API\n    MP --> WS\n    SP --> WS\n\n    API --> Daemon\n    WS --> Daemon\n\n    style DLC fill:#ffeb3b\n    style UAS fill:#81c784\n    style UP fill:#fff176\n    style KV fill:#fff176\n    style KMD fill:#4fc3f7\n    style DKP fill:#4fc3f7\n    style DST fill:#81c784\n    style UW fill:#81c784\n\n    classDef fixed fill:#ffeb3b\n    classDef new fill:#4fc3f7\n    classDef extended fill:#fff176\n    classDef reused fill:#81c784\n```\n\n**Legend**:\n- ðŸŸ¨ Yellow: Fixed (bugfix in existing component)\n- ðŸŸ¦ Blue: New (new component)\n- ðŸŸ¡ Light Yellow: Extended (modified existing component)\n- ðŸŸ© Green: Reused (no changes)\n\n---\n\n## Components and Interfaces\n\n### Requirement 1: Dashboard Device Count Fix\n\n**Component: DeviceListCard** (MODIFY EXISTING)\n\n**File**: `keyrx_ui/src/components/DeviceListCard.tsx`\n\n**Purpose**: Display connected devices count with live data from API\n\n**Current Bug**: Hardcoded `devices` prop, doesn't fetch from API\n\n**Changes Required**:\n```typescript\n// BEFORE (current):\nexport const DeviceListCard: React.FC<{ devices: Device[] }> = ({ devices }) => {\n  return <div>Connected Devices ({devices.length})</div>;\n};\n\n// AFTER (fixed):\nexport const DeviceListCard: React.FC = () => {\n  const { data: devices, isLoading, error } = useDevices(); // Use React Query hook\n\n  if (isLoading) return <LoadingSkeleton variant=\"card\" />;\n  if (error) return <ErrorState error={error} onRetry={() => refetch()} />;\n\n  return <div>Connected Devices ({devices?.length ?? 0})</div>;\n};\n```\n\n**Dependencies**:\n- `useDevices` hook (already exists in `src/hooks/useDevices.ts`)\n- `LoadingSkeleton` (already exists)\n- `ErrorState` (already exists)\n\n**Integration**: HomePage renders DeviceListCard without props (remove `devices` prop)\n\n**Testing**:\n- Unit test: Mock `useDevices` hook, verify count updates\n- E2E test: Start daemon with 3 devices, verify Dashboard shows \"Connected Devices (3)\"\n\n---\n\n### Requirement 2: Device Layout Auto-Save Fix\n\n**Component: DevicesPage** (VERIFY EXISTING)\n\n**File**: `keyrx_ui/src/pages/DevicesPage.tsx` (lines 76-88)\n\n**Purpose**: Persist layout selection using `useAutoSave` hook\n\n**Current Implementation**: Already correct! Uses `useAutoSave` with `rpcClient.setDeviceLayout(serial, layout)`.\n\n**Potential Bug**: API endpoint might not be persisting correctly.\n\n**Changes Required**: **None in frontend.** If bug persists, investigate backend `setDeviceLayout` RPC handler.\n\n**Testing**:\n- Integration test: Select JIS 109, navigate away, return, verify JIS 109 is still selected\n- Check API: `GET /api/devices` should return `layout: \"JIS_109\"` after save\n\n---\n\n### Requirement 3: Profile Activation State Persistence Fix\n\n**Component: ProfilesPage** (MODIFY EXISTING)\n\n**File**: `keyrx_ui/src/pages/ProfilesPage.tsx` (lines 113-132)\n\n**Purpose**: Persist active profile state after activation\n\n**Current Bug**: `isActive` badge disappears after ~1 second\n\n**Root Cause Analysis**:\n```typescript\n// Current code (lines 113-132):\nconst handleActivateProfile = async (profileId: string) => {\n  setActivationError(null);\n  try {\n    const result = await activateProfileMutation.mutateAsync(profileId);\n\n    // BUG: Compilation errors set activationError but don't prevent badge from appearing\n    if (result.errors && result.errors.length > 0) {\n      const errorMessage = result.errors.join('\\n');\n      setActivationError(`Compilation failed:\\n${errorMessage}`);\n      console.error('Compilation errors:', result.errors);\n    }\n  } catch (err) {\n    setActivationError(`Failed to activate profile: ${errorMessage}`);\n  }\n};\n```\n\n**Problem**: React Query cache might not be updating `isActive` flag correctly after activation.\n\n**Solution**: Invalidate profiles cache and refetch after successful activation:\n```typescript\nconst handleActivateProfile = async (profileId: string) => {\n  setActivationError(null);\n  try {\n    const result = await activateProfileMutation.mutateAsync(profileId);\n\n    if (result.errors && result.errors.length > 0) {\n      setActivationError(`Compilation failed:\\n${result.errors.join('\\n')}`);\n      return; // Don't update cache if compilation failed\n    }\n\n    // SUCCESS: Invalidate cache to refetch updated isActive state\n    await queryClient.invalidateQueries({ queryKey: ['profiles'] });\n\n  } catch (err) {\n    setActivationError(`Failed to activate profile: ${getErrorMessage(err)}`);\n  }\n};\n```\n\n**Dependencies**:\n- `useQueryClient` hook from `@tanstack/react-query`\n- Existing `activateProfileMutation` (already implemented)\n\n**Testing**:\n- E2E test: Click \"Activate\" on profile, wait 5 seconds, verify [Active] badge persists\n- API test: Verify `GET /api/profiles` returns correct `isActive: true` after activation\n\n---\n\n### Requirement 4: QMK-Style Drag-and-Drop Configuration Editor\n\n**NEW COMPONENTS**:\n\n#### 4.1 DragKeyPalette Component\n\n**File**: `keyrx_ui/src/components/config/DragKeyPalette.tsx` (NEW)\n\n**Purpose**: Display draggable virtual keys, modifiers, layers, macros\n\n**Interface**:\n```typescript\nexport interface AssignableKey {\n  id: string;           // e.g., \"VK_A\", \"MD_SHIFT\", \"LK_CAPSLOCK\"\n  category: 'vk' | 'modifier' | 'lock' | 'layer' | 'macro';\n  label: string;        // e.g., \"A\", \"Shift\", \"CapsLock\"\n  description: string;  // e.g., \"Virtual Key A\"\n  icon?: React.ReactNode;\n}\n\nexport interface DragKeyPaletteProps {\n  onDragStart?: (key: AssignableKey) => void;\n  onDragEnd?: () => void;\n  filterCategory?: string; // Filter by category\n  className?: string;\n}\n\nexport const DragKeyPalette: React.FC<DragKeyPaletteProps> = ({...}) => {\n  const { attributes, listeners, setNodeRef, transform } = useDraggable({\n    id: key.id,\n    data: { key },\n  });\n\n  return (\n    <div className=\"grid grid-cols-4 gap-2\">\n      {assignableKeys.map((key) => (\n        <div\n          key={key.id}\n          ref={setNodeRef}\n          {...listeners}\n          {...attributes}\n          className=\"p-2 bg-slate-700 rounded cursor-grab active:cursor-grabbing\"\n        >\n          {key.label}\n        </div>\n      ))}\n    </div>\n  );\n};\n```\n\n**Dependencies**:\n- `@dnd-kit/core`: For `useDraggable` hook\n- Existing `Button` component for styling consistency\n\n**Data Source**: Static list of assignable keys (VK_A through VK_Z, MD_*, LK_*, Layer names)\n\n---\n\n#### 4.2 KeyMappingDialog Component\n\n**File**: `keyrx_ui/src/components/config/KeyMappingDialog.tsx` (NEW)\n\n**Purpose**: Modal for configuring individual key mappings (click-to-edit alternative to drag-and-drop)\n\n**Interface**:\n```typescript\nexport interface KeyMapping {\n  keyCode: string;      // Physical key code (e.g., \"CapsLock\")\n  type: 'simple' | 'tap-hold' | 'macro' | 'layer-switch';\n  simple?: string;      // VK_A for simple mapping\n  tapHold?: {\n    tap: string;        // Tap action\n    hold: string;       // Hold action\n    timeoutMs: number;  // Tap/hold threshold\n  };\n  macro?: string[];     // Array of key codes for macro\n  layer?: string;       // Layer name for layer switch\n}\n\nexport interface KeyMappingDialogProps {\n  open: boolean;\n  onClose: () => void;\n  keyCode: string;              // e.g., \"CapsLock\"\n  currentMapping?: KeyMapping;\n  onSave: (mapping: KeyMapping) => Promise<void>;\n}\n\nexport const KeyMappingDialog: React.FC<KeyMappingDialogProps> = ({...}) => {\n  const [mappingType, setMappingType] = useState<KeyMapping['type']>('simple');\n  const [tapAction, setTapAction] = useState('');\n  const [holdAction, setHoldAction] = useState('');\n  const [timeout, setTimeout] = useState(200);\n\n  const handleSave = async () => {\n    const mapping: KeyMapping = {\n      keyCode,\n      type: mappingType,\n      tapHold: mappingType === 'tap-hold' ? { tap: tapAction, hold: holdAction, timeoutMs: timeout } : undefined,\n    };\n    await onSave(mapping);\n    onClose();\n  };\n\n  return (\n    <Modal open={open} onClose={onClose} title={`Configure ${keyCode}`}>\n      {/* Form fields based on mappingType */}\n    </Modal>\n  );\n};\n```\n\n**Dependencies**:\n- `Modal` component (already exists)\n- `Dropdown` component (already exists) for action selection\n- `Input` component (already exists) for timeout slider\n\n---\n\n#### 4.3 Modified KeyboardVisualizer Component\n\n**File**: `keyrx_ui/src/components/KeyboardVisualizer.tsx` (MODIFY EXISTING)\n\n**Purpose**: Add drag-and-drop drop zones to existing keyboard visualizer\n\n**Current Implementation**: Renders keyboard layout with clickable keys\n\n**Changes Required**:\n```typescript\n// ADD: New prop for drag-and-drop support\nexport interface KeyboardVisualizerProps {\n  // ... existing props ...\n  onKeyDrop?: (keyCode: string, assignedKey: AssignableKey) => void;  // NEW\n  keyMappings?: Map<string, KeyMapping>;  // NEW: Display current mappings\n  activeLayer?: string;  // NEW: Show layer-specific mappings\n}\n\n// MODIFY: KeyButton to be droppable\nconst KeyButtonWithDrop: React.FC<...> = ({ keyCode, onDrop, mapping }) => {\n  const { isOver, setNodeRef } = useDroppable({\n    id: keyCode,\n    data: { keyCode },\n  });\n\n  return (\n    <div\n      ref={setNodeRef}\n      className={cn(\n        \"key-button\",\n        isOver && \"ring-2 ring-blue-500\", // Highlight on drag-over\n        mapping && \"bg-primary-500\" // Show mapping exists\n      )}\n    >\n      <div className=\"key-label\">{keyCode}</div>\n      {mapping && <div className=\"mapping-label\">{mapping.simple ?? '...'}</div>}\n    </div>\n  );\n};\n```\n\n**Dependencies**:\n- `@dnd-kit/core`: For `useDroppable` hook\n- Existing `KeyButton` component (modify to add drop zone)\n\n**Backward Compatibility**: All new props are optional, existing usage still works\n\n---\n\n#### 4.4 Modified ConfigPage\n\n**File**: `keyrx_ui/src/pages/ConfigPage.tsx` (MAJOR MODIFICATION)\n\n**Purpose**: Add drag-and-drop UI layer on top of existing Monaco editor\n\n**New Architecture**:\n```typescript\nexport const ConfigPage: React.FC<ConfigPageProps> = ({ profileName }) => {\n  const [activeTab, setActiveTab] = useState<'visual' | 'code'>('visual');\n  const [selectedLayer, setSelectedLayer] = useState('base');\n  const [scope, setScope] = useState<MappingScope>('global');\n  const [selectedDevice, setSelectedDevice] = useState<string>('');\n  const [keyMappings, setKeyMappings] = useState<Map<string, KeyMapping>>(new Map());\n  const [activeDragKey, setActiveDragKey] = useState<AssignableKey | null>(null);\n\n  // Drag-and-drop handlers\n  const handleDragStart = (key: AssignableKey) => setActiveDragKey(key);\n  const handleDragEnd = () => setActiveDragKey(null);\n\n  const handleKeyDrop = async (keyCode: string) => {\n    if (!activeDragKey) return;\n\n    // Create mapping\n    const newMapping: KeyMapping = {\n      keyCode,\n      type: 'simple',\n      simple: activeDragKey.id,\n    };\n\n    // Update local state\n    setKeyMappings(prev => new Map(prev).set(keyCode, newMapping));\n\n    // Auto-save via API\n    await setProfileConfig({\n      name: profileName,\n      key: keyCode,\n      mapping: newMapping,\n    });\n  };\n\n  return (\n    <DndContext onDragStart={handleDragStart} onDragEnd={handleDragEnd}>\n      <ProfileHeader profileName={profileName} />\n      <DeviceScopeToggle scope={scope} onScopeChange={setScope} devices={devices} />\n      <LayerSelector activeLayer={selectedLayer} onLayerChange={setSelectedLayer} />\n\n      <div className=\"grid grid-cols-[300px_1fr] gap-4\">\n        <DragKeyPalette onDragStart={handleDragStart} />\n        <KeyboardVisualizer\n          layout={selectedLayout}\n          keyMappings={keyMappings}\n          onKeyDrop={handleKeyDrop}\n          activeLayer={selectedLayer}\n        />\n      </div>\n\n      {/* Fallback: Monaco editor for advanced users */}\n      <MonacoEditor code={configCode} onChange={setConfigCode} />\n    </DndContext>\n  );\n};\n```\n\n**Dependencies**:\n- `DndContext` from `@dnd-kit/core` (NEW)\n- All child components listed above (NEW + MODIFIED)\n- `useProfileConfig` hook (already exists)\n\n---\n\n### Requirement 5: Profile-Centric Configuration Workflow\n\n**NEW COMPONENT: ProfileHeader**\n\n**File**: `keyrx_ui/src/components/config/ProfileHeader.tsx` (NEW)\n\n**Purpose**: Display profile context in ConfigPage header\n\n**Interface**:\n```typescript\nexport interface ProfileHeaderProps {\n  profileName: string;\n  isActive?: boolean;\n  lastModified?: Date;\n  onProfileChange?: (newProfileName: string) => void;\n  availableProfiles?: string[];\n}\n\nexport const ProfileHeader: React.FC<ProfileHeaderProps> = ({...}) => {\n  return (\n    <div className=\"flex items-center justify-between\">\n      <div className=\"flex items-center gap-4\">\n        <h1>Editing: {profileName}</h1>\n        {isActive && <Badge variant=\"success\">Active</Badge>}\n      </div>\n      <Dropdown\n        options={availableProfiles.map(p => ({ value: p, label: p }))}\n        value={profileName}\n        onChange={onProfileChange}\n        aria-label=\"Select profile\"\n      />\n    </div>\n  );\n};\n```\n\n**Dependencies**:\n- `Dropdown` component (already exists)\n- `Badge` component (create simple version or use span with styles)\n\n**Integration**: ConfigPage renders ProfileHeader at top, passes profile name from URL query param\n\n---\n\n### Requirement 6: Metrics Page Profile Display\n\n**Component: MetricsPage** (MODIFY EXISTING)\n\n**File**: `keyrx_ui/src/pages/MetricsPage.tsx`\n\n**Purpose**: Add active profile display to header\n\n**Changes Required**:\n```typescript\n// ADD: Fetch active profile from API\nexport const MetricsPage: React.FC = () => {\n  const { data: profiles } = useProfiles();\n  const activeProfile = profiles?.find(p => p.isActive);\n\n  return (\n    <div className=\"metrics-page\">\n      {/* NEW: Profile header */}\n      <div className=\"flex items-center gap-4 mb-4\">\n        <h1>Performance Metrics</h1>\n        {activeProfile && (\n          <div className=\"flex items-center gap-2 text-sm text-slate-400\">\n            <span>Active Profile:</span>\n            <Link to={`/config?profile=${activeProfile.name}`} className=\"text-primary-500 hover:underline\">\n              {activeProfile.name}\n            </Link>\n            <span>({activeProfile.name}.rhai)</span>\n          </div>\n        )}\n      </div>\n\n      {/* Existing metrics components */}\n      <MetricsChart data={latencyHistory} />\n      {/* ... */}\n    </div>\n  );\n};\n```\n\n**Dependencies**:\n- `useProfiles` hook (already exists)\n- `Link` from `react-router-dom` (already installed)\n\n---\n\n### Requirement 7: WASM Simulator Dedicated Page\n\n**Component: SimulatorPage** (MODIFY EXISTING)\n\n**File**: `keyrx_ui/src/pages/SimulatorPage.tsx`\n\n**Purpose**: Move WASM simulation to dedicated page with profile selector\n\n**Current Implementation**: Likely basic or empty\n\n**New Implementation**:\n```typescript\nexport const SimulatorPage: React.FC = () => {\n  const [selectedProfile, setSelectedProfile] = useState('Default');\n  const { data: profileConfig } = useGetProfileConfig(selectedProfile);\n  const { processKeyEvent, isWasmReady } = useWasm();\n  const [eventLog, setEventLog] = useState<KeyEvent[]>([]);\n  const [currentState, setCurrentState] = useState<DaemonState | null>(null);\n\n  const handleKeyPress = async (keyCode: string) => {\n    if (!isWasmReady) return;\n\n    const result = await processKeyEvent(keyCode, 'press');\n\n    // Update event log\n    setEventLog(prev => [...prev, { input: keyCode, output: result.outputEvents }]);\n\n    // Update state\n    setCurrentState(result.newState);\n  };\n\n  return (\n    <div className=\"simulator-page\">\n      <div className=\"flex items-center gap-4 mb-4\">\n        <h1>Keyboard Simulator</h1>\n        <Dropdown\n          options={profiles.map(p => ({ value: p.name, label: p.name }))}\n          value={selectedProfile}\n          onChange={setSelectedProfile}\n          aria-label=\"Select profile to simulate\"\n        />\n      </div>\n\n      <div className=\"grid grid-cols-2 gap-4\">\n        <div>\n          <h2>Visual Keyboard</h2>\n          <KeyboardVisualizer\n            layout=\"ANSI_104\"\n            onKeyClick={handleKeyPress}\n            simulatorMode={true}\n          />\n        </div>\n\n        <div>\n          <h2>Event Log</h2>\n          <EventLogList events={eventLog} />\n\n          <h2>State Inspector</h2>\n          <StateIndicatorPanel state={currentState} />\n        </div>\n      </div>\n    </div>\n  );\n};\n```\n\n**Dependencies**:\n- `useWasm` hook (already exists)\n- `KeyboardVisualizer` component (already exists, reuse)\n- `StateIndicatorPanel` component (already exists)\n- New `EventLogList` component (simple list rendering)\n\n---\n\n### Requirement 8: Device List Integration in ConfigPage\n\n**Already Implemented**: ConfigPage uses `DeviceScopeToggle` component which has device list integration.\n\n**Verification**: Ensure `DeviceScopeToggle` receives real devices from `useDevices` hook, not mock data.\n\n**Changes Required**:\n```typescript\n// ConfigPage.tsx - Update devices source\nconst { data: devices, isLoading: isLoadingDevices } = useDevices(); // Fetch real devices\n\nconst deviceOptions: DeviceOption[] = useMemo(() =>\n  devices?.map(d => ({\n    serial: d.serial ?? d.id,\n    name: d.name,\n  })) ?? [],\n  [devices]\n);\n\n<DeviceScopeToggle\n  scope={scope}\n  onScopeChange={setScope}\n  devices={deviceOptions}  // Pass real devices, not mock\n  selectedDevice={selectedDevice}\n  onDeviceChange={setSelectedDevice}\n/>\n```\n\n**Dependencies**: `useDevices` hook (already exists)\n\n---\n\n## Data Models\n\n### KeyMapping Type\n\n```typescript\n/**\n * Represents a key mapping configuration\n */\nexport interface KeyMapping {\n  /** Physical key code (e.g., \"CapsLock\", \"A\") */\n  keyCode: string;\n\n  /** Mapping type */\n  type: 'simple' | 'tap-hold' | 'macro' | 'layer-switch';\n\n  /** Simple key mapping (VK_A, VK_ENTER, etc.) */\n  simple?: string;\n\n  /** Tap-hold configuration */\n  tapHold?: {\n    tap: string;        // Tap action (VK_A)\n    hold: string;       // Hold action (VK_SHIFT, Layer(\"nav\"))\n    timeoutMs: number;  // Threshold (100-500ms)\n  };\n\n  /** Macro sequence */\n  macro?: string[];\n\n  /** Layer name for layer switch */\n  layer?: string;\n}\n```\n\n### AssignableKey Type\n\n```typescript\n/**\n * Represents a draggable virtual key in the palette\n */\nexport interface AssignableKey {\n  /** Unique identifier (e.g., \"VK_A\", \"MD_SHIFT\") */\n  id: string;\n\n  /** Category for filtering */\n  category: 'vk' | 'modifier' | 'lock' | 'layer' | 'macro';\n\n  /** Display label */\n  label: string;\n\n  /** Tooltip description */\n  description: string;\n\n  /** Optional icon */\n  icon?: React.ReactNode;\n}\n```\n\n### Layer Type\n\n```typescript\n/**\n * Represents a keyboard layer\n */\nexport interface Layer {\n  /** Layer identifier (e.g., \"base\", \"nav\", \"num\") */\n  id: string;\n\n  /** Display name */\n  name: string;\n\n  /** Key mappings specific to this layer */\n  mappings: Map<string, KeyMapping>;\n}\n```\n\n---\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. Device API Fetch Failure\n\n**Scenario**: `GET /api/devices` returns 500 error or timeout\n\n**Handling**:\n```typescript\nconst { data: devices, isLoading, error, refetch } = useDevices();\n\nif (error) {\n  return (\n    <ErrorState\n      error={new Error(\"Failed to fetch devices\")}\n      onRetry={refetch}\n      message=\"Unable to connect to daemon. Please check if keyrx daemon is running.\"\n    />\n  );\n}\n```\n\n**User Impact**: Dashboard shows error message with \"Retry\" button, doesn't crash app\n\n---\n\n#### 2. Profile Activation Compilation Error\n\n**Scenario**: Activating profile fails due to Rhai syntax error\n\n**Handling**:\n```typescript\nconst handleActivateProfile = async (profileId: string) => {\n  try {\n    const result = await activateProfileMutation.mutateAsync(profileId);\n\n    if (result.errors && result.errors.length > 0) {\n      // Show detailed error modal\n      setActivationError({\n        title: \"Compilation Failed\",\n        errors: result.errors,\n        suggestion: \"Check your Rhai configuration for syntax errors\",\n      });\n      return; // Don't update cache\n    }\n\n    // Success: invalidate cache\n    await queryClient.invalidateQueries({ queryKey: ['profiles'] });\n\n  } catch (err) {\n    setActivationError({\n      title: \"Activation Failed\",\n      message: getErrorMessage(err),\n      suggestion: \"Check daemon logs for details\",\n    });\n  }\n};\n```\n\n**User Impact**: Error modal with line numbers and syntax errors, previous profile remains active\n\n---\n\n#### 3. Drag-and-Drop Save Failure\n\n**Scenario**: Dropping key onto keyboard fails to save to API\n\n**Handling**:\n```typescript\nconst handleKeyDrop = async (keyCode: string) => {\n  const optimisticMapping = { keyCode, simple: activeDragKey.id };\n\n  // Optimistic update\n  setKeyMappings(prev => new Map(prev).set(keyCode, optimisticMapping));\n\n  try {\n    await setProfileConfig({ name: profileName, key: keyCode, mapping: optimisticMapping });\n  } catch (err) {\n    // Rollback on error\n    setKeyMappings(prev => {\n      const newMap = new Map(prev);\n      newMap.delete(keyCode);\n      return newMap;\n    });\n\n    // Show error toast\n    toast.error(`Failed to save mapping: ${getErrorMessage(err)}`);\n  }\n};\n```\n\n**User Impact**: Visual feedback on success/failure, automatic rollback on error\n\n---\n\n#### 4. WASM Module Load Failure\n\n**Scenario**: keyrx_core WASM fails to load in SimulatorPage\n\n**Handling**:\n```typescript\nconst { isWasmReady, wasmError } = useWasm();\n\nif (wasmError) {\n  return (\n    <ErrorState\n      error={wasmError}\n      message=\"WASM module failed to load. Try refreshing the page.\"\n      onRetry={() => window.location.reload()}\n    />\n  );\n}\n\nif (!isWasmReady) {\n  return <LoadingSkeleton variant=\"page\" message=\"Loading simulator...\" />;\n}\n```\n\n**User Impact**: Clear error message with refresh button, doesn't break entire app\n\n---\n\n## Testing Strategy\n\n### Unit Testing\n\n**Components to Test**:\n1. **DragKeyPalette**: Verify draggable items render, drag events fire\n2. **KeyMappingDialog**: Verify form validation, save callback\n3. **ProfileHeader**: Verify profile name display, dropdown interaction\n4. **DeviceListCard**: Verify device count updates, loading states\n\n**Example Test**:\n```typescript\n// DeviceListCard.test.tsx\ndescribe('DeviceListCard', () => {\n  it('should display device count from API', async () => {\n    mockUseDevices.mockReturnValue({\n      data: [{ id: '1', name: 'Device 1' }, { id: '2', name: 'Device 2' }],\n      isLoading: false,\n      error: null,\n    });\n\n    const { getByText } = render(<DeviceListCard />);\n\n    await waitFor(() => {\n      expect(getByText('Connected Devices (2)')).toBeInTheDocument();\n    });\n  });\n\n  it('should show error state when API fails', async () => {\n    mockUseDevices.mockReturnValue({\n      data: null,\n      isLoading: false,\n      error: new Error('API Error'),\n    });\n\n    const { getByText, getByRole } = render(<DeviceListCard />);\n\n    expect(getByText(/Unable to connect/i)).toBeInTheDocument();\n    expect(getByRole('button', { name: /retry/i })).toBeInTheDocument();\n  });\n});\n```\n\n---\n\n### Integration Testing\n\n**Critical User Flows**:\n\n#### 1. Drag-and-Drop Key Assignment Flow\n\n**Test**: User drags VK_A from palette and drops onto CapsLock key\n\n```typescript\n// ConfigPage.integration.test.tsx\ndescribe('ConfigPage - Drag and Drop', () => {\n  it('should assign key mapping via drag and drop', async () => {\n    const { getByText, getByTestId } = render(<ConfigPage profileName=\"gaming\" />);\n\n    // 1. Find draggable key\n    const vkA = getByText('A');\n    const capsLock = getByTestId('key-CapsLock');\n\n    // 2. Drag and drop\n    fireEvent.dragStart(vkA);\n    fireEvent.dragOver(capsLock);\n    fireEvent.drop(capsLock);\n\n    // 3. Verify mapping appears\n    await waitFor(() => {\n      expect(capsLock).toHaveTextContent('A');\n    });\n\n    // 4. Verify API was called\n    expect(mockSetProfileConfig).toHaveBeenCalledWith({\n      name: 'gaming',\n      key: 'CapsLock',\n      mapping: { keyCode: 'CapsLock', type: 'simple', simple: 'VK_A' },\n    });\n  });\n});\n```\n\n#### 2. Profile Activation Persistence Flow\n\n**Test**: User activates profile, refreshes page, badge persists\n\n```typescript\n// ProfilesPage.integration.test.tsx\ndescribe('ProfilesPage - Activation', () => {\n  it('should persist active profile badge after page refresh', async () => {\n    const { getByText, getByRole } = render(<ProfilesPage />);\n\n    // 1. Activate profile\n    const activateButton = getByRole('button', { name: /activate.*gaming/i });\n    fireEvent.click(activateButton);\n\n    // 2. Wait for activation\n    await waitFor(() => {\n      expect(getByText('[Active]')).toBeInTheDocument();\n    });\n\n    // 3. Simulate page refresh (re-mount component)\n    const { getByText: getByText2 } = render(<ProfilesPage />);\n\n    // 4. Verify badge still appears\n    await waitFor(() => {\n      expect(getByText2('[Active]')).toBeInTheDocument();\n    });\n  });\n});\n```\n\n---\n\n### End-to-End Testing (Playwright)\n\n**Critical E2E Scenarios**:\n\n#### 1. Complete Configuration Workflow\n\n```typescript\n// e2e/configuration-workflow.spec.ts\ntest('complete keyboard configuration workflow', async ({ page }) => {\n  // 1. Navigate to profiles page\n  await page.goto('http://localhost:5173/profiles');\n\n  // 2. Create new profile\n  await page.click('button:has-text(\"Create Profile\")');\n  await page.fill('input[name=\"profileName\"]', 'e2e-test-profile');\n  await page.click('button:has-text(\"Create\")');\n\n  // 3. Navigate to config page\n  await page.click(`a:has-text(\"Edit Configuration\")`);\n\n  // 4. Assign key mapping via drag-and-drop\n  const vkA = page.locator('text=A').first();\n  const capsLock = page.locator('[data-testid=\"key-CapsLock\"]');\n  await vkA.dragTo(capsLock);\n\n  // 5. Verify mapping appears\n  await expect(capsLock).toContainText('A');\n\n  // 6. Activate profile\n  await page.click('button:has-text(\"Activate Profile\")');\n\n  // 7. Verify in metrics page\n  await page.goto('http://localhost:5173/metrics');\n  await expect(page.locator('text=Active Profile: e2e-test-profile')).toBeVisible();\n});\n```\n\n---\n\n### Accessibility Testing\n\n**Automated Checks** (using axe-core):\n```typescript\n// accessibility.spec.ts\ndescribe('Accessibility', () => {\n  it('ConfigPage should have no accessibility violations', async () => {\n    const { container } = render(<ConfigPage profileName=\"default\" />);\n    const results = await axe(container);\n    expect(results.violations).toHaveLength(0);\n  });\n});\n```\n\n**Manual Checks**:\n1. **Keyboard Navigation**: Tab through ConfigPage, verify all interactive elements are reachable\n2. **Screen Reader**: Test with NVDA/JAWS, verify drag-and-drop announces \"Grabbed VK_A, use arrows to select drop target\"\n3. **Focus Indicators**: Verify 2px outline visible on all focusable elements\n\n---\n\n## Performance Considerations\n\n### Bundle Size Impact\n\n**New Dependencies**:\n- `@dnd-kit/core`: 14KB gzipped\n- `@dnd-kit/utilities`: 3KB gzipped\n- **Total**: 17KB added (well within 50KB budget)\n\n**Code Splitting**:\n```typescript\n// Lazy load ConfigPage to reduce initial bundle\nconst ConfigPage = lazy(() => import('./pages/ConfigPage'));\n\n// In router:\n<Route path=\"/config\" element={\n  <Suspense fallback={<LoadingSkeleton variant=\"page\" />}>\n    <ConfigPage />\n  </Suspense>\n} />\n```\n\n### Rendering Performance\n\n**KeyboardVisualizer Optimization**:\n- Use `React.memo` to prevent unnecessary re-renders\n- Memoize key mappings to avoid recalculating on every render\n\n```typescript\nconst KeyboardVisualizer = React.memo<KeyboardVisualizerProps>(({ keyMappings, ...props }) => {\n  const memoizedMappings = useMemo(() => keyMappings, [keyMappings]);\n\n  return (\n    <div className=\"keyboard-visualizer\">\n      {keys.map(key => (\n        <KeyButton\n          key={key.code}\n          mapping={memoizedMappings.get(key.code)}\n        />\n      ))}\n    </div>\n  );\n});\n```\n\n### Auto-Save Debouncing\n\nAlready implemented in `useAutoSave` hook with 500ms debounce. No additional optimization needed.\n\n---\n\n## Migration Strategy\n\n### Phase 1: Bugfixes (Low Risk)\n\n1. Fix DeviceListCard to fetch from API (Req 1)\n2. Verify DevicesPage auto-save works (Req 2)\n3. Fix ProfilesPage activation persistence (Req 3)\n4. Add ProfileHeader to ConfigPage (Req 5)\n5. Add active profile to MetricsPage (Req 6)\n\n**Estimated Time**: 2-4 hours\n**Risk**: Low (minor changes to existing components)\n\n### Phase 2: Simulator Enhancement (Medium Risk)\n\n7. Enhance SimulatorPage with profile selector (Req 7)\n8. Integrate useWasm for event processing\n\n**Estimated Time**: 3-5 hours\n**Risk**: Medium (WASM integration complexity)\n\n### Phase 3: Drag-and-Drop Editor (High Complexity)\n\n4. Create DragKeyPalette component\n5. Create KeyMappingDialog component\n6. Modify KeyboardVisualizer for drop zones\n7. Integrate @dnd-kit in ConfigPage\n8. Add keyboard accessibility (Space to grab, arrows to move)\n\n**Estimated Time**: 8-12 hours\n**Risk**: High (new feature, complex interactions)\n\n### Rollback Plan\n\nIf drag-and-drop implementation fails or has critical bugs:\n1. Keep Monaco editor as primary interface\n2. Feature-flag drag-and-drop behind `enableDragAndDrop` query param\n3. Provide toggle switch: \"Use Visual Editor\" vs \"Use Code Editor\"\n\n---\n\n## Dependencies\n\n### New NPM Packages\n\n```json\n{\n  \"dependencies\": {\n    \"@dnd-kit/core\": \"^6.0.8\",\n    \"@dnd-kit/utilities\": \"^3.2.1\"\n  }\n}\n```\n\n**Installation**:\n```bash\ncd keyrx_ui\nnpm install @dnd-kit/core @dnd-kit/utilities\n```\n\n### Existing Dependencies (No Changes)\n\n- `@tanstack/react-query`: Already used, no version change\n- `react-router-dom`: Already used\n- `zustand`: Already used\n- `@headlessui/react`: Already used (in DeviceScopeToggle)\n\n---\n\n## API Contract\n\n**No backend changes required.** All existing API endpoints support the requirements:\n\n### GET /api/devices\n\n**Response**:\n```json\n{\n  \"devices\": [\n    {\n      \"id\": \"serial-JP\",\n      \"name\": \"ARCHISS PK85PD\",\n      \"path\": \"/dev/input/event2\",\n      \"serial\": \"JP\",\n      \"active\": true,\n      \"scope\": null,\n      \"layout\": \"JIS_109\"\n    }\n  ]\n}\n```\n\n**Used By**: DeviceListCard, DevicesPage, ConfigPage\n\n---\n\n### GET /api/profiles\n\n**Response**:\n```json\n{\n  \"profiles\": [\n    {\n      \"name\": \"gaming\",\n      \"isActive\": true,\n      \"modifiedAt\": \"2026-01-03T15:56:21Z\"\n    }\n  ]\n}\n```\n\n**Used By**: ProfilesPage, MetricsPage, ConfigPage, SimulatorPage\n\n---\n\n### PUT /api/config/:profile/key\n\n**Request**:\n```json\n{\n  \"key\": \"CapsLock\",\n  \"mapping\": {\n    \"keyCode\": \"CapsLock\",\n    \"type\": \"simple\",\n    \"simple\": \"VK_A\"\n  }\n}\n```\n\n**Response**:\n```json\n{\n  \"success\": true\n}\n```\n\n**Used By**: ConfigPage (drag-and-drop save)\n\n---\n\n## Accessibility Compliance (WCAG 2.2 Level AA)\n\n### Keyboard Navigation\n\n**All interactive elements accessible via keyboard**:\n- Tab/Shift+Tab: Navigate between elements\n- Space: Grab/drop dragged item, activate buttons\n- Arrow keys: Move dragged item to adjacent drop zone\n- Enter: Activate links, open dialogs\n- Escape: Close dialogs, cancel drag operation\n\n### Screen Reader Support\n\n**ARIA labels for all components**:\n```typescript\n// DragKeyPalette\n<div\n  role=\"button\"\n  aria-label={`Draggable key ${key.label}`}\n  aria-describedby={`${key.id}-description`}\n  tabIndex={0}\n>\n  {key.label}\n</div>\n<div id={`${key.id}-description`} className=\"sr-only\">\n  {key.description}\n</div>\n\n// KeyboardVisualizer with drop zones\n<div\n  role=\"button\"\n  aria-label={`Key ${keyCode}, ${mapping ? `mapped to ${mapping.simple}` : 'not mapped'}`}\n  aria-dropeffect=\"move\"\n  tabIndex={0}\n>\n  {keyCode}\n</div>\n```\n\n### Focus Management\n\n**Focus indicators visible (2px outline)**:\n```css\n.key-button:focus,\n.draggable-key:focus {\n  outline: 2px solid var(--color-primary-500);\n  outline-offset: 2px;\n}\n```\n\n**Focus trap in modals**:\n- KeyMappingDialog: Focus automatically moves to first input\n- Escape key closes modal, focus returns to trigger button\n\n### Color Contrast\n\n**All text meets WCAG AA requirements (4.5:1 for normal text)**:\n- Background: `slate-900` (#0F172A)\n- Text: `slate-100` (#F1F5F9)\n- Contrast ratio: 15.8:1 âœ…\n\n---\n\n## Summary\n\nThis design provides a **comprehensive, modular solution** to fix 8 critical bugs and add QMK-style drag-and-drop functionality to the existing keyrx web UI. The approach emphasizes:\n\n1. **Code Reuse**: Leverages existing hooks (useAutoSave, useProfiles, useWasm), components (KeyboardVisualizer, Modal, DeviceScopeToggle)\n2. **Minimal Changes**: Bugfixes modify existing files, new features are additive\n3. **Backward Compatibility**: All new props are optional, existing usage still works\n4. **Accessibility First**: Full WCAG 2.2 Level AA compliance with keyboard navigation and screen reader support\n5. **Performance**: Bundle size increase <17KB, lazy loading for ConfigPage\n\n**Next Phase**: Break down into implementation tasks in `tasks.md`.\n",
  "fileStats": {
    "size": 38347,
    "lines": 1377,
    "lastModified": "2026-01-03T07:32:16.255Z"
  },
  "comments": []
}