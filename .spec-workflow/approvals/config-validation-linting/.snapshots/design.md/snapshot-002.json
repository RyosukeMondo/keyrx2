{
  "id": "snapshot_1767224112349_j4pae0puh",
  "approvalId": "approval_1767022111063_0gvpr2wjs",
  "approvalTitle": "Config Validation & Linting - Design",
  "version": 2,
  "timestamp": "2025-12-31T23:35:12.349Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Architecture Overview\n\nThe Configuration Validation & Linting feature integrates the WASM validation engine into the configuration editor UI, providing real-time feedback as users type. The architecture follows a three-layer pattern: **Editor UI** â†’ **Validation Service** â†’ **WASM Module**.\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                         User Types                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                         â”‚\n                         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚              Monaco Editor Component                        â”‚\nâ”‚  - Syntax highlighting                                      â”‚\nâ”‚  - Error squiggles (red underlines)                        â”‚\nâ”‚  - Hover tooltips                                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                         â”‚\n                         â–¼ (debounced 500ms)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         useConfigValidator Hook                             â”‚\nâ”‚  - Debounce user input                                      â”‚\nâ”‚  - Call validator.validate()                                â”‚\nâ”‚  - Update editor markers                                    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                         â”‚\n                         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚            Validator Service                                â”‚\nâ”‚  (keyrx_ui/src/utils/validator.ts)                         â”‚\nâ”‚  - Calls WasmCore.loadConfig()                             â”‚\nâ”‚  - Parses WASM errors                                       â”‚\nâ”‚  - Returns ValidationResult                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                         â”‚\n                         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚              WASM Module                                    â”‚\nâ”‚  (keyrx_core/src/wasm.rs)                                  â”‚\nâ”‚  - load_config(rhaiSource)                                 â”‚\nâ”‚  - Returns Result<ConfigHandle, Error>                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Data Flow\n\n1. **User Types** â†’ Editor onChange fires with new content\n2. **Debounce** â†’ useConfigValidator waits 500ms after last keystroke\n3. **Validate** â†’ validator.validate(content) calls WasmCore.loadConfig()\n4. **Parse Errors** â†’ WASM errors converted to Monaco markers\n5. **Update UI** â†’ Monaco editor displays error squiggles, validation panel updates counts\n\n## Components and Interfaces\n\n### Component 1: ConfigEditor Component (keyrx_ui/src/components/ConfigEditor.tsx)\n\n**Purpose**: Main configuration editor with Monaco editor integration.\n\n**TypeScript Interface**:\n```typescript\ninterface ConfigEditorProps {\n  initialValue?: string;\n  onSave: (content: string) => Promise<void>;\n  onValidationChange?: (result: ValidationResult) => void;\n}\n\ninterface ConfigEditorState {\n  content: string;\n  validationResult: ValidationResult | null;\n  isValidating: boolean;\n}\n```\n\n**Key Methods**:\n- `handleEditorChange(value: string)` â†’ Update content and trigger validation\n- `handleSave()` â†’ Validate one final time, then call onSave if valid\n- `jumpToError(errorIndex: number)` â†’ Move cursor to error location\n\n**Integration Points**:\n- Uses `useConfigValidator` hook for validation logic\n- Uses `@monaco-editor/react` for Monaco editor\n- Displays `ValidationStatusPanel` at bottom\n\n**UI Layout**:\n```\n+-----------------------------------------------------------+\n| Configuration Editor                    [Save] [Test]    |\n+-----------------------------------------------------------+\n| 1  // Base layer configuration                           |\n| 2  layer \"base\" {                                        |\n| 3      map KEY_A to KEY_B                                |\n| 4      map KEY_INVALID to KEY_C    <-- ~~~ (red squiggle)|\n| 5  }                                                      |\n|                                                           |\n|                [Hover tooltip on line 4]                 |\n|                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   |\n|                â”‚ Error: Invalid key code             â”‚   |\n|                â”‚ Line 4, Col 9                       â”‚   |\n|                â”‚ 'KEY_INVALID' is not a valid code   â”‚   |\n|                â”‚ Suggestion: Use KEY_A or KEY_B      â”‚   |\n|                â”‚ [Quick Fix]                         â”‚   |\n|                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   |\n|                                                           |\n| 42 lines                                  [Validating...] |\n+-----------------------------------------------------------+\n| Validation Status                                         |\n| âŒ 1 Error   âš ï¸ 2 Warnings   ğŸ’¡ 1 Hint                   |\n| [View Errors >]                                           |\n+-----------------------------------------------------------+\n```\n\n### Component 2: useConfigValidator Hook (keyrx_ui/src/hooks/useConfigValidator.ts)\n\n**Purpose**: React hook that manages validation state and debouncing.\n\n**TypeScript Interface**:\n```typescript\ninterface UseConfigValidatorOptions {\n  debounceMs?: number;  // Default 500ms\n  enableLinting?: boolean;  // Default true\n}\n\ninterface UseConfigValidatorReturn {\n  validationResult: ValidationResult | null;\n  isValidating: boolean;\n  validate: (content: string) => Promise<void>;\n  clearValidation: () => void;\n}\n\nfunction useConfigValidator(\n  options?: UseConfigValidatorOptions\n): UseConfigValidatorReturn;\n```\n\n**Key Implementation**:\n```typescript\nconst useConfigValidator = (options = {}) => {\n  const [result, setResult] = useState<ValidationResult | null>(null);\n  const [isValidating, setIsValidating] = useState(false);\n\n  const debouncedValidate = useMemo(\n    () => debounce(async (content: string) => {\n      setIsValidating(true);\n      try {\n        const validationResult = await validator.validate(content);\n        setResult(validationResult);\n      } catch (error) {\n        setResult({ errors: [parseWasmError(error)], warnings: [], hints: [] });\n      } finally {\n        setIsValidating(false);\n      }\n    }, options.debounceMs || 500),\n    [options.debounceMs]\n  );\n\n  return { validationResult: result, isValidating, validate: debouncedValidate, clearValidation: () => setResult(null) };\n};\n```\n\n### Component 3: Validator Service (keyrx_ui/src/utils/validator.ts)\n\n**Purpose**: Core validation logic that wraps WASM module.\n\n**TypeScript Interface**:\n```typescript\nexport interface ValidationResult {\n  errors: ValidationError[];\n  warnings: ValidationWarning[];\n  hints: ValidationHint[];\n  stats?: ConfigStats;\n}\n\nexport interface ValidationError {\n  line: number;\n  column: number;\n  endLine?: number;\n  endColumn?: number;\n  message: string;\n  code: string;  // e.g., \"SYNTAX_ERROR\", \"UNDEFINED_LAYER\"\n  suggestion?: string;\n  quickFix?: QuickFix;\n}\n\nexport interface ValidationWarning {\n  line: number;\n  column: number;\n  message: string;\n  code: string;  // e.g., \"UNUSED_LAYER\"\n}\n\nexport interface ValidationHint {\n  line: number;\n  column: number;\n  message: string;\n  code: string;  // e.g., \"NAMING_INCONSISTENCY\"\n}\n\nexport interface QuickFix {\n  title: string;\n  edits: TextEdit[];\n}\n\nexport interface TextEdit {\n  range: { startLine: number, startColumn: number, endLine: number, endColumn: number };\n  newText: string;\n}\n\nexport interface ConfigStats {\n  lineCount: number;\n  mappingCount: number;\n  layerCount: number;\n}\n\nclass ConfigValidator {\n  async validate(rhaiSource: string): Promise<ValidationResult> {\n    // Implementation\n  }\n\n  private parseWasmError(wasmError: any): ValidationError[] {\n    // Convert WASM JsValue errors to ValidationError format\n  }\n\n  private runLintingRules(configHandle: ConfigHandle): ValidationWarning[] {\n    // Run optional linting rules (unused layers, naming conventions)\n  }\n}\n\nexport const validator = new ConfigValidator();\n```\n\n### Component 4: ValidationStatusPanel (keyrx_ui/src/components/ValidationStatusPanel.tsx)\n\n**Purpose**: Bottom panel showing error/warning counts with quick navigation.\n\n**TypeScript Interface**:\n```typescript\ninterface ValidationStatusPanelProps {\n  validationResult: ValidationResult | null;\n  isValidating: boolean;\n  onErrorClick: (error: ValidationError) => void;\n  onWarningClick: (warning: ValidationWarning) => void;\n}\n```\n\n**UI Layout**:\n```\n+-----------------------------------------------------------+\n| Validation Status                                         |\n+-----------------------------------------------------------+\n| âŒ 2 Errors   âš ï¸ 3 Warnings   ğŸ’¡ 1 Hint                  |\n|                                                           |\n| Errors:                                                   |\n|  â€¢ Line 4: Invalid key code 'KEY_INVALID'      [Jump]    |\n|  â€¢ Line 12: Missing semicolon after statement  [Jump]    |\n|                                                           |\n| Warnings:                                                 |\n|  â€¢ Line 5: Layer 'debug' is defined but never used        |\n|  â€¢ Line 8: Modifier 'MD_00' not activated in any mapping  |\n|  â€¢ Line 20: Consider using snake_case for layer names     |\n|                                                           |\n| Hints:                                                    |\n|  â€¢ Configuration exceeds 500 lines. Consider splitting.   |\n+-----------------------------------------------------------+\n```\n\n### Component 5: Monaco Editor Integration (keyrx_ui/src/utils/monacoConfig.ts)\n\n**Purpose**: Configure Monaco editor for Rhai syntax highlighting and error markers.\n\n**Key Functions**:\n```typescript\nexport function registerRhaiLanguage() {\n  monaco.languages.register({ id: 'rhai' });\n  monaco.languages.setMonarchTokensProvider('rhai', rhaiSyntax);\n  monaco.languages.setLanguageConfiguration('rhai', rhaiConfig);\n}\n\nexport function updateEditorMarkers(\n  editor: monaco.editor.IStandaloneCodeEditor,\n  validationResult: ValidationResult\n) {\n  const model = editor.getModel();\n  if (!model) return;\n\n  const markers: monaco.editor.IMarkerData[] = [\n    ...validationResult.errors.map(err => ({\n      severity: monaco.MarkerSeverity.Error,\n      startLineNumber: err.line,\n      startColumn: err.column,\n      endLineNumber: err.endLine || err.line,\n      endColumn: err.endColumn || err.column + 10,\n      message: err.message,\n      code: err.code,\n    })),\n    ...validationResult.warnings.map(warn => ({\n      severity: monaco.MarkerSeverity.Warning,\n      startLineNumber: warn.line,\n      startColumn: warn.column,\n      endLineNumber: warn.line,\n      endColumn: warn.column + 10,\n      message: warn.message,\n      code: warn.code,\n    })),\n  ];\n\n  monaco.editor.setModelMarkers(model, 'config-validator', markers);\n}\n\nexport function registerQuickFixProvider() {\n  monaco.languages.registerCodeActionProvider('rhai', {\n    provideCodeActions: (model, range, context) => {\n      // Provide \"Quick Fix\" actions for errors with suggestions\n    }\n  });\n}\n```\n\n## Data Models\n\n### ValidationResult Type\n\n```typescript\nexport type ValidationResult = {\n  errors: ValidationError[];      // Must fix before applying\n  warnings: ValidationWarning[];  // Should review but can ignore\n  hints: ValidationHint[];        // Optional suggestions\n  stats?: ConfigStats;            // Line count, mapping count, etc.\n};\n```\n\n### ValidationError Type\n\n```typescript\nexport type ValidationError = {\n  line: number;          // 1-based line number\n  column: number;        // 1-based column number\n  endLine?: number;      // Optional end position for multi-line errors\n  endColumn?: number;\n  message: string;       // Human-readable error description\n  code: string;          // Machine-readable error code (e.g., \"SYNTAX_ERROR\")\n  suggestion?: string;   // Optional fix suggestion\n  quickFix?: QuickFix;   // Optional automated fix\n};\n```\n\n### QuickFix Type\n\n```typescript\nexport type QuickFix = {\n  title: string;         // e.g., \"Replace with 'gaming'\"\n  edits: TextEdit[];     // Automated edits to apply\n};\n\nexport type TextEdit = {\n  range: { startLine: number, startColumn: number, endLine: number, endColumn: number };\n  newText: string;\n};\n```\n\n## Error Handling\n\n### WASM Validation Errors\n\n```typescript\nasync function validate(rhaiSource: string): Promise<ValidationResult> {\n  try {\n    // Try to load config via WASM\n    const configHandle = await WasmCore.loadConfig(rhaiSource);\n\n    // If successful, run linting rules\n    const warnings = runLintingRules(configHandle);\n\n    return {\n      errors: [],\n      warnings,\n      hints: [],\n      stats: { lineCount: rhaiSource.split('\\n').length, mappingCount: 0, layerCount: 0 }\n    };\n  } catch (wasmError) {\n    // Parse WASM error into ValidationError format\n    const errors = parseWasmError(wasmError);\n    return { errors, warnings: [], hints: [] };\n  }\n}\n\nfunction parseWasmError(wasmError: any): ValidationError[] {\n  // WASM errors come as JsValue with message like:\n  // \"Parse error at line 4, column 9: Invalid key code 'KEY_INVALID'\"\n  const match = wasmError.message.match(/line (\\d+), column (\\d+): (.+)/);\n  if (match) {\n    return [{\n      line: parseInt(match[1]),\n      column: parseInt(match[2]),\n      message: match[3],\n      code: 'WASM_ERROR',\n    }];\n  }\n\n  // Fallback for unparseable errors\n  return [{\n    line: 1,\n    column: 1,\n    message: wasmError.message || 'Unknown validation error',\n    code: 'UNKNOWN_ERROR',\n  }];\n}\n```\n\n### Graceful Degradation\n\nIf WASM module fails to initialize:\n\n```typescript\nfunction useConfigValidator() {\n  const [wasmAvailable, setWasmAvailable] = useState(false);\n\n  useEffect(() => {\n    WasmCore.init()\n      .then(() => setWasmAvailable(true))\n      .catch(() => {\n        console.error('WASM validation unavailable');\n        setWasmAvailable(false);\n      });\n  }, []);\n\n  const validate = async (content: string) => {\n    if (!wasmAvailable) {\n      return {\n        errors: [{\n          line: 1,\n          column: 1,\n          message: 'Validation unavailable. Please reload the page.',\n          code: 'WASM_UNAVAILABLE'\n        }],\n        warnings: [],\n        hints: []\n      };\n    }\n    // ... normal validation\n  };\n\n  return { validate, wasmAvailable };\n}\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n**validator.test.ts**:\n- Test validation of valid Rhai configs (0 errors)\n- Test validation of invalid syntax (parse errors with line numbers)\n- Test validation of semantic errors (undefined layers, invalid key codes)\n- Test WASM error parsing (extract line/column from error messages)\n- Test linting rules (unused layers, naming conventions)\n\n**useConfigValidator.test.ts**:\n- Test debouncing (validate only after 500ms idle)\n- Test validation state updates (isValidating flag)\n- Test error handling (WASM crashes)\n\n### Integration Tests\n\n**ConfigEditor.test.tsx**:\n- Test Monaco editor integration (markers appear on errors)\n- Test hover tooltips (error messages displayed)\n- Test keyboard shortcuts (F8 to jump to next error)\n- Test Quick Fix actions (apply suggested fixes)\n\n### E2E Tests\n\n**config-validation.spec.ts**:\n- Load editor â†’ type invalid config â†’ verify error squiggle appears\n- Hover over error â†’ verify tooltip shows message\n- Click Quick Fix â†’ verify edit applied\n- Fix error â†’ verify squiggle disappears\n- Click \"Apply Configuration\" with errors â†’ verify button disabled\n\n## Performance Considerations\n\n### Debouncing\n\nUse 500ms debounce to avoid excessive WASM calls:\n\n```typescript\nconst debouncedValidate = useMemo(\n  () => debounce(async (content: string) => {\n    await validate(content);\n  }, 500),\n  []\n);\n```\n\n### Web Worker (Future Optimization)\n\nFor very large configs (>2000 lines), run validation in Web Worker to avoid blocking UI:\n\n```typescript\n// Future: validator-worker.ts\nself.addEventListener('message', async (event) => {\n  const { content } = event.data;\n  const result = await validate(content);\n  self.postMessage({ result });\n});\n```\n\n### Incremental Validation (Future)\n\nOnly re-validate changed lines instead of entire file (requires Monaco's incremental parser).\n\n## Dependencies\n\n### Existing Infrastructure\n\n- **WASM Module** (wasm-simulation-integration): load_config function\n- **WasmCore API** (keyrx_ui/src/wasm/core.ts): TypeScript wrapper\n- **React 18**: Hooks (useState, useEffect, useMemo)\n\n### New Dependencies\n\n- `@monaco-editor/react@^4.6.0` - Monaco editor React component\n- `monaco-editor@^0.45.0` - Monaco editor core\n- `lodash.debounce@^4.0.8` - Debounce utility\n\n### Version Constraints\n\n- TypeScript 5.0+ (for strict mode)\n- React 18+ (for concurrent features)\n\n## Code Quality Metrics\n\n- **File Size Limits**:\n  - validator.ts: â‰¤300 lines\n  - useConfigValidator.ts: â‰¤150 lines\n  - ConfigEditor.tsx: â‰¤400 lines\n  - ValidationStatusPanel.tsx: â‰¤200 lines\n- **Function Size**: â‰¤50 lines per function\n- **Test Coverage**: â‰¥90% for validator.ts, â‰¥80% for UI components\n- **TypeScript Strict Mode**: Enabled (no `any` types)\n- **Accessibility**: 0 axe violations, WCAG 2.1 AA compliant\n\n## Architecture Decisions\n\n### Why Monaco Editor Instead of CodeMirror?\n\n**Decision**: Use Monaco editor for configuration editing.\n\n**Rationale**:\n- Built-in TypeScript/JavaScript support (familiar to developers)\n- Rich API for markers, hover providers, code actions\n- Used by VSCode (proven scalability)\n- Better WASM integration (can run language servers in Web Workers)\n\n**Trade-offs**:\n- Larger bundle size (~3MB) vs CodeMirror (~500KB)\n- Accepted because config editor is not on critical path\n\n### Why Debounce Instead of On-Blur Validation?\n\n**Decision**: Validate after 500ms idle time instead of on blur.\n\n**Rationale**:\n- Users see errors faster (don't need to unfocus field)\n- Matches IDE behavior (VSCode, IntelliJ)\n- Research shows [inline validation reduces errors](https://www.smashingmagazine.com/2022/09/inline-validation-web-forms-ux/)\n\n**Trade-offs**:\n- More WASM calls (mitigated by debouncing)\n- Accepted because validation is fast (<100ms)\n\n### Why Reuse WASM Module Instead of Separate Validator?\n\n**Decision**: Reuse load_config function from WASM module for validation.\n\n**Rationale**:\n- 100% parity with daemon validation (same parser, same errors)\n- No code duplication\n- Errors include exact line numbers from parser\n\n**Trade-offs**:\n- Tightly coupled to WASM module (if WASM fails, validation fails)\n- Accepted because graceful degradation handles WASM failures\n\n## Sources\n\nThis design incorporates UI/UX patterns from:\n- [A Complete Guide To Live Validation UX â€” Smashing Magazine](https://www.smashingmagazine.com/2022/09/inline-validation-web-forms-ux/)\n- [Error handling - UX design patterns](https://medium.com/design-bootcamp/error-handling-ux-design-patterns-c2a5bbae5f8d)\n- [Inline Validation UX â€” Smart Interface Design Patterns](https://smart-interface-design-patterns.com/articles/inline-validation-ux/)\n",
  "fileStats": {
    "size": 20684,
    "lines": 591,
    "lastModified": "2025-12-29T15:21:20.612Z"
  },
  "comments": []
}