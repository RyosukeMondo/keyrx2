{
  "id": "snapshot_1766587807992_bjg5aqvkj",
  "approvalId": "approval_1766427125778_2qfumztwn",
  "approvalTitle": "Requirements for Virtual E2E Testing",
  "version": 2,
  "timestamp": "2025-12-24T14:50:07.992Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe Virtual E2E Testing spec implements a fully automated end-to-end test framework for keyrx that runs without real hardware. This enables CI/CD integration and autonomous development by using Linux's uinput subsystem to create virtual input devices that simulate physical keyboards, capturing output from the daemon's virtual keyboard for verification.\n\n**Current State:** E2E tests exist but require real hardware (all marked `#[ignore]`). Mock implementations (MockInput/MockOutput) exist for unit tests but don't exercise the real kernel evdev/uinput path. CI runs unit and integration tests but cannot run E2E tests.\n\n**This Spec Delivers:** A complete virtual device testing framework that:\n1. Creates virtual keyboards using uinput for input injection\n2. Captures output from the daemon's virtual keyboard via evdev\n3. Orchestrates the full input→daemon→output pipeline\n4. Enables E2E tests to run in CI without real hardware\n\n## Alignment with Product Vision\n\nThis spec directly enables the **AI Coding Agent First** principle from product.md:\n\n**From product.md - AI Coding Agent First:**\n> \"keyrx is designed to be verified, modified, and deployed by AI agents without human intervention\"\n> \"Zero Manual Testing: All validation automated (no UAT phase)\"\n\n**How This Spec Delivers:**\n- **Fully automated E2E tests**: No human intervention required\n- **CI-compatible**: Tests run in GitHub Actions without real keyboards\n- **Deterministic verification**: Same input → same output, verifiable by AI agents\n- **No UAT phase**: All validation happens programmatically\n\n**From product.md - Quality Metrics:**\n> \"Test Coverage: 80% minimum, 90% for critical paths\"\n> \"Fuzz Testing: No crashes/panics under 1M+ random input sequences\"\n\n**How This Spec Enables:**\n- **Higher coverage**: E2E tests verify full kernel path (evdev→daemon→uinput)\n- **Regression prevention**: Automated tests catch issues before merge\n- **Platform verification**: Tests real Linux subsystem behavior\n\n**From tech.md - Known Limitation #3:**\n> \"WASM Simulation Cannot Test OS-Specific Quirks\"\n> \"E2E tests on real OS (GitHub Actions matrix)\"\n> \"Future Solution: Record/replay of OS events for deterministic testing\"\n\n**How This Spec Addresses:**\n- **Real OS path**: Tests use actual evdev/uinput kernel interfaces\n- **Virtual devices**: No hardware dependency, runs in VMs/containers\n- **Deterministic replay**: Input sequences can be recorded and replayed\n\n## Requirements\n\n### Requirement 1: Virtual Input Device Creation\n\n**User Story:** As a test framework, I want to create virtual keyboards using uinput, so that I can inject key events into the daemon without physical hardware.\n\n#### Acceptance Criteria\n\n1. **WHEN** test harness calls `VirtualKeyboard::create(name)` **THEN** system **SHALL** create uinput device\n   - Device appears at `/dev/input/eventX`\n   - Device name matches the specified name for pattern matching\n   - Device has keyboard capability (EV_KEY with all key codes)\n   - Returns error if `/dev/uinput` not accessible\n\n2. **WHEN** calling `inject(KeyEvent::Press(keycode))` **THEN** system **SHALL** write evdev event\n   - Write EV_KEY event with value=1 (press)\n   - Write EV_SYN/SYN_REPORT after key event\n   - Event is readable by daemon via evdev\n\n3. **WHEN** calling `inject(KeyEvent::Release(keycode))` **THEN** system **SHALL** write evdev event\n   - Write EV_KEY event with value=0 (release)\n   - Write EV_SYN/SYN_REPORT after key event\n   - Event is readable by daemon via evdev\n\n4. **WHEN** VirtualKeyboard is dropped **THEN** system **SHALL** destroy device cleanly\n   - Remove device from `/dev/input/`\n   - Close file descriptors\n   - No orphaned virtual devices remain\n\n5. **WHEN** multiple VirtualKeyboards created **THEN** system **SHALL** support concurrent devices\n   - Each device has unique path\n   - Each device can inject events independently\n   - Enables multi-device test scenarios\n\n### Requirement 2: Output Event Capture\n\n**User Story:** As a test framework, I want to capture key events from the daemon's virtual keyboard output, so that I can verify remapping behavior.\n\n#### Acceptance Criteria\n\n1. **WHEN** test harness calls `OutputCapture::find_by_name(name)` **THEN** system **SHALL** find device\n   - Enumerate `/dev/input/event*` devices\n   - Match device by name (e.g., \"keyrx Virtual Keyboard\")\n   - Return error if device not found within timeout\n\n2. **WHEN** daemon injects event via uinput **THEN** system **SHALL** capture via evdev\n   - Read EV_KEY events from daemon's output device\n   - Convert to KeyEvent (Press/Release)\n   - Ignore non-key events (EV_SYN, etc.)\n\n3. **WHEN** calling `next_event(timeout)` **THEN** system **SHALL** return event or timeout\n   - Return `Some(KeyEvent)` if event available\n   - Return `None` if timeout expires\n   - Non-blocking by default with configurable timeout\n\n4. **WHEN** calling `collect_events(timeout)` **THEN** system **SHALL** collect all events\n   - Read events until timeout\n   - Return Vec<KeyEvent> with all captured events\n   - Preserve event ordering\n\n5. **WHEN** calling `assert_events(expected)` **THEN** system **SHALL** verify sequence\n   - Compare captured events against expected sequence\n   - Panic with clear diff on mismatch\n   - Support partial matching (ignore extra events)\n\n### Requirement 3: E2E Test Harness Orchestration\n\n**User Story:** As a test developer, I want a high-level harness that manages the full E2E pipeline, so that writing tests is simple and reliable.\n\n#### Acceptance Criteria\n\n1. **WHEN** test calls `E2EHarness::setup(config)` **THEN** system **SHALL** initialize pipeline\n   - Create VirtualKeyboard with identifiable name\n   - Create .krx config file matching virtual keyboard pattern\n   - Start daemon process with config\n   - Wait for daemon to grab virtual keyboard\n   - Find and open daemon's output device\n   - Return harness ready for testing\n\n2. **WHEN** test calls `harness.inject(events)` **THEN** system **SHALL** inject sequence\n   - Inject each KeyEvent via VirtualKeyboard\n   - Support configurable delay between events (default: no delay)\n   - Return after all events injected\n\n3. **WHEN** test calls `harness.capture(timeout)` **THEN** system **SHALL** capture output\n   - Collect events from OutputCapture\n   - Return Vec<KeyEvent> of captured events\n   - Handle timing differences between inject and output\n\n4. **WHEN** test calls `harness.verify(expected)` **THEN** system **SHALL** verify output\n   - Compare captured events against expected\n   - Provide detailed assertion on failure\n   - Support flexible matching modes\n\n5. **WHEN** harness is dropped or `teardown()` called **THEN** system **SHALL** cleanup\n   - Stop daemon process gracefully (SIGTERM)\n   - Wait for daemon to release devices\n   - Destroy virtual keyboard\n   - Remove temporary config files\n   - No orphaned processes or devices\n\n6. **WHEN** daemon fails to start **THEN** system **SHALL** provide diagnostics\n   - Capture daemon stderr output\n   - Report clear error with logs\n   - Cleanup partial resources\n\n### Requirement 4: CI/CD Integration\n\n**User Story:** As a CI/CD pipeline, I want to run virtual E2E tests automatically, so that every PR is validated without manual intervention.\n\n#### Acceptance Criteria\n\n1. **WHEN** CI runs virtual E2E tests **THEN** system **SHALL** execute without hardware\n   - Tests use virtual devices only\n   - No physical keyboard required\n   - Works in GitHub Actions ubuntu-latest\n\n2. **WHEN** CI environment lacks uinput **THEN** system **SHALL** setup permissions\n   - Load uinput kernel module: `modprobe uinput`\n   - Set permissions: `chmod 666 /dev/uinput`\n   - Document required CI setup steps\n\n3. **WHEN** tests pass **THEN** CI **SHALL** report success\n   - Exit code 0 on all tests passing\n   - Clear output showing test results\n   - No false positives\n\n4. **WHEN** tests fail **THEN** CI **SHALL** report failure with diagnostics\n   - Exit code non-zero on failure\n   - Show which test failed and why\n   - Include captured vs expected events\n   - Daemon logs attached for debugging\n\n5. **WHEN** test times out **THEN** system **SHALL** cleanup and fail gracefully\n   - Kill daemon process if hung\n   - Destroy virtual devices\n   - Report timeout with context\n   - No zombie processes left\n\n### Requirement 5: Test Coverage for Remapping Scenarios\n\n**User Story:** As a developer, I want comprehensive E2E test cases covering all remapping types, so that I can verify the daemon works correctly end-to-end.\n\n#### Acceptance Criteria\n\n1. **WHEN** testing simple remap (A→B) **THEN** test **SHALL** verify\n   - Press A → outputs Press B\n   - Release A → outputs Release B\n   - Original key (A) not passed through\n\n2. **WHEN** testing modifier activation (CapsLock→MD_00) **THEN** test **SHALL** verify\n   - Press CapsLock → no output (modifier state set internally)\n   - Release CapsLock → no output (modifier state cleared)\n   - State change verifiable via conditional test\n\n3. **WHEN** testing lock toggle (ScrollLock→LK_00) **THEN** test **SHALL** verify\n   - Press ScrollLock → lock state toggled\n   - Release ScrollLock → no output\n   - Second press toggles lock off\n\n4. **WHEN** testing conditional mapping **THEN** test **SHALL** verify\n   - With modifier active: conditional mapping applies\n   - Without modifier: fallback or passthrough\n   - Complex conditions (AllActive, NotActive)\n\n5. **WHEN** testing modified output (Shift+Key) **THEN** test **SHALL** verify\n   - Press trigger → outputs Press(Shift), Press(Key)\n   - Release trigger → outputs Release(Key), Release(Shift)\n   - Correct ordering maintained\n\n6. **WHEN** testing passthrough (no mapping) **THEN** test **SHALL** verify\n   - Unmapped key passes through unchanged\n   - Press→Press, Release→Release\n   - No state side effects\n\n7. **WHEN** testing multi-event sequences **THEN** test **SHALL** verify\n   - Complex typing patterns work correctly\n   - State accumulates properly across events\n   - No event loss or reordering\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: VirtualKeyboard handles input injection only, OutputCapture handles output reading only, E2EHarness orchestrates both\n- **Modular Design**: Test utilities are reusable across test files\n- **Dependency Management**: Minimal dependencies, use existing evdev/uinput crates\n- **Clear Interfaces**: Public API is simple and discoverable\n\n### Performance\n\n- **Test Execution Time**: Each E2E test completes in <5 seconds\n- **Event Latency**: Inject→capture round-trip <100ms\n- **Parallel Test Support**: Tests can run in parallel with isolated virtual devices\n- **Resource Cleanup**: No resource leaks across test runs\n\n### Security\n\n- **No Privilege Escalation**: Tests run with minimal permissions (input/uinput groups)\n- **Sandboxed Devices**: Virtual devices only affect test environment\n- **No Key Logging**: Test output contains keycodes only, no PII\n\n### Reliability\n\n- **Deterministic Results**: Same test input → same output (no flaky tests)\n- **Graceful Cleanup**: Resources released even on panic/timeout\n- **Error Recovery**: Failed tests don't block subsequent tests\n- **Timeout Handling**: Hung daemon detected and killed\n\n### Usability\n\n- **Simple API**: `harness.inject()` and `harness.verify()` pattern\n- **Clear Errors**: Assertion failures show expected vs actual\n- **Easy Debugging**: Debug logs available, daemon output captured\n- **Documentation**: All public APIs documented with examples\n",
  "fileStats": {
    "size": 11574,
    "lines": 263,
    "lastModified": "2025-12-22T18:11:44.013Z"
  },
  "comments": []
}