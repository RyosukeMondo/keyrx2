{
  "id": "snapshot_1766427473372_95vg0hl3v",
  "approvalId": "approval_1766427473368_ydxcsz1v7",
  "approvalTitle": "Design for Virtual E2E Testing",
  "version": 1,
  "timestamp": "2025-12-22T18:17:53.372Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Virtual E2E Testing framework enables fully automated end-to-end testing of keyrx without physical hardware. It leverages Linux's uinput subsystem to create virtual keyboards for both input injection and output capture, exercising the complete kernel evdev/uinput path that the production daemon uses.\n\nThe architecture creates a closed loop:\n1. **VirtualKeyboard** (uinput) → generates events the daemon can read via evdev\n2. **keyrx_daemon** → processes events through the real platform layer\n3. **OutputCapture** (evdev) → reads events from daemon's uinput output\n\nThis design validates the exact same code path used in production, unlike mock-based tests which bypass the kernel interface.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nThis implementation follows keyrx architectural patterns:\n\n- **Trait-Based Abstraction**: VirtualKeyboard and OutputCapture can be extended for other platforms\n- **Zero-Copy Where Possible**: Direct evdev event reading without intermediate buffers\n- **Structured Logging**: JSON format for test diagnostics\n- **Fail-Safe Defaults**: Cleanup on panic, timeout, or normal exit\n- **Explicit Error Handling**: All I/O operations return Result<T, E>\n\n### Project Structure (structure.md)\n\nFile organization follows keyrx workspace conventions:\n\n```\nkeyrx_daemon/\n├── src/\n│   ├── test_utils/              # NEW: Virtual device test utilities\n│   │   ├── mod.rs               # Module exports\n│   │   ├── virtual_keyboard.rs  # VirtualKeyboard implementation\n│   │   └── output_capture.rs    # OutputCapture implementation\n│   └── platform/\n│       └── linux/               # Existing Linux platform code\n├── tests/\n│   ├── e2e_harness.rs           # NEW: E2E test harness\n│   ├── virtual_e2e_tests.rs     # NEW: Automated E2E test cases\n│   └── e2e_tests.rs             # Existing hardware-based tests\n└── Cargo.toml                   # Add dev-dependencies\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **keyrx_daemon::platform::linux::UinputOutput**: Reference for uinput device creation\n  - VirtualKeyboard uses same uinput patterns for event injection\n  - Keycode mapping functions (keycode_to_evdev) reused\n\n- **keyrx_daemon::platform::linux::EvdevInput**: Reference for evdev reading\n  - OutputCapture uses same evdev patterns for event capture\n  - Keycode conversion (evdev_to_keycode) reused\n\n- **keyrx_daemon::platform::linux::keycode_map**: Keycode conversion functions\n  - `keycode_to_evdev()` for VirtualKeyboard injection\n  - `evdev_to_keycode()` for OutputCapture reading\n\n- **keyrx_daemon::daemon::Daemon**: Daemon lifecycle management\n  - Used by E2EHarness to start/stop daemon process\n  - Signal handling (SIGTERM) for graceful shutdown\n\n- **keyrx_core::config**: Configuration types\n  - DeviceConfig for pattern matching\n  - ConfigRoot for test configurations\n\n### Integration Points\n\n- **uinput crate**: Virtual keyboard creation (same as UinputOutput)\n  - Device registration with EV_KEY capabilities\n  - Event injection with SYN_REPORT\n\n- **evdev crate**: Event capture from daemon output\n  - Device enumeration by name\n  - Non-blocking event reading\n\n- **std::process::Command**: Daemon process management\n  - Spawn daemon as subprocess\n  - Capture stdout/stderr for diagnostics\n  - Send signals for shutdown\n\n- **tempfile crate**: Temporary configuration files\n  - Create .krx files for test scenarios\n  - Automatic cleanup on test completion\n\n## Architecture\n\nThe E2E test framework creates a virtual device loop that exercises the full daemon pipeline:\n\n```mermaid\ngraph TD\n    subgraph TestHarness[\"E2E Test Harness\"]\n        TH[Test Code]\n        VK[VirtualKeyboard<br/>uinput device]\n        OC[OutputCapture<br/>evdev reader]\n    end\n\n    subgraph Kernel[\"Linux Kernel\"]\n        UI1[/dev/uinput<br/>VirtualKeyboard]\n        EV1[/dev/input/eventX<br/>Test Input]\n        UI2[/dev/uinput<br/>Daemon Output]\n        EV2[/dev/input/eventY<br/>keyrx Virtual Keyboard]\n    end\n\n    subgraph Daemon[\"keyrx_daemon Process\"]\n        EVD[EvdevInput<br/>grab eventX]\n        PROC[EventProcessor<br/>KeyLookup + State]\n        UIO[UinputOutput<br/>inject to eventY]\n    end\n\n    TH -->|1. inject events| VK\n    VK -->|2. write| UI1\n    UI1 -->|3. creates| EV1\n    EV1 -->|4. grab & read| EVD\n    EVD -->|5. KeyEvent| PROC\n    PROC -->|6. remap| UIO\n    UIO -->|7. write| UI2\n    UI2 -->|8. creates| EV2\n    EV2 -->|9. read| OC\n    OC -->|10. verify| TH\n\n    style TH fill:#e1f5ff\n    style VK fill:#fff3cd\n    style OC fill:#d4edda\n    style EVD fill:#fff3cd\n    style PROC fill:#f8d7da\n    style UIO fill:#d4edda\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**:\n  - `virtual_keyboard.rs`: uinput device creation and event injection only\n  - `output_capture.rs`: evdev device discovery and event reading only\n  - `e2e_harness.rs`: Test orchestration only (no device I/O details)\n  - `virtual_e2e_tests.rs`: Test cases only (use harness API)\n\n- **Component Isolation**:\n  - VirtualKeyboard has no knowledge of OutputCapture\n  - OutputCapture has no knowledge of VirtualKeyboard\n  - E2EHarness coordinates both without exposing internals\n  - Test cases use harness API exclusively\n\n- **Service Layer Separation**:\n  - Device layer: VirtualKeyboard, OutputCapture (low-level I/O)\n  - Orchestration layer: E2EHarness (lifecycle, coordination)\n  - Test layer: Test functions (assertions, scenarios)\n\n## Components and Interfaces\n\n### Component 1: VirtualKeyboard (keyrx_daemon/src/test_utils/virtual_keyboard.rs)\n\n**Purpose:** Create virtual input device and inject key events for testing\n\n**Interfaces:**\n```rust\npub struct VirtualKeyboard {\n    device: uinput::Device,\n    name: String,\n    path: PathBuf,\n}\n\nimpl VirtualKeyboard {\n    /// Create a virtual keyboard with the given name\n    /// Name is used for device identification in tests\n    pub fn create(name: &str) -> Result<Self, VirtualDeviceError>;\n\n    /// Inject a key event into the virtual device\n    /// Writes EV_KEY + EV_SYN to uinput\n    pub fn inject(&mut self, event: KeyEvent) -> Result<(), VirtualDeviceError>;\n\n    /// Inject multiple events with optional delay between them\n    pub fn inject_sequence(&mut self, events: &[KeyEvent], delay: Option<Duration>)\n        -> Result<(), VirtualDeviceError>;\n\n    /// Get the device path (e.g., /dev/input/event5)\n    pub fn path(&self) -> &Path;\n\n    /// Get the device name\n    pub fn name(&self) -> &str;\n}\n\nimpl Drop for VirtualKeyboard {\n    /// Destroy the virtual device on drop\n    fn drop(&mut self);\n}\n```\n\n**Dependencies:**\n- `uinput` crate for virtual device creation\n- `keyrx_core::runtime::event::KeyEvent` for event type\n- `keyrx_daemon::platform::linux::keycode_map::keycode_to_evdev` for key conversion\n\n**Reuses:**\n- UinputOutput patterns for device creation\n- keycode_to_evdev for KeyCode → evdev conversion\n\n**Design Decisions:**\n- **Unique device names**: Include timestamp/random suffix for parallel tests\n- **Full key capability**: Register all EV_KEY codes like UinputOutput\n- **Sync after each event**: Ensure events are processed immediately\n- **Drop cleanup**: Destroy device even on panic\n\n### Component 2: OutputCapture (keyrx_daemon/src/test_utils/output_capture.rs)\n\n**Purpose:** Find and read events from daemon's virtual keyboard output\n\n**Interfaces:**\n```rust\npub struct OutputCapture {\n    device: evdev::Device,\n    name: String,\n}\n\nimpl OutputCapture {\n    /// Find a device by name with timeout\n    /// Polls /dev/input/event* until device appears or timeout\n    pub fn find_by_name(name: &str, timeout: Duration) -> Result<Self, VirtualDeviceError>;\n\n    /// Read next event with timeout\n    /// Returns None if timeout expires\n    pub fn next_event(&mut self, timeout: Duration) -> Result<Option<KeyEvent>, VirtualDeviceError>;\n\n    /// Collect all events within timeout period\n    /// Stops collecting when no events for `timeout` duration\n    pub fn collect_events(&mut self, timeout: Duration) -> Vec<KeyEvent>;\n\n    /// Drain any pending events (clear buffer)\n    pub fn drain(&mut self);\n\n    /// Assert that captured events match expected sequence\n    /// Panics with detailed diff on mismatch\n    pub fn assert_events(captured: &[KeyEvent], expected: &[KeyEvent]);\n}\n```\n\n**Dependencies:**\n- `evdev` crate for device reading\n- `keyrx_core::runtime::event::KeyEvent` for event type\n- `keyrx_daemon::platform::linux::keycode_map::evdev_to_keycode` for key conversion\n\n**Reuses:**\n- EvdevInput patterns for device reading\n- evdev_to_keycode for evdev → KeyCode conversion\n- Device enumeration from device_manager\n\n**Design Decisions:**\n- **Poll-based discovery**: Device may not exist immediately after daemon starts\n- **Non-blocking reads**: Use timeout to avoid hanging tests\n- **Filter key events only**: Ignore EV_SYN, EV_MSC, etc.\n- **Detailed assertion**: Show expected vs actual on failure\n\n### Component 3: E2EHarness (keyrx_daemon/tests/e2e_harness.rs)\n\n**Purpose:** Orchestrate complete E2E test lifecycle\n\n**Interfaces:**\n```rust\npub struct E2EHarness {\n    virtual_input: VirtualKeyboard,\n    daemon_process: Child,\n    output_capture: OutputCapture,\n    config_path: PathBuf,\n}\n\npub struct E2EConfig {\n    pub mappings: Vec<KeyMapping>,\n    pub device_pattern: String,\n}\n\nimpl E2EHarness {\n    /// Setup complete E2E test environment\n    /// 1. Create VirtualKeyboard\n    /// 2. Write config file matching virtual keyboard\n    /// 3. Start daemon process\n    /// 4. Wait for daemon to grab device\n    /// 5. Find and open output device\n    pub fn setup(config: E2EConfig) -> Result<Self, E2EError>;\n\n    /// Inject events into virtual keyboard\n    pub fn inject(&mut self, events: &[KeyEvent]) -> Result<(), E2EError>;\n\n    /// Capture output events with timeout\n    pub fn capture(&mut self, timeout: Duration) -> Vec<KeyEvent>;\n\n    /// Inject and immediately capture, convenience method\n    pub fn inject_and_capture(&mut self, events: &[KeyEvent], timeout: Duration)\n        -> Result<Vec<KeyEvent>, E2EError>;\n\n    /// Verify captured events match expected\n    pub fn verify(&self, captured: &[KeyEvent], expected: &[KeyEvent]);\n\n    /// Graceful teardown\n    /// 1. Send SIGTERM to daemon\n    /// 2. Wait for daemon to exit\n    /// 3. Destroy virtual keyboard\n    /// 4. Remove config file\n    pub fn teardown(self) -> Result<(), E2EError>;\n}\n\nimpl Drop for E2EHarness {\n    /// Ensure cleanup even on panic\n    fn drop(&mut self);\n}\n```\n\n**Dependencies:**\n- `VirtualKeyboard` for input injection\n- `OutputCapture` for output verification\n- `std::process::Command` for daemon subprocess\n- `tempfile` for temporary config files\n- `keyrx_compiler` for config serialization\n\n**Reuses:**\n- serialize_config from keyrx_compiler for .krx generation\n- Signal handling patterns from daemon\n\n**Design Decisions:**\n- **Subprocess daemon**: Isolates test from daemon state\n- **Automatic cleanup**: Drop impl ensures no orphaned resources\n- **Timeout-based verification**: Handle async nature of event propagation\n- **Config generation**: Create .krx on-the-fly for test scenarios\n\n### Component 4: VirtualDeviceError (keyrx_daemon/src/test_utils/mod.rs)\n\n**Purpose:** Error type for virtual device operations\n\n**Interfaces:**\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum VirtualDeviceError {\n    #[error(\"Permission denied: {0}. Try: sudo chmod 666 /dev/uinput\")]\n    PermissionDenied(String),\n\n    #[error(\"Device not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"Timeout waiting for device: {0}\")]\n    Timeout(String),\n\n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Device creation failed: {0}\")]\n    CreationFailed(String),\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum E2EError {\n    #[error(\"Virtual device error: {0}\")]\n    VirtualDevice(#[from] VirtualDeviceError),\n\n    #[error(\"Daemon failed to start: {0}\")]\n    DaemonStart(String),\n\n    #[error(\"Daemon exited unexpectedly: {0}\")]\n    DaemonCrash(String),\n\n    #[error(\"Config error: {0}\")]\n    Config(String),\n\n    #[error(\"Verification failed: expected {expected:?}, got {actual:?}\")]\n    VerificationFailed {\n        expected: Vec<KeyEvent>,\n        actual: Vec<KeyEvent>,\n    },\n}\n```\n\n## Data Models\n\n### E2EConfig\n```rust\n/// Configuration for an E2E test scenario\npub struct E2EConfig {\n    /// Key mappings to test\n    pub mappings: Vec<KeyMapping>,\n    /// Device pattern (typically matches virtual keyboard name)\n    pub device_pattern: String,\n}\n\nimpl E2EConfig {\n    /// Create config for simple remap test\n    pub fn simple_remap(from: KeyCode, to: KeyCode) -> Self;\n\n    /// Create config for modifier test\n    pub fn modifier(trigger: KeyCode, modifier_id: u8) -> Self;\n\n    /// Create config for conditional test\n    pub fn conditional(\n        modifier_trigger: KeyCode,\n        modifier_id: u8,\n        when_active: Vec<(KeyCode, KeyCode)>,\n    ) -> Self;\n\n    /// Convert to ConfigRoot for serialization\n    pub fn to_config_root(&self, device_name: &str) -> ConfigRoot;\n}\n```\n\n### TestEvent Helper\n```rust\n/// Helper for creating test event sequences\npub struct TestEvents;\n\nimpl TestEvents {\n    /// Create press event\n    pub fn press(key: KeyCode) -> KeyEvent {\n        KeyEvent::Press(key)\n    }\n\n    /// Create release event\n    pub fn release(key: KeyCode) -> KeyEvent {\n        KeyEvent::Release(key)\n    }\n\n    /// Create press+release sequence (tap)\n    pub fn tap(key: KeyCode) -> Vec<KeyEvent> {\n        vec![KeyEvent::Press(key), KeyEvent::Release(key)]\n    }\n\n    /// Create sequence of taps\n    pub fn type_keys(keys: &[KeyCode]) -> Vec<KeyEvent> {\n        keys.iter().flat_map(|k| Self::tap(*k)).collect()\n    }\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. /dev/uinput Not Accessible\n**Scenario:** Permission denied when creating VirtualKeyboard\n\n**Handling:**\n```rust\nmatch VirtualKeyboard::create(\"test-keyboard\") {\n    Ok(vk) => vk,\n    Err(VirtualDeviceError::PermissionDenied(msg)) => {\n        panic!(\n            \"Cannot create virtual keyboard: {}\\n\\n\\\n             To fix in CI, add these steps:\\n\\\n             - run: sudo modprobe uinput\\n\\\n             - run: sudo chmod 666 /dev/uinput\\n\\n\\\n             To fix locally:\\n\\\n             - sudo usermod -aG input,uinput $USER\\n\\\n             - Log out and back in\",\n            msg\n        );\n    }\n    Err(e) => panic!(\"Virtual keyboard creation failed: {}\", e),\n}\n```\n\n**User Impact:** Clear CI setup instructions\n\n#### 2. Daemon Fails to Start\n**Scenario:** Daemon process exits immediately\n\n**Handling:**\n```rust\nlet mut child = Command::new(daemon_path)\n    .args([\"run\", \"--config\", config_path])\n    .stderr(Stdio::piped())\n    .spawn()?;\n\n// Wait briefly and check if still running\nthread::sleep(Duration::from_millis(500));\nmatch child.try_wait() {\n    Ok(Some(status)) => {\n        let stderr = read_stderr(&mut child);\n        return Err(E2EError::DaemonStart(format!(\n            \"Daemon exited with {}: {}\",\n            status, stderr\n        )));\n    }\n    Ok(None) => { /* Still running, good */ }\n    Err(e) => return Err(E2EError::DaemonStart(e.to_string())),\n}\n```\n\n**User Impact:** Daemon stderr captured for debugging\n\n#### 3. Output Device Not Found\n**Scenario:** Daemon's virtual keyboard doesn't appear\n\n**Handling:**\n```rust\nmatch OutputCapture::find_by_name(\"keyrx Virtual Keyboard\", Duration::from_secs(5)) {\n    Ok(oc) => oc,\n    Err(VirtualDeviceError::Timeout(msg)) => {\n        // Check if daemon is still running\n        if let Ok(Some(status)) = daemon.try_wait() {\n            let stderr = read_stderr(&mut daemon);\n            panic!(\n                \"Daemon exited before creating output device.\\n\\\n                 Exit status: {}\\n\\\n                 Stderr: {}\",\n                status, stderr\n            );\n        }\n        panic!(\n            \"Timeout waiting for daemon output device: {}\\n\\\n             Available devices: {:?}\",\n            msg,\n            list_input_devices()\n        );\n    }\n    Err(e) => panic!(\"Output capture failed: {}\", e),\n}\n```\n\n**User Impact:** Lists available devices for debugging\n\n#### 4. Event Verification Failure\n**Scenario:** Captured events don't match expected\n\n**Handling:**\n```rust\npub fn assert_events(captured: &[KeyEvent], expected: &[KeyEvent]) {\n    if captured != expected {\n        let mut diff = String::new();\n        diff.push_str(\"Event verification failed:\\n\\n\");\n        diff.push_str(\"Expected:\\n\");\n        for (i, e) in expected.iter().enumerate() {\n            diff.push_str(&format!(\"  [{}] {:?}\\n\", i, e));\n        }\n        diff.push_str(\"\\nActual:\\n\");\n        for (i, e) in captured.iter().enumerate() {\n            let marker = if i < expected.len() && expected[i] != *e {\n                \" <-- MISMATCH\"\n            } else if i >= expected.len() {\n                \" <-- EXTRA\"\n            } else {\n                \"\"\n            };\n            diff.push_str(&format!(\"  [{}] {:?}{}\\n\", i, e, marker));\n        }\n        if captured.len() < expected.len() {\n            diff.push_str(&format!(\"\\nMissing {} events\\n\", expected.len() - captured.len()));\n        }\n        panic!(\"{}\", diff);\n    }\n}\n```\n\n**User Impact:** Detailed diff showing exactly what failed\n\n## Testing Strategy\n\n### Unit Testing\n\n**Approach:** Test VirtualKeyboard and OutputCapture in isolation\n\n**Key Components to Test:**\n\n1. **VirtualKeyboard Creation**\n   - Test device appears in /dev/input/ after creation\n   - Test device has correct name\n   - Test device is destroyed on drop\n   - Test error on permission denied\n\n2. **VirtualKeyboard Injection**\n   - Test press event generates correct evdev event\n   - Test release event generates correct evdev event\n   - Test sequence injection with delays\n   - Test all KeyCode values map correctly\n\n3. **OutputCapture Discovery**\n   - Test finds device by exact name\n   - Test timeout when device doesn't exist\n   - Test finds newly created device within timeout\n\n4. **OutputCapture Reading**\n   - Test reads press events correctly\n   - Test reads release events correctly\n   - Test timeout returns None when no events\n   - Test collect_events gathers multiple events\n\n5. **E2EConfig Helpers**\n   - Test simple_remap creates correct config\n   - Test modifier creates correct config\n   - Test conditional creates correct config\n   - Test to_config_root generates valid structure\n\n### Integration Testing\n\n**Approach:** Test components working together without daemon\n\n**Key Flows to Test:**\n\n1. **Virtual Device Round-Trip**\n   ```rust\n   #[test]\n   fn test_virtual_keyboard_readable() {\n       let vk = VirtualKeyboard::create(\"test-vk\").unwrap();\n       let reader = evdev::Device::open(vk.path()).unwrap();\n\n       vk.inject(KeyEvent::Press(KeyCode::A)).unwrap();\n\n       // Read event from device\n       let event = reader.next_event().unwrap();\n       assert_eq!(event.code(), evdev::Key::KEY_A.code());\n       assert_eq!(event.value(), 1);\n   }\n   ```\n\n2. **Config Generation and Serialization**\n   ```rust\n   #[test]\n   fn test_e2e_config_serialization() {\n       let config = E2EConfig::simple_remap(KeyCode::A, KeyCode::B);\n       let root = config.to_config_root(\"test-device\");\n\n       let bytes = serialize_config(&root).unwrap();\n       let loaded = deserialize_config(&bytes).unwrap();\n\n       assert_eq!(root, loaded);\n   }\n   ```\n\n### End-to-End Testing\n\n**Approach:** Full pipeline tests with daemon subprocess\n\n**User Scenarios:**\n\n1. **Simple Remap (A→B)**\n   ```rust\n   #[test]\n   fn e2e_simple_remap() {\n       let harness = E2EHarness::setup(E2EConfig::simple_remap(KeyCode::A, KeyCode::B)).unwrap();\n\n       let output = harness.inject_and_capture(\n           &[KeyEvent::Press(KeyCode::A), KeyEvent::Release(KeyCode::A)],\n           Duration::from_millis(100),\n       ).unwrap();\n\n       harness.verify(&output, &[\n           KeyEvent::Press(KeyCode::B),\n           KeyEvent::Release(KeyCode::B),\n       ]);\n   }\n   ```\n\n2. **Modifier State**\n   ```rust\n   #[test]\n   fn e2e_modifier_state() {\n       let harness = E2EHarness::setup(E2EConfig::conditional(\n           KeyCode::CapsLock, 0x00,\n           vec![(KeyCode::H, KeyCode::Left)],\n       )).unwrap();\n\n       // Without modifier: H passes through\n       let output1 = harness.inject_and_capture(\n           &TestEvents::tap(KeyCode::H),\n           Duration::from_millis(100),\n       ).unwrap();\n       harness.verify(&output1, &TestEvents::tap(KeyCode::H));\n\n       // With modifier: H becomes Left\n       harness.inject(&[KeyEvent::Press(KeyCode::CapsLock)]).unwrap();\n       let output2 = harness.inject_and_capture(\n           &TestEvents::tap(KeyCode::H),\n           Duration::from_millis(100),\n       ).unwrap();\n       harness.verify(&output2, &TestEvents::tap(KeyCode::Left));\n   }\n   ```\n\n3. **Modified Output (Shift+Key)**\n   ```rust\n   #[test]\n   fn e2e_modified_output() {\n       let config = E2EConfig {\n           mappings: vec![KeyMapping::modified_output(\n               KeyCode::Num2, KeyCode::Num2, true, false, false, false\n           )],\n           device_pattern: \"*\".to_string(),\n       };\n       let harness = E2EHarness::setup(config).unwrap();\n\n       let output = harness.inject_and_capture(\n           &TestEvents::tap(KeyCode::Num2),\n           Duration::from_millis(100),\n       ).unwrap();\n\n       // Should output Shift+2 sequence\n       harness.verify(&output, &[\n           KeyEvent::Press(KeyCode::LShift),\n           KeyEvent::Press(KeyCode::Num2),\n           KeyEvent::Release(KeyCode::Num2),\n           KeyEvent::Release(KeyCode::LShift),\n       ]);\n   }\n   ```\n\n### Performance Testing\n\n**Benchmarks:**\n\n1. **Event Round-Trip Latency**\n   - Measure inject → capture time\n   - Target: <100ms for single event\n\n2. **Harness Setup Time**\n   - Measure E2EHarness::setup duration\n   - Target: <2 seconds\n\n3. **Parallel Test Isolation**\n   - Run multiple E2E tests concurrently\n   - Verify no cross-contamination\n",
  "fileStats": {
    "size": 21992,
    "lines": 718,
    "lastModified": "2025-12-22T18:14:59.928Z"
  },
  "comments": []
}