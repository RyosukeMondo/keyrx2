{
  "id": "snapshot_1766594845858_osvp4aspn",
  "approvalId": "approval_1766594845851_w82jlwnx8",
  "approvalTitle": "Windows Device Discrimination Design",
  "version": 1,
  "timestamp": "2025-12-24T16:47:25.858Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design replaces Windows Low-Level Keyboard Hooks (`WH_KEYBOARD_LL`) with Raw Input API (`RAWINPUT`) to achieve per-device event discrimination. This enables \"keyboard-aware remapping\" on Windows, unlocking the ability to use spare keyboards as macro pads (Stream Deck alternative).\n\n**Key Changes:**\n1. **Delete `hook.rs`**: Remove `SetWindowsHookExW(WH_KEYBOARD_LL, ...)` implementation\n2. **Add `rawinput.rs`**: Implement `RegisterRawInputDevices` with `WM_INPUT` message loop\n3. **Add `device_map.rs`**: Map `HANDLE hDevice` → serial number via `GetRawInputDeviceInfo`\n4. **Preserve `tray.rs`**: System tray unchanged (still uses `tray-icon` crate)\n\n**Performance Gain:** Raw Input is **lower latency** than LL Hooks (kernel-level vs user-level callback), so this refactor improves performance while adding device discrimination.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Windows Platform Integration:**\n> \"Windows: Low-Level Hooks (WH_KEYBOARD_LL) + Raw Input for device identification\"\n\nThis design **corrects** the tech doc: we move fully to Raw Input (not hybrid). Update tech.md to reflect:\n> \"Windows: Raw Input API (RAWINPUT) for low-latency device-aware event capture\"\n\n**Cross-Platform Parity:**\n> \"Linux: evdev/uinput with EVIOCGRAB for kernel-level interception\"\n\nRaw Input achieves similar kernel-level performance to Linux evdev (both avoid user-mode hook overhead).\n\n### Project Structure (structure.md)\n\n**Windows Platform Structure:**\n```\nkeyrx_daemon/src/platform/windows/\n├── mod.rs              # WindowsPlatform struct\n├── rawinput.rs         # NEW: RegisterRawInputDevices, WM_INPUT handling\n├── device_map.rs       # NEW: Device handle → serial number mapping\n├── input.rs            # MODIFIED: Use rawinput.rs instead of hook.rs\n├── output.rs           # UNCHANGED: SendInput injection\n├── tray.rs             # UNCHANGED: System tray (implements SystemTray trait)\n├── keycode.rs          # UNCHANGED: VK code mapping\n├── inject.rs           # UNCHANGED: Event injection\n└── hook.rs             # DELETE: WH_KEYBOARD_LL removed\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n1. **System Tray (`windows/tray.rs`)**\n   - **Reuse:** 100% unchanged (TrayIconController continues working)\n   - **Note:** If Spec 1 refactors this to SystemTray trait, this spec is compatible\n\n2. **Keycode Mapping (`windows/keycode.rs`)**\n   - **Reuse:** VK code → KeyCode translation unchanged\n   - **Note:** Raw Input uses same VK codes as LL Hooks\n\n3. **Event Injection (`windows/inject.rs`, `output.rs`)**\n   - **Reuse:** `SendInput` API unchanged (output side unaffected)\n\n4. **KeyEvent Structure (from Spec 1)**\n   - **Reuse:** `KeyEvent::with_device_id()` method (assumes Spec 1 is implemented first)\n   - **Dependency:** This spec depends on Spec 1 task #1 (device_id field added)\n\n### Components to Remove\n\n1. **Low-Level Hook (`windows/hook.rs`)**\n   - **Delete:** Entire file (122 lines removed)\n   - **Reason:** Replaced by `rawinput.rs` (Raw Input is superior: lower latency + device info)\n\n### Integration Points\n\n1. **Window Message Loop**\n   - **Current:** `WindowsPlatform::process_events()` runs message loop for tray events\n   - **Integration:** Add `WM_INPUT` handler to same message loop (via hidden window)\n\n2. **Input Event Channel**\n   - **Current:** `hook.rs` uses `crossbeam_channel::Sender<KeyEvent>` to send events\n   - **Integration:** `rawinput.rs` uses same channel pattern (drop-in replacement)\n\n3. **Daemon Lifecycle**\n   - **Current:** Hook installed in `WindowsKeyboardInput::grab()`\n   - **Integration:** Raw input registered in `grab()`, unregistered in `release()`\n\n## Architecture\n\n### Modular Design Principles\n\n**File Responsibility Breakdown:**\n- `rawinput.rs`: Raw input registration, window creation, WM_INPUT message processing (~200 lines)\n- `device_map.rs`: Device enumeration, handle → serial mapping, caching (~150 lines)\n- `input.rs`: WindowsKeyboardInput implementation using rawinput.rs (~80 lines, simplified from current)\n- `mod.rs`: WindowsPlatform struct, unchanged interface (~50 lines, same as current)\n\n**Separation of Concerns:**\n- **Device Discovery:** `device_map.rs` owns `GetRawInputDeviceList`, `GetRawInputDeviceInfo`\n- **Event Capture:** `rawinput.rs` owns `RegisterRawInputDevices`, `GetRawInputData`, window proc\n- **Event Translation:** `input.rs` bridges platform layer to `InputDevice` trait\n- **Platform Integration:** `mod.rs` exposes cross-platform `WindowsPlatform` API\n\n### System Architecture Diagram\n\n```mermaid\ngraph TD\n    subgraph Windows Kernel\n        A[Hardware Keyboards] -->|USB HID| B[HID Driver Stack]\n        B -->|Raw Input| C[Win32 Subsystem]\n    end\n\n    subgraph User Mode - keyrx_daemon\n        C -->|WM_INPUT messages| D[Hidden Window]\n        D -->|GetRawInputData| E[RawInputManager<br/>rawinput.rs]\n\n        E -->|HANDLE hDevice| F[DeviceMap<br/>device_map.rs]\n        F -->|GetRawInputDeviceInfo| G[Device Serial Cache]\n\n        E -->|KeyEvent| H[crossbeam_channel]\n        F -->|device_id: String| H\n\n        H -->|KeyEvent + device_id| I[WindowsKeyboardInput<br/>input.rs]\n        I -->|InputDevice trait| J[Daemon Main Loop]\n\n        K[System Tray<br/>tray.rs] -->|TrayControlEvent| J\n\n        J -->|Remapping| L[keyrx_core]\n        L -->|Remapped Events| M[SendInput API<br/>output.rs]\n        M -->|Inject| C\n    end\n\n    style E fill:#ffe6e6\n    style F fill:#ffe6e6\n    style A fill:#e1f5e1\n```\n\n### Raw Input vs LL Hooks Comparison\n\n| Aspect | Low-Level Hooks (WH_KEYBOARD_LL) | Raw Input (RAWINPUT) |\n|--------|----------------------------------|----------------------|\n| **Device Info** | ❌ No device handle | ✅ `RAWINPUT.header.hDevice` |\n| **Latency** | ~1-2ms (user mode callback) | ~0.5ms (kernel → message queue) |\n| **Timeout Risk** | ⚠️ Unhooked if >300ms processing | ✅ No timeout (messages buffered) |\n| **Admin Required** | ❌ No | ⚠️ Sometimes (RIDEV_INPUTSINK) |\n| **API Stability** | ✅ Stable since Win2000 | ✅ Stable since WinXP SP1 |\n| **Event Suppression** | ✅ Return 1 to block | ✅ RIDEV_NOLEGACY flag |\n\n**Design Choice:** Raw Input is objectively superior for keyrx use case (device discrimination + lower latency).\n\n## Components and Interfaces\n\n### Component 1: RawInputManager\n\n**Purpose:** Register raw input devices, create hidden window, process WM_INPUT messages\n\n**Interfaces:**\n```rust\n// keyrx_daemon/src/platform/windows/rawinput.rs\n\npub struct RawInputManager {\n    hwnd: HWND,                          // Hidden window handle\n    event_sender: Sender<(KeyEvent, Option<String>)>, // Send (event, device_id)\n    device_map: Arc<Mutex<DeviceMap>>,   // Shared device handle cache\n}\n\nimpl RawInputManager {\n    /// Creates hidden window and registers raw input\n    pub fn new(sender: Sender<(KeyEvent, Option<String>)>) -> Result<Self, String>;\n\n    /// Unregisters raw input (called on shutdown)\n    pub fn shutdown(&mut self) -> Result<(), String>;\n\n    /// Runs message loop (blocking, call in dedicated thread or main loop)\n    pub fn run_message_loop(&self) -> Result<(), String>;\n}\n\n// Internal: Window procedure for WM_INPUT\nunsafe extern \"system\" fn window_proc(\n    hwnd: HWND,\n    msg: u32,\n    w_param: WPARAM,\n    l_param: LPARAM,\n) -> LRESULT;\n```\n\n**Dependencies:**\n- `windows-sys::Win32::UI::WindowsAndMessaging::*` (window creation, message loop)\n- `windows-sys::Win32::UI::Input::KeyboardAndMouse::*` (RegisterRawInputDevices, GetRawInputData)\n- `crossbeam_channel::Sender` (event output)\n\n**Reuses:**\n- Event channel pattern from existing `hook.rs`\n- Keycode translation from `keycode::vk_to_keycode()`\n\n### Component 2: DeviceMap\n\n**Purpose:** Map device handles to serial numbers, cache results for O(1) lookup\n\n**Interfaces:**\n```rust\n// keyrx_daemon/src/platform/windows/device_map.rs\n\npub struct DeviceInfo {\n    pub handle: HANDLE,\n    pub device_id: String,        // Serial or fallback path\n    pub name: String,             // Human-readable name\n    pub path: String,             // Full device path\n}\n\npub struct DeviceMap {\n    cache: HashMap<isize, DeviceInfo>, // Key: hDevice as isize\n}\n\nimpl DeviceMap {\n    /// Creates empty device map\n    pub fn new() -> Self;\n\n    /// Enumerates all keyboards via GetRawInputDeviceList\n    pub fn enumerate_devices() -> Result<Vec<DeviceInfo>, String>;\n\n    /// Gets device ID for handle (caches on first lookup)\n    pub fn get_device_id(&mut self, hdevice: HANDLE) -> Option<String>;\n\n    /// Refreshes device list (for hot-plug support)\n    pub fn refresh(&mut self) -> Result<(), String>;\n}\n\n// Helper: Parse device path to extract serial\nfn extract_serial_from_path(device_path: &str) -> Option<String>;\n```\n\n**Dependencies:**\n- `windows-sys::Win32::Devices::HumanInterfaceDevice::*` (GetRawInputDeviceList, GetRawInputDeviceInfo)\n- `std::collections::HashMap` (device cache)\n\n**Reuses:** None (new component)\n\n### Component 3: WindowsKeyboardInput (Refactored)\n\n**Purpose:** Implement `InputDevice` trait using `RawInputManager`\n\n**Interfaces:**\n```rust\n// keyrx_daemon/src/platform/windows/input.rs\n\npub struct WindowsKeyboardInput {\n    rawinput_manager: Option<RawInputManager>,\n    event_receiver: Receiver<(KeyEvent, Option<String>)>,\n    grabbed: bool,\n}\n\nimpl InputDevice for WindowsKeyboardInput {\n    fn next_event(&mut self) -> Result<KeyEvent, DeviceError> {\n        // Receive from channel, attach device_id to KeyEvent\n        let (mut event, device_id) = self.event_receiver.recv()\n            .map_err(|_| DeviceError::EndOfStream)?;\n\n        if let Some(id) = device_id {\n            event = event.with_device_id(id);\n        }\n\n        Ok(event)\n    }\n\n    fn grab(&mut self) -> Result<(), DeviceError> {\n        // Create RawInputManager (registers raw input)\n        let (tx, rx) = crossbeam_channel::unbounded();\n        self.rawinput_manager = Some(RawInputManager::new(tx)?);\n        self.event_receiver = rx;\n        self.grabbed = true;\n        Ok(())\n    }\n\n    fn release(&mut self) -> Result<(), DeviceError> {\n        // Shutdown RawInputManager (unregisters raw input)\n        if let Some(mut mgr) = self.rawinput_manager.take() {\n            mgr.shutdown()?;\n        }\n        self.grabbed = false;\n        Ok(())\n    }\n}\n```\n\n**Dependencies:**\n- `RawInputManager` (from rawinput.rs)\n- `KeyEvent::with_device_id()` (from Spec 1)\n\n**Reuses:**\n- `InputDevice` trait interface (unchanged)\n- Event receiver pattern\n\n## Data Models\n\n### DeviceInfo Model\n```rust\npub struct DeviceInfo {\n    /// Device handle (opaque Windows HANDLE)\n    pub handle: HANDLE,\n\n    /// Unique device ID (serial or path-based)\n    pub device_id: String,\n\n    /// Human-readable device name\n    pub name: String,\n\n    /// Full device path from GetRawInputDeviceInfo\n    /// Example: \"\\\\?\\HID#VID_046D&PID_C52B#7&2a8c8e9d&0&0000#{884b96c3-56ef-11d1-bc8c-00a0c91405dd}\"\n    pub path: String,\n}\n```\n\n### Device Path Format\n```\n\\\\?\\HID#VID_XXXX&PID_YYYY#SerialNumber#{GUID}\n       └── Vendor/Product ──┘ └─ Extract ─┘\n```\n\n**Parsing Strategy:**\n1. Split by `#` delimiter\n2. If segment 2 exists and looks like serial (alphanumeric, >4 chars), use it\n3. Otherwise, use full path as fallback ID (stable, but verbose)\n\n### WM_INPUT Message Flow\n```\nKeyboard Press\n    ↓\nWindows Kernel (HID Driver)\n    ↓\nPostMessage(hwnd, WM_INPUT, ...)\n    ↓\nwindow_proc() receives WM_INPUT\n    ↓\nGetRawInputData(lParam) → RAWINPUT struct\n    ↓\nRAWINPUT.header.hDevice (HANDLE)\nRAWINPUT.data.keyboard.VKey (Virtual Key Code)\nRAWINPUT.data.keyboard.Flags (up/down)\n    ↓\nDeviceMap.get_device_id(hDevice) → device_id\n    ↓\nKeyEvent::press(keycode).with_device_id(device_id)\n    ↓\nSend via crossbeam_channel\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **RegisterRawInputDevices Failure (Access Denied)**\n   - **Handling:** Return error from `grab()`, log: \"Failed to register raw input. Try running as Administrator.\"\n   - **User Impact:** Daemon won't start, clear error message guides user\n   - **Code:**\n     ```rust\n     if RegisterRawInputDevices(...) == 0 {\n         let err = GetLastError();\n         return Err(format!(\"RegisterRawInputDevices failed (error {}). Try running as Administrator.\", err));\n     }\n     ```\n\n2. **GetRawInputDeviceInfo Failure (Device Disconnected)**\n   - **Handling:** Cache miss → query again → if fails, use handle as fallback ID\n   - **User Impact:** Device shows as \"Unknown-0x12345678\" in UI (degraded but functional)\n   - **Code:**\n     ```rust\n     match get_device_info(hdevice) {\n         Ok(info) => info.device_id,\n         Err(_) => format!(\"Unknown-{:p}\", hdevice as *const _),\n     }\n     ```\n\n3. **WM_INPUT Processing Error (Malformed Data)**\n   - **Handling:** Log warning, skip event, continue processing\n   - **User Impact:** Single event dropped (unnoticeable in normal use)\n   - **Code:**\n     ```rust\n     let result = GetRawInputData(lParam, ...);\n     if result == u32::MAX {\n         log::warn!(\"GetRawInputData failed, skipping event\");\n         return DefWindowProcW(hwnd, msg, w_param, l_param);\n     }\n     ```\n\n4. **Device Hot-Plug (WM_INPUT_DEVICE_CHANGE)**\n   - **Handling:** Refresh device map, log new device added/removed\n   - **User Impact:** New keyboard automatically detected, shown in web UI\n   - **Code:**\n     ```rust\n     WM_INPUT_DEVICE_CHANGE => {\n         if w_param == GIDC_ARRIVAL {\n             device_map.refresh()?;\n             log::info!(\"New device detected\");\n         } else if w_param == GIDC_REMOVAL {\n             device_map.refresh()?;\n             log::info!(\"Device removed\");\n         }\n     }\n     ```\n\n## Testing Strategy\n\n### Unit Testing\n\n**DeviceMap:**\n- Test `extract_serial_from_path()` with real Windows device paths\n- Test cache hit/miss performance (should be O(1) after first lookup)\n- Test fallback ID generation when serial unavailable\n\n**RawInputManager:**\n- Mock `GetRawInputData` to inject test events\n- Verify `window_proc` correctly parses VK codes and flags\n- Test event suppression (RIDEV_NOLEGACY prevents legacy messages)\n\n**WindowsKeyboardInput:**\n- Test `grab()` initializes RawInputManager correctly\n- Test `next_event()` receives events with device_id attached\n- Test `release()` unregisters raw input cleanly\n\n### Integration Testing\n\n**Device Discrimination:**\n- Connect 2 USB keyboards (or use virtual HID devices for CI)\n- Verify each keyboard gets unique device_id\n- Verify events tagged with correct device_id\n- Verify device_id persists across daemon restarts (serial-based, not handle-based)\n\n**Performance Benchmarks:**\n- Measure latency: WM_INPUT received → KeyEvent sent to channel\n- Target: <100μs (compare to baseline LL Hooks latency)\n- Use Windows Performance Recorder (WPR) to verify kernel-level timing\n\n**Hot-Plug:**\n- Start daemon with 1 keyboard\n- Connect second keyboard while running\n- Verify `WM_INPUT_DEVICE_CHANGE` triggers device refresh\n- Verify web UI `/api/devices` updates (requires WebSocket notification)\n\n### End-to-End Testing\n\n**Scenario: USB Numpad as OBS Controller**\n1. User connects USB numpad (has serial \"ABC123\")\n2. Daemon starts, enumerates devices, logs: \"Device: Numeric Keypad (serial: ABC123)\"\n3. User writes Rhai config:\n   ```rhai\n   if event.device_id() == \"ABC123\" {\n       map(NUM_1, F13);  // OBS hotkey\n   }\n   ```\n4. Compile to .krx, reload via tray\n5. Press Num1 on numpad → F13 injected (OBS scene changes)\n6. Press 1 on main keyboard → normal `1` output\n7. Unplug numpad → daemon continues with main keyboard (no crash)\n8. Replug numpad → automatically detected, works again\n\n**Coverage Target:** 85% for new code (rawinput.rs, device_map.rs)\n",
  "fileStats": {
    "size": 15749,
    "lines": 455,
    "lastModified": "2025-12-24T16:47:16.491Z"
  },
  "comments": []
}