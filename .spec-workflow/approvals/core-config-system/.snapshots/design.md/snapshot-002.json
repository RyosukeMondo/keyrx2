{
  "id": "snapshot_1766303888770_n58bxylg4",
  "approvalId": "approval_1766302502793_6u5hja2aa",
  "approvalTitle": "Design for Core Configuration System",
  "version": 2,
  "timestamp": "2025-12-21T07:58:08.770Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Core Configuration System enables users to define keyboard remapping configurations in Rhai scripts and compile them into deterministic, zero-copy binary files (.krx format). The system consists of four major components working together:\n\n1. **Configuration Data Structures** - Rust structs defining the configuration model\n2. **Rhai DSL Evaluator** - Parses and evaluates Rhai scripts\n3. **Binary Serializer** - rkyv-based serialization with hash verification\n4. **CLI Compiler** - User-facing command-line tool\n\nThis design ensures deterministic output (same input → same binary), zero-copy performance (no heap allocation on load), and SSOT verification (SHA256 hashing).\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Rhai Scripting Language**:\n- Rhai version 1.15+ for DSL implementation\n- Custom functions registered for `device()` and `map()` API\n- Compile-time evaluation (no runtime script execution)\n- Resource limits prevent DoS attacks (max operations, max recursion, timeout)\n\n**rkyv Serialization**:\n- rkyv 0.7+ with validation features\n- Zero-copy deserialization for sub-10ms load times\n- Deterministic byte output for hash verification\n- `#[repr(C)]` structs for stable memory layout\n\n**no_std Compatibility**:\n- `keyrx_core/src/config.rs` compiles without std library\n- Uses `core::` and `alloc::` only (WASM-compatible)\n- Enables future use in embedded contexts\n\n### Project Structure (structure.md)\n\n**Module Organization**:\n```\nkeyrx_core/src/\n├── config.rs          # Configuration data structures (no_std)\n└── lib.rs             # Public API exports\n\nkeyrx_compiler/src/\n├── main.rs            # CLI entry point\n├── parser.rs          # Rhai DSL evaluator\n├── serialize.rs       # rkyv serialization\n├── import_resolver.rs # Import system\n└── error.rs           # Error types\n```\n\n**Naming Conventions**:\n- Rust: `snake_case` for modules/functions, `PascalCase` for types\n- Files match module names (`parser.rs` → `mod parser`)\n- Structs are noun phrases: `ConfigRoot`, `DeviceConfig`, `KeyMapping`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**From ai-dev-foundation**:\n- Build scripts (`scripts/build.sh`, `scripts/verify.sh`)\n- Testing infrastructure (cargo test, BATS, integration tests)\n- CI/CD workflows (GitHub Actions)\n- Pre-commit hooks for quality gates\n\n**From Workspace Dependencies**:\n- `rkyv` crate for serialization (already in workspace)\n- `rhai` crate for DSL (already in workspace)\n- `clap` crate for CLI parsing (already in workspace)\n- `serde` crate for JSON output (already in workspace)\n\n### Integration Points\n\nAll code in this spec is greenfield (no existing keyrx-specific config code). The compiler will integrate with:\n- `keyrx_daemon`: Loads and consumes .krx files\n- `keyrx_ui`: May display configuration metadata or errors\n- Build scripts: Invoked via `make build` and `make verify`\n\n## Architecture\n\n### High-Level Flow\n\n```mermaid\ngraph TD\n    A[User writes main.rhai] --> B[keyrx_compiler]\n    B --> C[Rhai Parser]\n    C --> D[Import Resolver]\n    D --> C\n    C --> E[ConfigRoot Builder]\n    E --> F[rkyv Serializer]\n    F --> G[SHA256 Hasher]\n    G --> H[.krx Binary File]\n    H --> I[keyrx_daemon loads .krx]\n    I --> J[Zero-copy deserialization]\n    J --> K[Hash verification]\n    K --> L[Runtime key remapping]\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: Each module handles one specific concern\n- **Component Isolation**: Parser, serializer, import resolver are independent\n- **Service Layer Separation**: Clear boundaries between CLI, logic, and data layers\n- **Utility Modularity**: Error handling and validation are separate utilities\n\n## Components and Interfaces\n\n### Component 1: Configuration Data Structures (`keyrx_core/src/config.rs`)\n\n- **Purpose**: Define the configuration data model shared by compiler and daemon\n- **Interfaces**: Public structs/enums with rkyv traits\n- **Dependencies**: rkyv, fixedbitset, arrayvec (no_std compatible)\n- **Key Types**:\n  - `ConfigRoot`: Root configuration with version, devices, metadata\n  - `DeviceConfig`: Device identifier + list of mappings\n  - `KeyMapping`: Enum with Simple variant (from → to)\n  - `KeyCode`: Enum with 100+ key codes\n\n### Component 2: Rhai DSL Evaluator (`keyrx_compiler/src/parser.rs`)\n\n- **Purpose**: Parse and evaluate Rhai scripts into ConfigRoot\n- **Interfaces**:\n  - `parse_script(path: &Path) -> Result<ConfigRoot, ParseError>`\n  - Custom Rhai functions: `device(pattern)`, `map(from, to)`\n- **Dependencies**: Rhai engine, import resolver, error utilities\n- **Reuses**: Error types from `error.rs`, import logic from `import_resolver.rs`\n\n### Component 3: Binary Serializer (`keyrx_compiler/src/serialize.rs`)\n\n- **Purpose**: Serialize ConfigRoot to .krx format with hash verification\n- **Interfaces**:\n  - `serialize(config: &ConfigRoot) -> Result<Vec<u8>, SerializeError>`\n  - `deserialize(bytes: &[u8]) -> Result<&ArchivedConfigRoot, DeserializeError>`\n- **Dependencies**: rkyv, sha2 (for SHA256)\n- **Binary Format**:\n  - Header: 4 bytes magic (0x4B52580A), 4 bytes version, 32 bytes SHA256, 8 bytes size\n  - Body: rkyv-serialized ConfigRoot\n\n### Component 4: Import Resolver (`keyrx_compiler/src/import_resolver.rs`)\n\n- **Purpose**: Resolve and load imported Rhai files recursively\n- **Interfaces**:\n  - `resolve_imports(path: &Path) -> Result<Vec<PathBuf>, ImportError>`\n  - `detect_circular_imports(chain: &[PathBuf]) -> Result<(), ImportError>`\n- **Dependencies**: std::fs for file I/O, std::collections for cycle detection\n- **Reuses**: Error types from `error.rs`\n\n### Component 5: CLI Interface (`keyrx_compiler/src/main.rs`)\n\n- **Purpose**: Provide user-facing command-line interface\n- **Interfaces**:\n  - `compile` subcommand: input.rhai → output.krx\n  - `verify` subcommand: validate .krx file\n  - `hash` subcommand: output SHA256 hash\n  - `parse` subcommand: parse to JSON (debugging)\n- **Dependencies**: clap for CLI parsing, all other components\n- **Reuses**: Parser, serializer, error formatting\n\n## Data Models\n\n### ConfigRoot\n```rust\n#[repr(C)]\n#[derive(Archive, Serialize, Deserialize)]\nstruct ConfigRoot {\n    version: Version,              // Semantic version (major, minor, patch)\n    devices: Vec<DeviceConfig>,    // List of device configurations\n    metadata: Metadata,            // Compilation timestamp, compiler version, source hash\n}\n```\n\n### DeviceConfig\n```rust\n#[repr(C)]\n#[derive(Archive, Serialize, Deserialize)]\nstruct DeviceConfig {\n    identifier: DeviceIdentifier,  // USB VID/PID pattern or serial number glob\n    mappings: Vec<KeyMapping>,     // List of key mappings for this device\n}\n```\n\n### KeyMapping\n```rust\n#[repr(C)]\n#[derive(Archive, Serialize, Deserialize)]\nenum KeyMapping {\n    Simple { from: KeyCode, to: KeyCode },\n    // Future variants: TapHold, Layer (placeholders only)\n}\n```\n\n### KeyCode\n```rust\n#[repr(u16)]\n#[derive(Archive, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, Hash)]\nenum KeyCode {\n    // Letters: A=0x00, B=0x01, ..., Z=0x19\n    A = 0x00, B = 0x01, /* ... */ Z = 0x19,\n\n    // Numbers: Num0=0x20, ..., Num9=0x29\n    Num0 = 0x20, /* ... */ Num9 = 0x29,\n\n    // Function keys: F1=0x30, ..., F12=0x3B\n    F1 = 0x30, /* ... */ F12 = 0x3B,\n\n    // Modifiers: LShift=0x100, RShift=0x101, etc.\n    LShift = 0x100, RShift = 0x101, /* ... */\n\n    // Special keys: Escape=0x200, Enter=0x201, etc.\n    Escape = 0x200, Enter = 0x201, /* ... */\n\n    // 100+ total variants\n}\n```\n\n### Version\n```rust\n#[repr(C)]\n#[derive(Archive, Serialize, Deserialize)]\nstruct Version {\n    major: u8,\n    minor: u8,\n    patch: u8,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Rhai Syntax Error**:\n   - **Handling**: Capture error from Rhai engine, extract line/column, show code snippet\n   - **User Impact**: Clear message with \"error at line X, column Y: ...\" and suggestions\n\n2. **Import Not Found**:\n   - **Handling**: Report file path, list searched directories, suggest similar filenames\n   - **User Impact**: \"import 'foo.rhai' not found, searched: [paths], did you mean: bar.rhai?\"\n\n3. **Circular Import**:\n   - **Handling**: Detect cycles during resolution, report import chain\n   - **User Impact**: \"circular import: a.rhai → b.rhai → c.rhai → a.rhai\"\n\n4. **Serialization Failure**:\n   - **Handling**: Wrap rkyv errors with context, report problematic field\n   - **User Impact**: \"failed to serialize DeviceConfig: ...\"\n\n5. **Hash Verification Failure**:\n   - **Handling**: Compare computed hash vs embedded hash, report corruption\n   - **User Impact**: \"corrupted .krx file: hash mismatch (expected: ..., actual: ...)\"\n\n6. **Resource Limit Exceeded**:\n   - **Handling**: Rhai engine aborts, report which limit was hit\n   - **User Impact**: \"script exceeded operation limit (10,000), possible infinite loop\"\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Configuration Structures**: Test serialization/deserialization round-trips, validate rkyv traits\n- **Rhai Parser**: Test device() and map() functions, error handling, resource limits\n- **Import Resolver**: Test recursive imports, circular detection, file not found\n- **Serializer**: Test deterministic output, hash computation, binary format\n- **Error Formatting**: Test JSON output, user-friendly messages\n\n**Coverage Target**: 90% for all modules\n\n### Integration Testing\n\n- **End-to-End Compilation**: Write Rhai scripts → compile → verify .krx files\n- **Multi-File Imports**: Test configurations split across multiple files\n- **CLI Commands**: Test all subcommands (compile, verify, hash, parse) with various flags\n- **Error Scenarios**: Test all error paths produce expected messages\n\n**Test Files**: Located in `keyrx_compiler/tests/integration/`\n\n### Property-Based Testing\n\n- **Determinism**: Verify serialize(config) produces identical bytes on multiple runs\n- **Round-trip**: Verify deserialize(serialize(config)) == config\n- **Hash Stability**: Verify same config always produces same hash\n\n**Framework**: Use `proptest` or `quickcheck` crate\n\n### Fuzz Testing\n\n- **Parser Robustness**: Feed random Rhai scripts to parser, ensure no panics\n- **Deserializer Safety**: Feed random bytes to deserializer, ensure no panics or UB\n\n**Setup**: `cargo fuzz` in `keyrx_core/fuzz/` directory\n**Duration**: Run for 60+ seconds in CI, continuous fuzzing in background\n",
  "fileStats": {
    "size": 10392,
    "lines": 291,
    "lastModified": "2025-12-21T07:52:36.457Z"
  },
  "comments": []
}