{
  "id": "snapshot_1766302502797_ssgu39qbu",
  "approvalId": "approval_1766302502793_6u5hja2aa",
  "approvalTitle": "Design for Core Configuration System",
  "version": 1,
  "timestamp": "2025-12-21T07:35:02.797Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document - Core Configuration System\n\n## Overview\n\nThe Core Configuration System enables users to define keyboard remapping configurations in Rhai scripts and compile them into deterministic, zero-copy binary files (.krx format). The system consists of four major components:\n\n1. **Configuration Data Structures** (`keyrx_core/src/config.rs`) - Rust structs defining the configuration model\n2. **Rhai DSL Evaluator** (`keyrx_compiler/src/parser.rs`) - Parses and evaluates Rhai scripts\n3. **Binary Serializer/Deserializer** (`keyrx_compiler/src/serialize.rs`) - rkyv-based serialization\n4. **CLI Compiler** (`keyrx_compiler/src/main.rs`) - User-facing command-line tool\n\nThis design ensures:\n- **Deterministic Output**: Same Rhai input always produces identical binary output\n- **Zero-Copy Performance**: Deserial\n\nization requires no heap allocation or parsing\n- **SSOT Verification**: SHA256 hashing enables configuration integrity checks\n- **Modular Architecture**: Single entry point with imports for complex configurations\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Rhai Scripting Language**:\n- Rhai version 1.15+ for DSL implementation\n- Custom functions registered for `device()` and `map()` API\n- Compile-time evaluation (no runtime script execution)\n- Resource limits prevent DoS attacks (max operations, max recursion)\n\n**rkyv Serialization**:\n- rkyv 0.7+ with validation features\n- Zero-copy deserialization for sub-10ms load times\n- Deterministic byte output for hash verification\n- `#[repr(C)]` structs for stable memory layout\n\n**no_std Compatibility**:\n- `keyrx_core/src/config.rs` compiles without std library\n- Uses `core::` and `alloc::` only (WASM-compatible)\n- Enables future use in embedded contexts\n\n### Project Structure (structure.md)\n\n**Module Organization**:\n```\nkeyrx_core/src/\n├── config.rs          # Configuration data structures (no_std)\n└── lib.rs             # Public API exports\n\nkeyrx_compiler/src/\n├── main.rs            # CLI entry point\n├── parser.rs          # Rhai DSL evaluator\n├── serialize.rs       # rkyv serialization\n├── import_resolver.rs # Import system\n└── error.rs           # Error types\n```\n\n**Naming Conventions**:\n- Rust: `snake_case` for modules/functions, `PascalCase` for types\n- Files: Match module names (`parser.rs` → `mod parser`)\n- Structs: `ConfigRoot`, `DeviceConfig`, `KeyMapping` (noun phrases)\n\n## Code Reuse Analysis\n\n### Existing Code to Leverage\n\n**From ai-dev-foundation**:\n- Build scripts (`scripts/build.sh`, `scripts/verify.sh`)\n- Testing infrastructure (BATS, integration tests)\n- CI/CD workflows (GitHub Actions)\n- Pre-commit hooks (quality gates)\n\n**From Workspace Dependencies**:\n- `rkyv` crate for serialization (already in workspace Cargo.toml)\n- `rhai` crate for DSL (already in workspace Cargo.toml)\n- `clap` crate for CLI parsing (already in workspace Cargo.toml)\n- `serde` crate for metadata JSON (already in workspace Cargo.toml)\n\n### New Code to Create\n\nAll code in this spec is greenfield (no existing keyrx-specific config code):\n- Configuration data structures (new)\n- Rhai DSL evaluator (new)\n- Binary serialization logic (new)\n- CLI compiler (new)\n- Import resolution (new)\n\n## Architecture\n\n### High-Level Architecture\n\n```mermaid\ngraph TD\n    A[User writes main.rhai] --> B[keyrx_compiler]\n    B --> C[Rhai Parser]\n    C --> D[Import Resolver]\n    D --> C\n    C --> E[ConfigRoot Builder]\n    E --> F[rkyv Serializer]\n    F --> G[SHA256 Hasher]\n    G --> H[.krx Binary File]\n\n    H --> I[keyrx_daemon]\n    I --> J[rkyv Deserializer]\n    J --> K[ConfigRoot]\n    K --> L[Hash Verification]\n    L --> M[Configuration Loaded]\n\n    style H fill:#f9f,stroke:#333,stroke-width:2px\n    style K fill:#9f9,stroke:#333,stroke-width:2px\n```\n\n### Data Flow\n\n1. **Compilation Flow** (Rhai → Binary):\n   ```\n   main.rhai\n     ↓\n   Rhai Parser (parse AST)\n     ↓\n   Import Resolver (fetch & merge imports)\n     ↓\n   DSL Evaluator (execute AST, call device()/map())\n     ↓\n   ConfigRoot Builder (construct data structures)\n     ↓\n   Normalizer (sort devices, mappings for determinism)\n     ↓\n   rkyv Serializer (convert to bytes)\n     ↓\n   SHA256 Hasher (compute hash)\n     ↓\n   Binary Writer (magic + version + hash + payload)\n     ↓\n   config.krx\n   ```\n\n2. **Deserialization Flow** (Binary → Runtime Config):\n   ```\n   config.krx\n     ↓\n   Binary Reader (read header + payload)\n     ↓\n   Hash Verifier (recompute SHA256, compare)\n     ↓\n   rkyv Deserializer (zero-copy access)\n     ↓\n   Validator (check pointers, enum variants)\n     ↓\n   ConfigRoot (ready for use)\n   ```\n\n### Component Architecture\n\n#### Component 1: Configuration Data Structures\n\n**Module**: `keyrx_core/src/config.rs`\n\n**Purpose**: Define the in-memory representation of keyboard remapping configuration.\n\n**Design Decisions**:\n- Use `#[repr(C)]` for ABI stability (cross-version compatibility consideration)\n- Derive `rkyv::Archive`, `rkyv::Serialize`, `rkyv::Deserialize` for zero-copy\n- Use `FixedBitSet` for future modifier state (255 bits)\n- Use `ArrayVec` for bounded collections (avoid heap allocations)\n\n**Data Model**:\n```rust\n#[derive(Archive, Serialize, Deserialize)]\n#[repr(C)]\npub struct ConfigRoot {\n    pub version: Version,\n    pub devices: Vec<DeviceConfig>,\n    pub metadata: Metadata,\n}\n\n#[derive(Archive, Serialize, Deserialize)]\n#[repr(C)]\npub struct Version {\n    pub major: u8,\n    pub minor: u8,\n    pub patch: u8,\n}\n\n#[derive(Archive, Serialize, Deserialize)]\n#[repr(C)]\npub struct DeviceConfig {\n    pub identifier: DeviceIdentifier,\n    pub mappings: Vec<KeyMapping>,\n}\n\n#[derive(Archive, Serialize, Deserialize)]\n#[repr(C)]\npub struct DeviceIdentifier {\n    pub pattern: String,  // e.g., \"USB\\\\VID_1234&PID_5678\\\\SERIAL_*\"\n}\n\n#[derive(Archive, Serialize, Deserialize)]\n#[repr(C)]\npub enum KeyMapping {\n    Simple {\n        from: KeyCode,\n        to: KeyCode,\n    },\n    // Future variants:\n    // TapHold { ... }\n    // Layer { ... }\n}\n\n#[derive(Archive, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, Hash)]\n#[repr(u16)]\npub enum KeyCode {\n    // Letters\n    A = 0x00,\n    B = 0x01,\n    // ... (full keyboard layout)\n\n    // Modifiers\n    LShift = 0x100,\n    RShift = 0x101,\n    LCtrl = 0x102,\n    // ...\n\n    // Special keys\n    Escape = 0x200,\n    CapsLock = 0x201,\n    // ...\n}\n\n#[derive(Archive, Serialize, Deserialize)]\n#[repr(C)]\npub struct Metadata {\n    pub compiler_version: String,\n    pub source_hash: [u8; 32],  // SHA256 of Rhai source\n    // No timestamp (non-deterministic)\n}\n```\n\n**Validation Strategy**:\n- KeyCode enum: All variants must be explicitly numbered (prevent reordering)\n- DeviceIdentifier: Validate pattern format at compile time\n- Vec bounds: Document maximum sizes (e.g., max 100 devices, 10K mappings)\n\n---\n\n#### Component 2: Rhai DSL Evaluator\n\n**Module**: `keyrx_compiler/src/parser.rs`\n\n**Purpose**: Parse Rhai scripts and construct `ConfigRoot` from DSL calls.\n\n**Rhai Engine Configuration**:\n```rust\nuse rhai::{Engine, Scope, Dynamic, Map};\n\npub struct RhaiEvaluator {\n    engine: Engine,\n    devices: Vec<DeviceConfig>,\n}\n\nimpl RhaiEvaluator {\n    pub fn new() -> Self {\n        let mut engine = Engine::new();\n\n        // Security: Disable dangerous features\n        engine.set_max_operations(1_000_000);  // Prevent infinite loops\n        engine.set_max_string_size(1024);      // Limit string size\n        engine.set_max_array_size(10_000);     // Limit array size\n\n        // Register custom API\n        Self::register_device_api(&mut engine);\n        Self::register_key_enum(&mut engine);\n\n        RhaiEvaluator {\n            engine,\n            devices: Vec::new(),\n        }\n    }\n\n    fn register_device_api(engine: &mut Engine) {\n        // device(\"USB\\\\VID_1234...\") -> DeviceHandle\n        engine.register_fn(\"device\", |identifier: String| {\n            DeviceHandle::new(identifier)\n        });\n    }\n\n    fn register_key_enum(engine: &mut Engine) {\n        // Key::A, Key::B, etc.\n        engine.register_type::<KeyCode>();\n\n        // Register all key codes as constants\n        engine.register_static_module(\"Key\", KeyCode::rhai_module());\n    }\n\n    pub fn eval_script(&mut self, script: &str, file_path: &Path) -> Result<ConfigRoot> {\n        // Parse and evaluate\n        let ast = self.engine.compile(script)\n            .map_err(|e| CompileError::SyntaxError { ... })?;\n\n        let mut scope = Scope::new();\n        self.engine.eval_ast_with_scope(&mut scope, &ast)\n            .map_err(|e| CompileError::EvalError { ... })?;\n\n        // Extract devices from scope\n        self.extract_devices(&scope)?;\n\n        // Build ConfigRoot\n        Ok(ConfigRoot {\n            version: Version::current(),\n            devices: self.devices.clone(),\n            metadata: Metadata::from_script(script),\n        })\n    }\n}\n```\n\n**DeviceHandle Implementation** (Rhai custom type):\n```rust\n#[derive(Clone)]\npub struct DeviceHandle {\n    identifier: String,\n    mappings: Vec<KeyMapping>,\n}\n\nimpl DeviceHandle {\n    pub fn new(identifier: String) -> Self {\n        DeviceHandle {\n            identifier,\n            mappings: Vec::new(),\n        }\n    }\n\n    // Rhai method: kbd.map(Key::A, Key::B)\n    pub fn map(&mut self, from: KeyCode, to: KeyCode) {\n        self.mappings.push(KeyMapping::Simple { from, to });\n    }\n\n    // Convert to DeviceConfig\n    pub fn to_config(self) -> DeviceConfig {\n        DeviceConfig {\n            identifier: DeviceIdentifier { pattern: self.identifier },\n            mappings: self.mappings,\n        }\n    }\n}\n\n// Register with Rhai\nfn register_device_handle(engine: &mut Engine) {\n    engine.register_type::<DeviceHandle>();\n    engine.register_fn(\"map\", DeviceHandle::map);\n}\n```\n\n**KeyCode Rhai Module**:\n```rust\nimpl KeyCode {\n    pub fn rhai_module() -> rhai::Module {\n        let mut module = rhai::Module::new();\n\n        // Key::A\n        module.set_var(\"A\", KeyCode::A);\n        module.set_var(\"B\", KeyCode::B);\n        // ... (all 100+ key codes)\n\n        module.set_var(\"Escape\", KeyCode::Escape);\n        module.set_var(\"CapsLock\", KeyCode::CapsLock);\n        // ...\n\n        module\n    }\n}\n```\n\n---\n\n#### Component 3: Import Resolver\n\n**Module**: `keyrx_compiler/src/import_resolver.rs`\n\n**Purpose**: Resolve `import \"file.rhai\"` statements recursively.\n\n**Design**:\n```rust\nuse std::path::{Path, PathBuf};\nuse std::collections::HashSet;\n\npub struct ImportResolver {\n    visited: HashSet<PathBuf>,  // Prevent circular imports\n    base_dir: PathBuf,           // Base directory for relative imports\n}\n\nimpl ImportResolver {\n    pub fn new(base_dir: impl Into<PathBuf>) -> Self {\n        ImportResolver {\n            visited: HashSet::new(),\n            base_dir: base_dir.into(),\n        }\n    }\n\n    pub fn resolve(&mut self, script: &str, current_file: &Path) -> Result<String> {\n        // Find all import statements\n        let imports = self.find_imports(script)?;\n\n        if imports.is_empty() {\n            return Ok(script.to_string());\n        }\n\n        // Resolve each import\n        let mut resolved = script.to_string();\n        for import_path in imports {\n            let full_path = self.resolve_path(&import_path, current_file)?;\n\n            // Detect circular imports\n            if !self.visited.insert(full_path.clone()) {\n                return Err(ImportError::Circular { path: full_path });\n            }\n\n            // Read imported file\n            let imported_content = std::fs::read_to_string(&full_path)\n                .map_err(|e| ImportError::FileNotFound { ... })?;\n\n            // Recursively resolve imports in imported file\n            let resolved_import = self.resolve(&imported_content, &full_path)?;\n\n            // Replace import statement with resolved content\n            let import_stmt = format!(\"import \\\"{}\\\";\", import_path);\n            resolved = resolved.replace(&import_stmt, &resolved_import);\n        }\n\n        Ok(resolved)\n    }\n\n    fn find_imports(&self, script: &str) -> Result<Vec<String>> {\n        // Regex: import \"path/to/file.rhai\";\n        let re = regex::Regex::new(r#\"import\\s+\"([^\"]+\\.rhai)\"\\s*;\"#).unwrap();\n\n        Ok(re.captures_iter(script)\n            .map(|cap| cap[1].to_string())\n            .collect())\n    }\n\n    fn resolve_path(&self, import_path: &str, current_file: &Path) -> Result<PathBuf> {\n        let current_dir = current_file.parent().unwrap_or(&self.base_dir);\n        let full_path = current_dir.join(import_path);\n\n        if !full_path.exists() {\n            return Err(ImportError::FileNotFound {\n                path: import_path.to_string(),\n                searched_in: current_dir.to_path_buf(),\n            });\n        }\n\n        Ok(full_path.canonicalize()?)\n    }\n}\n```\n\n**Import Processing Flow**:\n1. Read main script file\n2. Find all `import \"...\"` statements (regex)\n3. For each import:\n   - Resolve path relative to importing file\n   - Check circular import (visited set)\n   - Read imported file\n   - Recursively resolve imports in imported file\n   - Replace import statement with resolved content\n4. Return fully resolved script (all imports inlined)\n\n**Example**:\n```rhai\n// main.rhai\nimport \"devices/left.rhai\";\nimport \"devices/right.rhai\";\n```\n\nBecomes:\n```rhai\n// main.rhai (after resolution)\n// --- BEGIN devices/left.rhai ---\nlet left = device(\"USB\\\\VID_AAAA\");\nleft.map(Key::A, Key::B);\n// --- END devices/left.rhai ---\n\n// --- BEGIN devices/right.rhai ---\nlet right = device(\"USB\\\\VID_BBBB\");\nright.map(Key::C, Key::D);\n// --- END devices/right.rhai ---\n```\n\n---\n\n#### Component 4: Binary Serializer\n\n**Module**: `keyrx_compiler/src/serialize.rs`\n\n**Purpose**: Serialize `ConfigRoot` to deterministic binary format.\n\n**Binary Format** (.krx file structure):\n```\n+------------------+\n| Magic (4 bytes)  |  b\"KRXC\"\n+------------------+\n| Version (3 bytes)|  major.minor.patch\n+------------------+\n| Reserved (1 byte)|  0x00 (future use)\n+------------------+\n| Hash (32 bytes)  |  SHA256(payload)\n+------------------+\n| Payload Len      |  u64 little-endian\n| (8 bytes)        |\n+------------------+\n| Payload          |  rkyv serialized ConfigRoot\n| (N bytes)        |\n+------------------+\n```\n\n**Serialization Implementation**:\n```rust\nuse rkyv::{ser::Serializer, AlignedVec, Archive};\nuse sha2::{Sha256, Digest};\n\npub struct BinarySerializer;\n\nimpl BinarySerializer {\n    const MAGIC: &'static [u8; 4] = b\"KRXC\";\n    const CURRENT_VERSION: Version = Version { major: 1, minor: 0, patch: 0 };\n\n    pub fn serialize(config: &ConfigRoot) -> Result<Vec<u8>> {\n        // Step 1: Normalize config for determinism\n        let normalized = Self::normalize(config);\n\n        // Step 2: Serialize payload with rkyv\n        let mut serializer = AlignedVec::new();\n        serializer.serialize_value(&normalized)\n            .map_err(|e| SerializeError::RkyvError { ... })?;\n\n        let payload = serializer.into_vec();\n\n        // Step 3: Compute hash\n        let mut hasher = Sha256::new();\n        hasher.update(&payload);\n        let hash = hasher.finalize();\n\n        // Step 4: Build binary\n        let mut output = Vec::new();\n        output.extend_from_slice(Self::MAGIC);\n        output.push(Self::CURRENT_VERSION.major);\n        output.push(Self::CURRENT_VERSION.minor);\n        output.push(Self::CURRENT_VERSION.patch);\n        output.push(0x00);  // Reserved\n        output.extend_from_slice(&hash);\n        output.extend_from_slice(&(payload.len() as u64).to_le_bytes());\n        output.extend_from_slice(&payload);\n\n        Ok(output)\n    }\n\n    fn normalize(config: &ConfigRoot) -> ConfigRoot {\n        // Sort devices by identifier (deterministic ordering)\n        let mut devices = config.devices.clone();\n        devices.sort_by(|a, b| a.identifier.pattern.cmp(&b.identifier.pattern));\n\n        // Sort mappings within each device\n        for device in &mut devices {\n            device.mappings.sort_by_key(|m| match m {\n                KeyMapping::Simple { from, to } => (*from as u32) << 16 | (*to as u32),\n            });\n        }\n\n        ConfigRoot {\n            version: config.version.clone(),\n            devices,\n            metadata: config.metadata.clone(),\n        }\n    }\n\n    pub fn deserialize(bytes: &[u8]) -> Result<&ConfigRoot> {\n        // Step 1: Verify magic\n        if &bytes[0..4] != Self::MAGIC {\n            return Err(DeserializeError::InvalidMagic);\n        }\n\n        // Step 2: Check version\n        let version = Version {\n            major: bytes[4],\n            minor: bytes[5],\n            patch: bytes[6],\n        };\n\n        if version.major != Self::CURRENT_VERSION.major {\n            return Err(DeserializeError::IncompatibleVersion { found: version });\n        }\n\n        // Step 3: Verify hash\n        let stored_hash = &bytes[8..40];\n        let payload_len = u64::from_le_bytes(bytes[40..48].try_into().unwrap()) as usize;\n        let payload = &bytes[48..48+payload_len];\n\n        let mut hasher = Sha256::new();\n        hasher.update(payload);\n        let computed_hash = hasher.finalize();\n\n        if stored_hash != computed_hash.as_slice() {\n            return Err(DeserializeError::HashMismatch);\n        }\n\n        // Step 4: Deserialize with validation\n        let archived = unsafe {\n            rkyv::archived_root::<ConfigRoot>(payload)\n        };\n\n        // Validate\n        rkyv::check_archived_root::<ConfigRoot>(payload)\n            .map_err(|e| DeserializeError::ValidationFailed { ... })?;\n\n        Ok(archived)\n    }\n}\n```\n\n**Determinism Strategy**:\n1. Sort all collections (devices, mappings) before serialization\n2. Use stable field ordering (struct field order determines byte layout)\n3. Exclude non-deterministic data (timestamps, random IDs)\n4. Use `#[repr(C)]` for stable memory layout\n5. Verify with test: serialize(X) 1000 times → same bytes\n\n---\n\n#### Component 5: CLI Compiler\n\n**Module**: `keyrx_compiler/src/main.rs`\n\n**Purpose**: User-facing command-line tool for compiling Rhai scripts.\n\n**CLI Structure** (using clap derive):\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(name = \"keyrx_compiler\")]\n#[command(about = \"Compile Rhai configuration scripts to .krx binaries\")]\n#[command(version)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option<Commands>,\n\n    /// Input Rhai script file\n    #[arg(value_name = \"INPUT\")]\n    input: Option<PathBuf>,\n\n    /// Output .krx file path\n    #[arg(short, long, value_name = \"OUTPUT\")]\n    output: Option<PathBuf>,\n\n    /// Enable verbose logging\n    #[arg(short, long)]\n    verbose: bool,\n\n    /// Suppress all output except errors\n    #[arg(short, long)]\n    quiet: bool,\n\n    /// Output in JSON format\n    #[arg(long)]\n    json: bool,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Compile Rhai script to .krx binary\n    Compile {\n        /// Input Rhai script\n        input: PathBuf,\n\n        /// Output .krx file\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n    },\n\n    /// Verify .krx binary hash\n    Verify {\n        /// .krx file to verify\n        file: PathBuf,\n    },\n\n    /// Extract hash from .krx binary\n    Hash {\n        /// .krx file\n        file: PathBuf,\n    },\n\n    /// Parse script without compiling (syntax check)\n    ParseOnly {\n        /// Rhai script to parse\n        input: PathBuf,\n    },\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    match cli.command {\n        Some(Commands::Compile { input, output }) => {\n            compile_command(input, output, &cli)\n        },\n        Some(Commands::Verify { file }) => {\n            verify_command(file, &cli)\n        },\n        Some(Commands::Hash { file }) => {\n            hash_command(file, &cli)\n        },\n        Some(Commands::ParseOnly { input }) => {\n            parse_only_command(input, &cli)\n        },\n        None if cli.input.is_some() => {\n            // Default: compile\n            compile_command(cli.input.unwrap(), cli.output, &cli)\n        },\n        None => {\n            eprintln!(\"Error: No input file specified\");\n            std::process::exit(1);\n        }\n    }\n}\n```\n\n**Compile Command**:\n```rust\nfn compile_command(input: PathBuf, output: Option<PathBuf>, cli: &Cli) -> ! {\n    // Determine output path\n    let output_path = output.unwrap_or_else(|| {\n        input.with_extension(\"krx\")\n    });\n\n    // Read input script\n    let script = std::fs::read_to_string(&input)\n        .unwrap_or_exit(\"Failed to read input file\");\n\n    // Resolve imports\n    let mut resolver = ImportResolver::new(input.parent().unwrap());\n    let resolved_script = resolver.resolve(&script, &input)\n        .unwrap_or_exit(\"Import resolution failed\");\n\n    // Parse and evaluate\n    let mut evaluator = RhaiEvaluator::new();\n    let config = evaluator.eval_script(&resolved_script, &input)\n        .unwrap_or_exit(\"Compilation failed\");\n\n    // Serialize\n    let binary = BinarySerializer::serialize(&config)\n        .unwrap_or_exit(\"Serialization failed\");\n\n    // Write output\n    std::fs::write(&output_path, &binary)\n        .unwrap_or_exit(\"Failed to write output file\");\n\n    // Compute hash for output\n    let hash = compute_hash(&binary);\n\n    // Output success\n    if cli.json {\n        println!(\"{}\", json!({\n            \"status\": \"success\",\n            \"output\": output_path.display().to_string(),\n            \"hash\": hex::encode(hash),\n        }));\n    } else if !cli.quiet {\n        println!(\"Compiled successfully: {}\", output_path.display());\n        println!(\"SHA256: {}\", hex::encode(hash));\n    }\n\n    std::process::exit(0);\n}\n```\n\n**Error Handling** (unwrap_or_exit pattern):\n```rust\ntrait UnwrapOrExit<T> {\n    fn unwrap_or_exit(self, message: &str) -> T;\n}\n\nimpl<T, E: std::fmt::Display> UnwrapOrExit<T> for Result<T, E> {\n    fn unwrap_or_exit(self, message: &str) -> T {\n        match self {\n            Ok(value) => value,\n            Err(err) => {\n                if cli.json {\n                    eprintln!(\"{}\", json!({\n                        \"status\": \"error\",\n                        \"message\": message,\n                        \"error\": err.to_string(),\n                    }));\n                } else {\n                    eprintln!(\"Error: {}\", message);\n                    eprintln!(\"{}\", err);\n                }\n                std::process::exit(1);\n            }\n        }\n    }\n}\n```\n\n---\n\n## Data Models\n\n### KeyCode Enum (First 50 keys)\n\n```rust\n#[derive(Archive, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, Hash, Debug)]\n#[repr(u16)]\npub enum KeyCode {\n    // Letters (0x00 - 0x19)\n    A = 0x00, B = 0x01, C = 0x02, D = 0x03, E = 0x04,\n    F = 0x05, G = 0x06, H = 0x07, I = 0x08, J = 0x09,\n    K = 0x0A, L = 0x0B, M = 0x0C, N = 0x0D, O = 0x0E,\n    P = 0x0F, Q = 0x10, R = 0x11, S = 0x12, T = 0x13,\n    U = 0x14, V = 0x15, W = 0x16, X = 0x17, Y = 0x18,\n    Z = 0x19,\n\n    // Numbers (0x20 - 0x29)\n    Num0 = 0x20, Num1 = 0x21, Num2 = 0x22, Num3 = 0x23, Num4 = 0x24,\n    Num5 = 0x25, Num6 = 0x26, Num7 = 0x27, Num8 = 0x28, Num9 = 0x29,\n\n    // Function keys (0x30 - 0x3B)\n    F1 = 0x30, F2 = 0x31, F3 = 0x32, F4 = 0x33,\n    F5 = 0x34, F6 = 0x35, F7 = 0x36, F8 = 0x37,\n    F9 = 0x38, F10 = 0x39, F11 = 0x3A, F12 = 0x3B,\n\n    // Modifiers (0x100 - 0x107)\n    LShift = 0x100, RShift = 0x101,\n    LCtrl = 0x102, RCtrl = 0x103,\n    LAlt = 0x104, RAlt = 0x105,\n    LMeta = 0x106, RMeta = 0x107,  // Windows/Super/Command key\n\n    // Special keys (0x200 - 0x20F)\n    Escape = 0x200, Enter = 0x201, Backspace = 0x202, Tab = 0x203,\n    Space = 0x204, CapsLock = 0x205, Insert = 0x206, Delete = 0x207,\n    Home = 0x208, End = 0x209, PageUp = 0x20A, PageDown = 0x20B,\n\n    // Arrow keys (0x210 - 0x213)\n    Left = 0x210, Right = 0x211, Up = 0x212, Down = 0x213,\n\n    // ... (100+ total keys)\n}\n```\n\n### Binary Format Details\n\n**Header Layout** (48 bytes):\n```\nOffset | Size | Field        | Value\n-------|------|--------------|------------------\n0      | 4    | Magic        | b\"KRXC\" (0x4B525843)\n4      | 1    | Major        | 1\n5      | 1    | Minor        | 0\n6      | 1    | Patch        | 0\n7      | 1    | Reserved     | 0x00\n8      | 32   | SHA256       | Hash of payload\n40     | 8    | Payload Len  | u64 little-endian\n48     | N    | Payload      | rkyv bytes\n```\n\n**Payload Structure** (rkyv layout):\n- ConfigRoot struct offset table\n- Version struct (inline)\n- Device vector metadata (length, capacity)\n- DeviceConfig structs (sequential)\n- Mapping vector metadata per device\n- KeyMapping enums (sequential)\n- String data (device identifiers)\n\n---\n\n## Error Handling\n\n### Error Types\n\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum CompileError {\n    #[error(\"Syntax error at {location}: {message}\")]\n    SyntaxError {\n        location: SourceLocation,\n        message: String,\n    },\n\n    #[error(\"Unknown key '{key}' at {location}\")]\n    UnknownKey {\n        key: String,\n        location: SourceLocation,\n        suggestions: Vec<String>,\n    },\n\n    #[error(\"Duplicate mapping for {key} at {location} (previously defined at {previous})\")]\n    DuplicateMapping {\n        key: String,\n        location: SourceLocation,\n        previous: SourceLocation,\n    },\n\n    #[error(\"Circular import detected: {chain}\")]\n    CircularImport {\n        chain: String,  // e.g., \"main.rhai → a.rhai → b.rhai → a.rhai\"\n    },\n\n    #[error(\"Import file not found: {path} (searched in {searched_in})\")]\n    ImportNotFound {\n        path: String,\n        searched_in: PathBuf,\n    },\n\n    #[error(\"Serialization failed: {message}\")]\n    SerializationError {\n        message: String,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct SourceLocation {\n    pub file: String,\n    pub line: usize,\n    pub column: usize,\n}\n```\n\n### Error Output Formats\n\n**Human-Readable** (default):\n```\nError: Unknown key 'Key::InvalidKey' at line 10, column 15\n  |\n10| kbd.map(Key::InvalidKey, Key::A);\n  |         ^^^^^^^^^^^^^^^ unknown key\n\nDid you mean one of these?\n  - Key::Insert\n  - Key::Delete\n  - Key::Escape\n```\n\n**JSON** (`--json` flag):\n```json\n{\n  \"status\": \"error\",\n  \"error\": \"unknown_key\",\n  \"message\": \"Unknown key 'Key::InvalidKey'\",\n  \"location\": {\n    \"file\": \"main.rhai\",\n    \"line\": 10,\n    \"column\": 15\n  },\n  \"suggestions\": [\"Key::Insert\", \"Key::Delete\", \"Key::Escape\"]\n}\n```\n\n---\n\n## Testing Strategy\n\n### Unit Testing\n\n**Test Categories**:\n\n1. **Configuration Serialization**:\n   - Serialize ConfigRoot → bytes → deserialize → verify equality\n   - Test determinism: serialize 1000 times → same bytes\n   - Test all KeyCode variants\n   - Test large configs (10K mappings)\n\n2. **Rhai Evaluation**:\n   - Parse valid scripts → verify ConfigRoot structure\n   - Parse invalid scripts → verify error messages\n   - Test device() and map() API\n   - Test edge cases (empty config, single mapping, max mappings)\n\n3. **Import Resolution**:\n   - Single import\n   - Nested imports (A imports B imports C)\n   - Circular import detection (A imports B imports A)\n   - Import not found error\n\n4. **Hash Verification**:\n   - Compute hash → modify byte → verify fails\n   - Compute hash → same input → same hash\n   - Extract hash from binary\n\n**Test Examples**:\n```rust\n#[test]\nfn test_serialize_determinism() {\n    let config = ConfigRoot { ... };\n\n    let bytes1 = BinarySerializer::serialize(&config).unwrap();\n    let bytes2 = BinarySerializer::serialize(&config).unwrap();\n\n    assert_eq!(bytes1, bytes2);  // Deterministic\n}\n\n#[test]\nfn test_rhai_simple_mapping() {\n    let script = r#\"\n        let kbd = device(\"USB\\\\VID_1234\");\n        kbd.map(Key::A, Key::B);\n    \"#;\n\n    let mut eval = RhaiEvaluator::new();\n    let config = eval.eval_script(script, Path::new(\"test.rhai\")).unwrap();\n\n    assert_eq!(config.devices.len(), 1);\n    assert_eq!(config.devices[0].mappings.len(), 1);\n}\n\n#[test]\nfn test_circular_import() {\n    // a.rhai: import \"b.rhai\";\n    // b.rhai: import \"a.rhai\";\n\n    let mut resolver = ImportResolver::new(Path::new(\"test/\"));\n    let result = resolver.resolve(\"import \\\"a.rhai\\\";\", Path::new(\"test/main.rhai\"));\n\n    assert!(matches!(result, Err(ImportError::Circular { .. })));\n}\n```\n\n### Integration Testing\n\n**End-to-End Tests**:\n```bash\n# Test: Compile simple config\n./keyrx_compiler tests/fixtures/simple.rhai -o /tmp/simple.krx\nassert_exit_code 0\nassert_file_exists /tmp/simple.krx\n\n# Test: Verify hash\n./keyrx_compiler verify /tmp/simple.krx\nassert_stdout_contains \"VALID\"\n\n# Test: Extract hash\nHASH=$(./keyrx_compiler hash /tmp/simple.krx)\nassert_not_empty \"$HASH\"\n\n# Test: Recompile produces same hash\n./keyrx_compiler tests/fixtures/simple.rhai -o /tmp/simple2.krx\nHASH2=$(./keyrx_compiler hash /tmp/simple2.krx)\nassert_equal \"$HASH\" \"$HASH2\"\n\n# Test: Error on invalid script\n./keyrx_compiler tests/fixtures/invalid.rhai -o /tmp/invalid.krx\nassert_exit_code 1\nassert_stderr_contains \"Syntax error\"\n\n# Test: JSON output\nOUTPUT=$(./keyrx_compiler tests/fixtures/simple.rhai --json)\nassert_json_field \"$OUTPUT\" \"status\" \"success\"\nassert_json_field \"$OUTPUT\" \"hash\" \"^[0-9a-f]{64}$\"\n```\n\n### Property-Based Testing\n\n**Proptest Strategies**:\n```rust\nuse proptest::prelude::*;\n\n// Generate arbitrary ConfigRoot\nfn arb_config_root() -> impl Strategy<Value = ConfigRoot> {\n    (arb_version(), vec(arb_device_config(), 1..10), arb_metadata())\n        .prop_map(|(version, devices, metadata)| ConfigRoot {\n            version, devices, metadata\n        })\n}\n\n// Test: Roundtrip serialization\nproptest! {\n    #[test]\n    fn test_serialize_roundtrip(config in arb_config_root()) {\n        let bytes = BinarySerializer::serialize(&config).unwrap();\n        let deserialized = BinarySerializer::deserialize(&bytes).unwrap();\n\n        // Compare (requires PartialEq on ConfigRoot)\n        assert_eq!(config, deserialized);\n    }\n\n    #[test]\n    fn test_hash_determinism(config in arb_config_root()) {\n        let bytes1 = BinarySerializer::serialize(&config).unwrap();\n        let bytes2 = BinarySerializer::serialize(&config).unwrap();\n\n        assert_eq!(bytes1, bytes2);\n    }\n}\n```\n\n### Coverage Goals\n\n- **keyrx_core/src/config.rs**: 100% (data structures)\n- **keyrx_compiler/src/parser.rs**: ≥90% (Rhai evaluation)\n- **keyrx_compiler/src/serialize.rs**: ≥95% (serialization critical)\n- **keyrx_compiler/src/import_resolver.rs**: ≥90% (import logic)\n- **Overall**: ≥90% code coverage\n\n---\n\n## Performance Targets\n\n| Operation | Target | Measurement |\n|-----------|--------|-------------|\n| Compile simple config (<100 lines) | <500ms | Time from CLI invocation to .krx write |\n| Compile large config (1000 lines, 10K mappings) | <2s | Same |\n| Serialize ConfigRoot (10K mappings) | <100ms | BinarySerializer::serialize() |\n| Deserialize .krx (10K mappings) | <10ms | BinarySerializer::deserialize() |\n| Hash computation (100KB binary) | <5ms | SHA256 of payload |\n| Import resolution (10 files, 5 levels deep) | <200ms | ImportResolver::resolve() |\n\n**Benchmark Setup** (using Criterion):\n```rust\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn bench_serialize(c: &mut Criterion) {\n    let config = generate_large_config(10_000);  // 10K mappings\n\n    c.bench_function(\"serialize_10k_mappings\", |b| {\n        b.iter(|| BinarySerializer::serialize(black_box(&config)))\n    });\n}\n\ncriterion_group!(benches, bench_serialize, bench_deserialize, bench_hash);\ncriterion_main!(benches);\n```\n\n---\n\n## Security Considerations\n\n### Rhai Sandboxing\n\n**Disabled Features** (prevent malicious scripts):\n- File I/O (`std::fs` access) - DISABLED\n- Network access (`std::net`) - DISABLED\n- System commands (`std::process`) - DISABLED\n- Arbitrary code execution (`eval`) - DISABLED\n\n**Resource Limits**:\n- Max operations: 1,000,000 (prevents infinite loops)\n- Max string size: 1KB (prevents memory exhaustion)\n- Max array size: 10,000 (prevents DoS)\n- Max recursion depth: 100 (prevents stack overflow)\n\n### Binary Validation\n\n**Defense Against Malformed Binaries**:\n- Magic number check (prevents treating non-.krx files as config)\n- Version compatibility check (prevents loading incompatible formats)\n- Hash verification (detects corruption or tampering)\n- rkyv validation (prevents buffer overflows, out-of-bounds access)\n\n**Threat Model**:\n- Untrusted .krx files (e.g., downloaded from internet)\n- Corrupted files (bit flips, incomplete writes)\n- Malicious files (crafted to exploit deserializer)\n\n**Mitigation**:\n- All validation before unsafe deserialization\n- Fail-safe defaults (reject on any validation failure)\n- No unsafe code except in rkyv (which has validation)\n\n---\n\n## Future Enhancements (Out of Scope)\n\nThe following are explicitly deferred to future specs:\n\n1. **Configuration Validation Tool** - Separate CLI tool to lint/validate configs\n2. **Hot Reload** - Watch .rhai files, recompile and reload daemon on change\n3. **IDE Integration** - VSCode extension for Rhai syntax highlighting, autocomplete\n4. **Configuration Diff Tool** - Compare two .krx files, show differences\n5. **Binary Compression** - Compress payload with zstd (trade size for speed)\n6. **Conditional Compilation** - `#[cfg(...)]`-like directives in Rhai\n7. **Macro System** - Rhai macros for reducing repetition\n\nThese will be addressed in subsequent specs after core-config-system is stable.\n",
  "fileStats": {
    "size": 33151,
    "lines": 1183,
    "lastModified": "2025-12-21T07:30:19.051Z"
  },
  "comments": []
}