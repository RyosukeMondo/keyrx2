{
  "id": "snapshot_1766302502738_pd0cf87mv",
  "approvalId": "approval_1766302502735_5jzbwvzm6",
  "approvalTitle": "Requirements for Core Configuration System",
  "version": 1,
  "timestamp": "2025-12-21T07:35:02.738Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document - Core Configuration System\n\n## Introduction\n\nThe **Core Configuration System** is the foundational component that enables users to write Rhai-based configuration scripts and compile them into deterministic, zero-copy binary files (.krx format). This system is the **critical path dependency** for all keyrx features, as it:\n\n- Defines the configuration DSL (Domain-Specific Language) for keyboard remapping\n- Establishes the binary format (.krx) used by the daemon at runtime\n- Implements the SSOT (Single Source of Truth) mechanism via deterministic serialization\n- Enables hash-based verification of configuration integrity\n- Supports modular configuration with imports (single entry point pattern)\n\nWithout this system, the daemon cannot load configurations, users cannot define remappings, and AI agents cannot verify configuration correctness programmatically.\n\n## Alignment with Product Vision\n\nThis spec directly implements multiple **\"AI Coding Agent First\"** product principles (product.md):\n\n### 1. Single Source of Truth (SSOT)\n\n**From Product Principles**:\n> \"Unified Configuration Store: All system state, configuration, and runtime parameters exist in a single, authoritative location (.krx binary format)\"\n> \"Hash-Based Verification: Configuration changes are verified via deterministic binary serialization—AI agents can confirm 'configuration A == configuration B' with a simple hash comparison\"\n\n**Key Alignments**:\n- .krx binary is the single source of truth for all remapping behavior\n- Deterministic serialization ensures same Rhai input → same binary output → same hash\n- AI agents can verify configuration changes by comparing SHA256 hashes\n- No configuration drift: daemon, UI, and tests all consume identical .krx artifact\n\n### 2. Deterministic Behavior\n\n**From Product Principles**:\n> \"Complete Determinism: Same input sequence + same configuration → identical output (bit-for-bit)\"\n\n**Key Alignments**:\n- rkyv serialization is deterministic (no randomness, stable field ordering)\n- Compiler flags ensure reproducible builds\n- Hash verification detects any non-determinism immediately\n\n### 3. CLI-First Design\n\n**From Product Principles**:\n> \"CLI-first design: Every GUI operation has a machine-readable CLI/API equivalent\"\n\n**Key Alignments**:\n- `keyrx_compiler` provides pure CLI interface (no GUI required)\n- AI agents can compile configurations programmatically\n- Machine-parseable error messages (JSON output mode)\n\n### 4. Structured Configuration DSL\n\n**From Tech Stack** (tech.md):\n> \"Rhai scripting language for configuration DSL with compile-time evaluation\"\n\n**Key Alignments**:\n- Rhai provides familiar scripting syntax (Rust-like)\n- Compile-time evaluation eliminates runtime overhead\n- Single entry point with imports enables modular configurations\n\n## Requirements\n\n### Requirement 1: Configuration Data Structures\n\n**User Story**: As a **developer**, I want **well-defined configuration data structures**, so that **the compiler and daemon can share a common understanding of configuration format**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN configuration structures are defined THEN the system SHALL create a `ConfigRoot` struct with:\n   - Version field (semantic versioning: major.minor.patch)\n   - List of device configurations (`Vec<DeviceConfig>`)\n   - Metadata (compilation timestamp, compiler version, source file hash)\n\n2. WHEN a device configuration is defined THEN the system SHALL create a `DeviceConfig` struct with:\n   - Device identifier pattern (USB VID/PID, serial number glob pattern)\n   - List of key mappings (`Vec<KeyMapping>`)\n   - Device-specific settings (optional)\n\n3. WHEN a key mapping is defined THEN the system SHALL create a `KeyMapping` enum with variants:\n   - `Simple { from: KeyCode, to: KeyCode }` - 1:1 remapping\n   - (Future variants for modifiers, tap/hold, layers - placeholders only)\n\n4. WHEN key codes are defined THEN the system SHALL create a `KeyCode` enum with:\n   - Standard keys (A-Z, 0-9, F1-F12, modifiers, etc.)\n   - At least 100 common key codes\n   - Extensible design for future additions\n\n5. WHEN structures are serialized THEN they SHALL:\n   - Derive `rkyv::Archive`, `rkyv::Serialize`, `rkyv::Deserialize`\n   - Use `#[repr(C)]` for stable memory layout\n   - Include validation constraints (via rkyv validation features)\n\n6. WHEN structures are defined THEN they SHALL:\n   - Be located in `keyrx_core/src/config.rs` (no_std compatible)\n   - Have no external dependencies except rkyv, fixedbitset, arrayvec\n   - Include comprehensive documentation with examples\n\n---\n\n### Requirement 2: Rhai DSL Parser and Evaluator\n\n**User Story**: As a **user**, I want **to write keyboard configurations in Rhai scripts**, so that **I can define remappings using a familiar scripting language**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN the Rhai engine is initialized THEN the system SHALL:\n   - Create a Rhai engine instance\n   - Register custom functions: `device()`, `map()`\n   - Configure engine for compile-time evaluation (no runtime eval)\n   - Set resource limits (max operations, max script size)\n\n2. WHEN `device()` function is called THEN the system SHALL:\n   - Accept device identifier string (e.g., \"USB\\\\VID_1234&PID_5678\\\\SERIAL_ABC\")\n   - Return a device handle object (Rhai custom type)\n   - Store device configuration in engine scope\n\n3. WHEN `map()` method is called on device THEN the system SHALL:\n   - Accept two parameters: `from` key, `to` key\n   - Create a `KeyMapping::Simple` entry\n   - Add mapping to device's key mapping list\n   - Validate key codes are valid (error if unknown)\n\n4. WHEN a Rhai script is parsed THEN the system SHALL:\n   - Read script from file or stdin\n   - Parse script into AST (Abstract Syntax Tree)\n   - Evaluate AST to generate configuration data structures\n   - Return `ConfigRoot` struct or compilation error\n\n5. WHEN import statements are encountered THEN the system SHALL:\n   - Support `import \"path/to/file.rhai\"` syntax\n   - Resolve imports relative to main script directory\n   - Prevent circular imports (error if detected)\n   - Recursively evaluate imported scripts\n   - Merge imported configurations into main config\n\n6. WHEN errors occur during parsing THEN the system SHALL:\n   - Report line number and column of error\n   - Provide clear error messages (e.g., \"Unknown key 'KeyABC' at line 10\")\n   - Exit with non-zero exit code\n   - Support `--json` flag for machine-readable errors\n\n7. WHEN the script is evaluated THEN the system SHALL:\n   - Complete in <1 second for typical configurations (<1000 lines)\n   - Limit recursion depth to prevent stack overflow\n   - Detect duplicate mappings (warn or error based on mode)\n\n---\n\n### Requirement 3: Binary Serialization with rkyv\n\n**User Story**: As a **system architect**, I want **deterministic binary serialization**, so that **the same Rhai script always produces identical binary output**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN a configuration is serialized THEN the system SHALL:\n   - Use rkyv's zero-copy serialization\n   - Produce deterministic byte output (same input → same bytes)\n   - Include magic number header (b\"KRXC\" - KeyRX Configuration)\n   - Include version field (current: 1.0.0)\n\n2. WHEN serialization is performed THEN the system SHALL:\n   - Serialize `ConfigRoot` struct to byte buffer\n   - Compute SHA256 hash of serialized bytes\n   - Embed hash in metadata section\n   - Write binary to .krx file with `.krx` extension\n\n3. WHEN the binary format is structured THEN it SHALL have:\n   - Magic number: 4 bytes (b\"KRXC\")\n   - Version: 3 bytes (major.minor.patch)\n   - Reserved: 1 byte (for future use)\n   - Hash: 32 bytes (SHA256 of payload)\n   - Payload length: 8 bytes (u64, little-endian)\n   - Payload: N bytes (rkyv-serialized ConfigRoot)\n\n4. WHEN deserialization is performed THEN the system SHALL:\n   - Verify magic number matches b\"KRXC\"\n   - Verify version compatibility (major version must match)\n   - Compute SHA256 of payload, compare with embedded hash\n   - Deserialize payload using rkyv with validation\n   - Return `ConfigRoot` or deserialization error\n\n5. WHEN validation is enabled THEN the system SHALL:\n   - Use rkyv's validation features to check:\n     - No out-of-bounds pointers\n     - No invalid enum variants\n     - No malformed strings\n   - Reject invalid binaries with clear error messages\n\n6. WHEN binary compatibility is considered THEN the system SHALL:\n   - Fail gracefully on version mismatch (error, not crash)\n   - Document breaking changes in changelog\n   - Support forward compatibility within same major version\n\n---\n\n### Requirement 4: Hash-Based Verification (SSOT Mechanism)\n\n**User Story**: As an **AI agent**, I want **to verify configuration integrity via hash comparison**, so that **I can confirm two configurations are identical without inspecting internals**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN a configuration is compiled THEN the system SHALL:\n   - Compute SHA256 hash of serialized payload\n   - Embed hash in binary file header\n   - Output hash to stdout in hex format\n   - Support `--verify` flag to check hash without recompiling\n\n2. WHEN `--verify` flag is used THEN the system SHALL:\n   - Read .krx file\n   - Extract embedded hash from header\n   - Recompute SHA256 of payload\n   - Compare hashes, output result: \"VALID\" or \"CORRUPTED\"\n   - Exit with code 0 if valid, 1 if corrupted\n\n3. WHEN deterministic compilation is required THEN the system SHALL:\n   - Sort all collections before serialization (devices, mappings)\n   - Use stable field ordering (defined by struct order)\n   - Exclude non-deterministic metadata (timestamp optional, disabled by default)\n   - Document reproducible build flags\n\n4. WHEN hashes are compared THEN AI agents SHALL be able to:\n   - Run: `keyrx_compiler main.rhai -o config1.krx`\n   - Run: `keyrx_compiler main.rhai -o config2.krx`\n   - Verify: `diff <(xxd config1.krx) <(xxd config2.krx)` (no differences)\n   - Extract hash: `keyrx_compiler --hash config1.krx` → \"abc123...\"\n\n5. WHEN configurations differ THEN the system SHALL:\n   - Produce different hashes\n   - Enable AI agents to detect configuration drift\n   - Support `--diff` mode (future: show what changed)\n\n---\n\n### Requirement 5: CLI Compiler Interface\n\n**User Story**: As a **user or AI agent**, I want **a command-line compiler**, so that **I can compile Rhai scripts to binary without a GUI**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN the compiler is invoked THEN it SHALL support:\n   - Input: Rhai script file path (required argument)\n   - Output: .krx file path (via `-o` or `--output` flag)\n   - Default output: `<input_name>.krx` if `-o` not specified\n\n2. WHEN the compiler runs THEN it SHALL:\n   - Parse Rhai script\n   - Evaluate to ConfigRoot\n   - Serialize to binary\n   - Write .krx file\n   - Output success message with hash\n\n3. WHEN the compiler succeeds THEN it SHALL:\n   - Exit with code 0\n   - Output: \"Compiled successfully: <output_path>\"\n   - Output: \"SHA256: <hash_hex>\"\n   - Support `--quiet` flag to suppress output\n   - Support `--json` flag for machine-readable output\n\n4. WHEN the compiler fails THEN it SHALL:\n   - Exit with code 1\n   - Output error message to stderr\n   - Include line/column information for parse errors\n   - Support `--json` flag for structured error output\n\n5. WHEN additional flags are provided THEN the compiler SHALL support:\n   - `--verify <file.krx>`: Verify hash without recompiling\n   - `--hash <file.krx>`: Extract and print hash only\n   - `--parse-only`: Parse script without compiling (syntax check)\n   - `--verbose`: Enable debug logging\n   - `--help`: Show usage information\n   - `--version`: Show compiler version\n\n6. WHEN the compiler is used THEN it SHALL:\n   - Be located at `keyrx_compiler/src/main.rs`\n   - Use `clap` crate with derive macros for CLI parsing\n   - Follow UNIX conventions (exit codes, stderr for errors, stdout for output)\n\n---\n\n### Requirement 6: Import System (Modular Configuration)\n\n**User Story**: As a **user**, I want **to split configurations across multiple files**, so that **I can organize complex configurations modularly**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN import syntax is used THEN it SHALL follow:\n   - Syntax: `import \"path/to/file.rhai\";`\n   - Paths are relative to importing file's directory\n   - Paths use forward slashes (cross-platform)\n   - File extension `.rhai` is required\n\n2. WHEN imports are resolved THEN the system SHALL:\n   - Find imported file on filesystem\n   - Read and parse imported file\n   - Evaluate imported script in same engine scope\n   - Merge imported device configurations\n   - Continue with main script\n\n3. WHEN circular imports are detected THEN the system SHALL:\n   - Track import chain (A imports B imports A)\n   - Detect cycles using visited set\n   - Error with message: \"Circular import detected: A → B → A\"\n   - Exit with code 1\n\n4. WHEN imports fail THEN the system SHALL:\n   - Error if imported file not found\n   - Error if imported file has syntax errors\n   - Include import chain in error message (e.g., \"In main.rhai → devices/left.rhai → line 5\")\n\n5. WHEN conditional imports are used THEN the system SHALL support:\n   - Rhai `if` statements to conditionally import\n   - Example: `if device_exists(\"USB\\\\VID_1234\") { import \"gaming.rhai\"; }`\n   - Note: `device_exists()` implemented in Requirement 7 (future)\n\n6. WHEN import resolution is performed THEN it SHALL:\n   - Complete in <1 second for deep import trees (<10 levels)\n   - Support up to 100 total imported files\n   - Cache parsed ASTs to avoid re-parsing same file\n\n---\n\n### Requirement 7: Error Handling and Validation\n\n**User Story**: As a **user or AI agent**, I want **clear error messages**, so that **I can fix configuration issues quickly**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN syntax errors occur THEN the system SHALL:\n   - Report exact line and column number\n   - Show snippet of offending code\n   - Suggest fix if possible (e.g., \"Did you mean 'Key::A'?\")\n   - Example: \"Error at line 10, column 5: Unexpected token '}'\"\n\n2. WHEN semantic errors occur THEN the system SHALL report:\n   - Unknown key codes: \"Unknown key 'KeyABC' at line 15\"\n   - Duplicate mappings: \"Key::A already mapped at line 10, duplicate at line 20\"\n   - Invalid device identifiers: \"Device identifier must match pattern 'USB\\\\...'\"\n\n3. WHEN validation errors occur THEN the system SHALL:\n   - Validate during deserialization (rkyv validation)\n   - Reject corrupted binaries with message: \"Binary validation failed: invalid pointer\"\n   - Reject version mismatches: \"Incompatible version: expected 1.x.x, got 2.0.0\"\n\n4. WHEN errors are output THEN the system SHALL:\n   - Use structured format in `--json` mode:\n     ```json\n     {\n       \"error\": \"syntax_error\",\n       \"message\": \"Unexpected token '}'\",\n       \"location\": {\"file\": \"main.rhai\", \"line\": 10, \"column\": 5},\n       \"snippet\": \"    map(Key::A, Key::B)}\\n                       ^\"\n     }\n     ```\n   - Use human-readable format in normal mode (colored output)\n\n5. WHEN warnings are generated THEN the system SHALL:\n   - Warn on duplicate mappings (configurable: warn vs error)\n   - Warn on unused imports\n   - Warn on deprecated syntax\n   - Support `--warn-as-error` flag\n\n---\n\n### Requirement 8: Testing and Verification\n\n**User Story**: As a **developer**, I want **comprehensive tests**, so that **the configuration system is reliable and correct**.\n\n#### Acceptance Criteria (EARS)\n\n1. WHEN unit tests are written THEN they SHALL cover:\n   - Configuration data structure serialization/deserialization\n   - Rhai parser and evaluator (parsing valid and invalid scripts)\n   - Import resolution (single file, multi-file, circular detection)\n   - Hash computation and verification\n   - Error handling (all error paths)\n\n2. WHEN integration tests are written THEN they SHALL:\n   - Compile sample Rhai scripts to .krx\n   - Deserialize .krx and verify contents match expected\n   - Test end-to-end: Rhai → binary → deserialize → verify\n   - Test CLI interface with various flags\n\n3. WHEN property-based tests are written THEN they SHALL:\n   - Use `proptest` to generate random configurations\n   - Verify: serialize(config) → deserialize → same config\n   - Verify: hash(serialize(config)) is deterministic (run 1000 times)\n\n4. WHEN regression tests are created THEN they SHALL:\n   - Include sample configurations from documentation\n   - Verify compilation succeeds for valid configs\n   - Verify errors for invalid configs\n   - Prevent breaking changes to .krx format\n\n5. WHEN tests are run THEN they SHALL:\n   - Pass on all platforms (Linux, Windows, macOS)\n   - Complete in <10 seconds (unit + integration)\n   - Achieve ≥90% code coverage for core config module\n\n---\n\n## Non-Functional Requirements\n\n### Performance\n\n- **Compilation Time**: <1 second for typical configurations (<1000 lines)\n- **Serialization Time**: <100ms for large configurations (10K mappings)\n- **Deserialization Time**: <10ms for typical .krx files (<100KB)\n- **Binary Size**: <50KB for typical configurations, <500KB for large configs\n- **Memory Usage**: <50MB during compilation\n\n### Reliability\n\n- **Determinism**: 100% - same input always produces same output (byte-for-byte)\n- **Hash Collisions**: SHA256 provides 2^256 security (no practical collisions)\n- **Crash Resistance**: Compiler never crashes on invalid input (always returns error)\n- **Validation**: rkyv validation prevents deserialization of corrupted binaries\n\n### Usability (for AI Agents)\n\n- **Machine-Parseable Errors**: JSON output mode for all errors\n- **Structured Output**: Hash values, file paths, exit codes are programmatically accessible\n- **Deterministic Failures**: Same invalid input → same error message\n- **No Interactive Prompts**: Compiler never prompts for input (fully automatable)\n\n### Security\n\n- **No Code Execution**: Rhai engine disables dangerous features (file I/O, network, system calls)\n- **Resource Limits**: Max script size (10MB), max operations (1M), max recursion (100)\n- **Input Validation**: All user input validated before use\n- **No Secrets in Binaries**: Configuration contains only key mappings (no passwords, API keys)\n\n### Compatibility\n\n- **Rust Version**: Minimum Rust 1.70 (stable channel)\n- **no_std Support**: `keyrx_core/src/config.rs` compiles without std library\n- **Cross-Platform**: Compiler runs on Linux, Windows, macOS\n- **Forward Compatibility**: Minor version updates (1.x → 1.y) are binary-compatible\n- **Breaking Changes**: Major version updates (1.x → 2.0) may break compatibility\n\n---\n\n## Example Configurations\n\n### Example 1: Simple Remapping\n\n```rhai\n// main.rhai - Simple CapsLock → Escape remapping\n\nlet kbd = device(\"USB\\\\VID_1234&PID_5678\\\\SERIAL_ABC\");\n\nkbd.map(Key::CapsLock, Key::Escape);\nkbd.map(Key::A, Key::B);  // A → B\n```\n\n**Expected Output**:\n```bash\n$ keyrx_compiler main.rhai -o simple.krx\nCompiled successfully: simple.krx\nSHA256: a1b2c3d4...\n```\n\n### Example 2: Multi-Device Configuration\n\n```rhai\n// main.rhai - Two keyboards with different mappings\n\nlet left_kbd = device(\"USB\\\\VID_AAAA&PID_1111\\\\SERIAL_LEFT\");\nlet right_kbd = device(\"USB\\\\VID_BBBB&PID_2222\\\\SERIAL_RIGHT\");\n\n// Left keyboard\nleft_kbd.map(Key::A, Key::B);\n\n// Right keyboard\nright_kbd.map(Key::A, Key::C);\n```\n\n### Example 3: Modular Configuration with Imports\n\n```rhai\n// main.rhai - Entry point with imports\n\nimport \"devices/left_hand.rhai\";\nimport \"devices/right_hand.rhai\";\n```\n\n```rhai\n// devices/left_hand.rhai\n\nlet left = device(\"USB\\\\VID_AAAA&PID_1111\\\\SERIAL_LEFT\");\nleft.map(Key::CapsLock, Key::Escape);\n```\n\n```rhai\n// devices/right_hand.rhai\n\nlet right = device(\"USB\\\\VID_BBBB&PID_2222\\\\SERIAL_RIGHT\");\nright.map(Key::A, Key::B);\n```\n\n### Example 4: Error Handling\n\n**Invalid Script** (unknown key):\n```rhai\nlet kbd = device(\"USB\\\\VID_1234&PID_5678\\\\SERIAL_ABC\");\nkbd.map(Key::InvalidKey, Key::A);  // Error: Unknown key\n```\n\n**Expected Error**:\n```\nError at line 2, column 9: Unknown key 'Key::InvalidKey'\nValid keys: Key::A, Key::B, ..., Key::CapsLock, ...\n```\n\n**Machine-Readable Error** (`--json` flag):\n```json\n{\n  \"error\": \"unknown_key\",\n  \"message\": \"Unknown key 'Key::InvalidKey'\",\n  \"location\": {\"file\": \"main.rhai\", \"line\": 2, \"column\": 9},\n  \"suggestions\": [\"Key::Escape\", \"Key::Insert\", \"Key::Delete\"]\n}\n```\n\n---\n\n## Success Criteria\n\nThe Core Configuration System is considered complete when:\n\n1. ✅ **Compilation Works**: Users can write Rhai scripts and compile to .krx binaries\n2. ✅ **Determinism Verified**: Same Rhai input produces identical .krx output (verified via hash)\n3. ✅ **Deserialization Works**: Daemon can load .krx files and access configuration data\n4. ✅ **Imports Work**: Multi-file configurations compile correctly with import resolution\n5. ✅ **Error Handling**: All error paths tested, clear messages for common mistakes\n6. ✅ **Testing Complete**: ≥90% code coverage, all tests pass\n7. ✅ **Documentation Complete**: CLAUDE.md updated with DSL syntax and examples\n8. ✅ **AI-Verifiable**: AI agents can compile, verify, and validate configurations programmatically\n\n---\n\n## Out of Scope (Future Work)\n\nThe following features are **NOT** included in this spec (deferred to future specs):\n\n- ❌ **Advanced Mappings**: Tap/Hold, layers, combos (requires DFA state machine)\n- ❌ **255 Modifiers**: Extended modifier support (requires extended-modifiers spec)\n- ❌ **Conditional Logic**: `if` statements based on device state (requires runtime evaluation)\n- ❌ **MPHF Optimization**: O(1) lookup tables (requires mphf-key-lookup spec)\n- ❌ **Hot Reload**: Live configuration updates without daemon restart\n- ❌ **Configuration Validation Tool**: Separate tool to lint/validate configs\n- ❌ **IDE Integration**: VSCode extension for Rhai syntax highlighting\n\nThese will be addressed in subsequent specs once the core system is stable.\n",
  "fileStats": {
    "size": 21873,
    "lines": 554,
    "lastModified": "2025-12-21T07:27:30.702Z"
  },
  "comments": []
}