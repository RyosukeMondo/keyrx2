{
  "id": "snapshot_1766303817011_hppoi39qg",
  "approvalId": "approval_1766302502735_5jzbwvzm6",
  "approvalTitle": "Requirements for Core Configuration System",
  "version": 2,
  "timestamp": "2025-12-21T07:56:57.011Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe Core Configuration System provides the foundational infrastructure for keyrx's configuration management. It enables users to write Rhai-based configuration scripts and compile them into deterministic, zero-copy binary files (.krx format). This system is the critical path dependency for all keyrx features, as it defines how configurations are authored, compiled, and consumed by the daemon.\n\n## Alignment with Product Vision\n\nThis spec implements the **\"AI Coding Agent First\"** product principles (product.md):\n\n**Single Source of Truth (SSOT)**:\n- .krx binary is the single authoritative source for all remapping behavior\n- Deterministic serialization ensures same Rhai input → same binary output → same hash\n- AI agents can verify configuration changes via SHA256 hash comparison\n\n**CLI-First Design**:\n- `keyrx_compiler` provides pure CLI interface (no GUI required)\n- AI agents can compile configurations programmatically\n- Machine-parseable error messages with JSON output mode\n\n**Deterministic Behavior**:\n- rkyv serialization is deterministic (stable field ordering, no randomness)\n- Hash verification detects any non-determinism immediately\n- Same input configuration always produces identical binary output\n\n## Requirements\n\n### Requirement 1: Configuration Data Structures\n\n**User Story:** As a **developer**, I want **well-defined configuration data structures**, so that **the compiler and daemon share a common understanding of configuration format**.\n\n#### Acceptance Criteria\n\n1. WHEN configuration structures are defined THEN the system SHALL create a `ConfigRoot` struct with version field (semantic versioning), list of device configurations, and metadata (compilation timestamp, compiler version, source file hash)\n\n2. WHEN a device configuration is defined THEN the system SHALL create a `DeviceConfig` struct with device identifier pattern and list of key mappings\n\n3. WHEN a key mapping is defined THEN the system SHALL create a `KeyMapping` enum with `Simple { from: KeyCode, to: KeyCode }` variant for 1:1 remapping\n\n4. WHEN key codes are defined THEN the system SHALL create a `KeyCode` enum with at least 100 common key codes (A-Z, 0-9, F1-F12, modifiers, special keys)\n\n5. WHEN structures are serialized THEN they SHALL derive `rkyv::Archive`, `rkyv::Serialize`, `rkyv::Deserialize` with `#[repr(C)]` for stable memory layout\n\n6. WHEN structures are defined THEN they SHALL be located in `keyrx_core/src/config.rs` with no_std compatibility\n\n### Requirement 2: Rhai DSL Parser and Evaluator\n\n**User Story:** As a **user**, I want **a simple DSL for defining keyboard remappings**, so that **I can write configurations without learning complex syntax**.\n\n#### Acceptance Criteria\n\n1. WHEN the Rhai parser is initialized THEN the system SHALL create a Rhai engine with custom functions `device(pattern)` and `map(from, to)` registered\n\n2. WHEN a Rhai script calls `device(pattern)` THEN the system SHALL create a new `DeviceConfig` with the specified identifier pattern and push it to the configuration root\n\n3. WHEN a Rhai script calls `map(from, to)` THEN the system SHALL create a `KeyMapping::Simple` and add it to the current device configuration\n\n4. WHEN the parser evaluates a script THEN it SHALL enforce resource limits: max 10,000 operations, max 100 recursion depth, 10-second timeout\n\n5. WHEN a Rhai script has syntax errors THEN the system SHALL produce user-friendly error messages with line numbers, column positions, and \"did you mean\" suggestions\n\n6. WHEN the parser completes THEN it SHALL return a fully populated `ConfigRoot` struct ready for serialization\n\n### Requirement 3: Binary Serialization and Deserialization\n\n**User Story:** As a **developer**, I want **deterministic binary serialization**, so that **configurations can be verified via hash comparison**.\n\n#### Acceptance Criteria\n\n1. WHEN a `ConfigRoot` is serialized THEN the system SHALL use rkyv to produce a binary format with 48-byte header (magic bytes, version, hash, size)\n\n2. WHEN serialization completes THEN the system SHALL compute SHA256 hash of the serialized data and embed it in the header\n\n3. WHEN the same `ConfigRoot` is serialized multiple times THEN the system SHALL produce bit-identical output (deterministic serialization)\n\n4. WHEN a .krx file is deserialized THEN the system SHALL verify the magic bytes (0x4B52580A), version compatibility, and SHA256 hash\n\n5. WHEN hash verification fails THEN the system SHALL reject the file with error message indicating corruption or tampering\n\n6. WHEN deserialization succeeds THEN the system SHALL provide zero-copy access to the configuration (no heap allocation)\n\n### Requirement 4: Import System\n\n**User Story:** As a **user**, I want **to split configurations across multiple files**, so that **I can organize complex configurations modularly**.\n\n#### Acceptance Criteria\n\n1. WHEN a Rhai script uses `import \"path/to/file.rhai\"` THEN the system SHALL resolve the path relative to the current file's directory\n\n2. WHEN imports are resolved THEN the system SHALL recursively load and evaluate imported files before continuing with the parent script\n\n3. WHEN circular imports are detected THEN the system SHALL abort with error message showing the import cycle chain\n\n4. WHEN an imported file is not found THEN the system SHALL report error with searched paths and suggestions\n\n5. WHEN imports are successful THEN all imported device configurations SHALL be merged into the root configuration\n\n### Requirement 5: CLI Compiler Interface\n\n**User Story:** As a **user**, I want **a command-line compiler**, so that **I can compile configurations from scripts or CI/CD pipelines**.\n\n#### Acceptance Criteria\n\n1. WHEN `keyrx_compiler compile input.rhai -o output.krx` is executed THEN the system SHALL parse the Rhai script, serialize it, and write the .krx file\n\n2. WHEN `keyrx_compiler verify config.krx` is executed THEN the system SHALL validate the binary format and hash, reporting success or specific errors\n\n3. WHEN `keyrx_compiler hash config.krx` is executed THEN the system SHALL output the SHA256 hash in hexadecimal format\n\n4. WHEN `keyrx_compiler parse input.rhai --json` is executed THEN the system SHALL parse the script and output the configuration as JSON (for debugging)\n\n5. WHEN any command fails THEN the system SHALL exit with non-zero exit code and output structured error messages\n\n6. WHEN `--help` flag is used THEN the system SHALL display usage information for all commands and flags\n\n### Requirement 6: Error Handling and Validation\n\n**User Story:** As a **user**, I want **clear error messages**, so that **I can quickly fix configuration mistakes**.\n\n#### Acceptance Criteria\n\n1. WHEN errors occur THEN the system SHALL use structured error types with error codes, context, and actionable suggestions\n\n2. WHEN Rhai syntax errors occur THEN error messages SHALL include file path, line number, column number, and snippet of problematic code\n\n3. WHEN validation fails THEN error messages SHALL explain what was expected vs what was found\n\n4. WHEN `--json` flag is used THEN errors SHALL be formatted as JSON with fields: error_code, message, file, line, column, suggestion\n\n5. WHEN multiple errors are present THEN the system SHALL report all errors (not just the first one)\n\n### Requirement 7: Testing and Verification\n\n**User Story:** As a **developer**, I want **comprehensive tests**, so that **the configuration system is reliable and correct**.\n\n#### Acceptance Criteria\n\n1. WHEN tests are implemented THEN they SHALL achieve at least 90% code coverage for the config system\n\n2. WHEN unit tests are run THEN they SHALL test each component in isolation: parser, serializer, import resolver, CLI\n\n3. WHEN integration tests are run THEN they SHALL test end-to-end workflows: Rhai script → .krx binary → verification\n\n4. WHEN property-based tests are run THEN they SHALL verify deterministic serialization: serialize(x) == serialize(x) for all valid configurations\n\n5. WHEN fuzz tests are run THEN they SHALL test parser robustness with randomly generated Rhai scripts for at least 60 seconds\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: Each module handles one concern (parsing, serialization, import resolution)\n- **Modular Design**: Components are isolated and reusable (core structs in keyrx_core, compiler logic in keyrx_compiler)\n- **Dependency Management**: keyrx_core is no_std with minimal dependencies (rkyv, fixedbitset, arrayvec)\n- **Clear Interfaces**: Public APIs are well-documented with examples\n\n### Performance\n- **Compilation Time**: Compile 1000-line configuration in <100ms\n- **Serialization Time**: Serialize typical configuration in <10ms\n- **Deserialization Time**: Deserialize .krx file in <5ms (zero-copy)\n- **Binary Size**: .krx files <10KB for typical configurations (100 mappings)\n\n### Security\n- **Resource Limits**: Parser enforces operation limits, recursion limits, and timeouts to prevent DoS\n- **Hash Verification**: SHA256 hashing prevents tampering with .krx files\n- **Input Validation**: All user inputs are validated before processing\n- **No Code Execution**: Daemon never executes Rhai scripts (only loads pre-compiled .krx)\n\n### Reliability\n- **Deterministic Output**: Same input always produces identical output (bit-for-bit)\n- **Validation**: All .krx files are validated before use (magic bytes, version, hash)\n- **Error Recovery**: Parser recovers from syntax errors and reports all errors\n- **No Panics**: All error conditions are handled gracefully with Result types\n\n### Usability\n- **Clear Syntax**: Rhai DSL is simple and intuitive (device/map API)\n- **Helpful Errors**: Error messages include context, suggestions, and examples\n- **JSON Output**: All commands support --json for machine parsing\n- **Comprehensive Help**: --help flag provides usage examples for all commands\n",
  "fileStats": {
    "size": 9943,
    "lines": 179,
    "lastModified": "2025-12-21T07:51:32.207Z"
  },
  "comments": []
}