{
  "id": "snapshot_1766587806662_e9lln1hoh",
  "approvalId": "approval_1766302502878_fep04k2j3",
  "approvalTitle": "Tasks for Core Configuration System",
  "version": 2,
  "timestamp": "2025-12-24T14:50:06.662Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks Document\n\n- [x] 1. Define Version struct in keyrx_core/src/config.rs\n  - File: keyrx_core/src/config.rs\n  - Create Version struct with major, minor, patch fields (u8 types)\n  - Derive rkyv traits: Archive, Serialize, Deserialize\n  - Add #[repr(C)] for stable binary layout\n  - Implement Version::current() -> Version returning 1.0.0\n  - Implement Display trait for version formatting\n  - Purpose: Version information for binary compatibility checking\n  - _Leverage: tech.md specifications for rkyv usage_\n  - _Requirements: 1.1_\n  - _Prompt: Role: Rust Systems Programmer with expertise in binary serialization and versioning | Task: Define Version struct in keyrx_core/src/config.rs following requirement 1.1, using rkyv traits and #[repr(C)] for stable binary layout | Restrictions: Must use u8 for all version fields, derive all required rkyv traits, implement current() to return Version { major: 1, minor: 0, patch: 0 } | Success: Struct compiles, derives rkyv traits correctly, Display trait shows \"1.0.0\" format, current() returns correct version_\n\n- [x] 2. Define KeyCode enum with 100+ key codes\n  - File: keyrx_core/src/config.rs (same file as task 1)\n  - Create KeyCode enum with #[repr(u16)]\n  - Define all standard keys: A-Z (0x00-0x19), 0-9 (0x20-0x29), F1-F12 (0x30-0x3B)\n  - Define modifiers: LShift, RShift, LCtrl, RCtrl, LAlt, RAlt, LMeta, RMeta (0x100-0x107)\n  - Define special keys: Escape, Enter, Backspace, Tab, Space, CapsLock, etc. (0x200+)\n  - Define arrow keys: Left, Right, Up, Down (0x210-0x213)\n  - Derive: Archive, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, Hash, Debug\n  - Explicitly number all variants to prevent reordering issues\n  - Purpose: Complete keyboard key code enumeration (platform-agnostic)\n  - _Leverage: design.md KeyCode enum specification_\n  - _Requirements: 1.5_\n  - _Prompt: Role: Input Systems Engineer with expertise in keyboard scancode mappings | Task: Define comprehensive KeyCode enum in keyrx_core/src/config.rs with 100+ keys following requirement 1.5 and design.md specifications | Restrictions: Must use #[repr(u16)], explicitly number all variants, cover all standard keyboard keys, derive all required traits, organize keys by category (letters, numbers, modifiers, special) | Success: Enum compiles with all traits, includes A-Z, 0-9, F1-F12, modifiers, special keys, arrows, all variants have explicit numbers_\n\n- [x] 3. Define Condition enum with 4 variants\n  - File: keyrx_core/src/config.rs (same file as tasks 1-2)\n  - Create Condition enum with #[repr(C)]\n  - Define ModifierActive(u8) variant - single custom modifier active (MD_XX)\n  - Define LockActive(u8) variant - single custom lock active (LK_XX)\n  - Define AllActive(Vec<ConditionItem>) variant - all conditions must be true (AND logic)\n  - Define NotActive(Box<Condition>) variant - negated condition (when_not)\n  - Create ConditionItem enum with ModifierActive(u8) and LockActive(u8) variants for AllActive\n  - Derive: Archive, Serialize, Deserialize, Clone, PartialEq, Eq, Debug\n  - Purpose: Conditional mapping support (when/when_not blocks)\n  - _Leverage: design.md Condition specification_\n  - _Requirements: 1.4_\n  - _Prompt: Role: Rust Developer with expertise in enum design and binary serialization | Task: Define Condition enum with 4 variants in keyrx_core/src/config.rs following requirement 1.4 | Restrictions: Must use #[repr(C)], include all 4 variants, support both single conditions and AND logic, derive all required rkyv traits | Success: Enum compiles, all variants work correctly, serialization works, supports nested conditions_\n\n- [x] 4. Define KeyMapping enum with 6 variants\n  - File: keyrx_core/src/config.rs (same file as tasks 1-3)\n  - Create KeyMapping enum with #[repr(C)]\n  - Define Simple variant: { from: KeyCode, to: KeyCode } - 1:1 remapping\n  - Define Modifier variant: { from: KeyCode, modifier_id: u8 } - key acts as custom modifier (MD_00-MD_FE)\n  - Define Lock variant: { from: KeyCode, lock_id: u8 } - key toggles custom lock (LK_00-LK_FE)\n  - Define TapHold variant: { from: KeyCode, tap: KeyCode, hold_modifier: u8, threshold_ms: u16 } - dual tap/hold behavior\n  - Define ModifiedOutput variant: { from: KeyCode, to: KeyCode, shift: bool, ctrl: bool, alt: bool, win: bool } - output with physical modifiers\n  - Define Conditional variant: { condition: Condition, mappings: Vec<KeyMapping> } - conditional mappings (when/when_not)\n  - Derive: Archive, Serialize, Deserialize, Clone, PartialEq, Eq, Debug\n  - Purpose: Enumeration of all mapping types\n  - _Leverage: design.md KeyMapping specification_\n  - _Requirements: 1.3_\n  - _Prompt: Role: Rust Developer with expertise in enum design and binary serialization | Task: Define KeyMapping enum with all 6 variants in keyrx_core/src/config.rs following requirement 1.3 | Restrictions: Must use #[repr(C)], include all 6 variants exactly as specified, derive all required rkyv traits | Success: Enum compiles, all variants work with correct field types, serialization works, supports nested mappings_\n\n- [x] 5. Define DeviceIdentifier and DeviceConfig structs\n  - File: keyrx_core/src/config.rs (same file as tasks 1-4)\n  - Create DeviceIdentifier struct with pattern field (String)\n  - Create DeviceConfig struct with identifier (DeviceIdentifier) and mappings (Vec<KeyMapping>)\n  - Add #[repr(C)] to both structs\n  - Derive rkyv traits: Archive, Serialize, Deserialize\n  - Add documentation explaining device identifier pattern format\n  - Purpose: Device-specific configuration storage\n  - _Leverage: design.md DeviceConfig specification_\n  - _Requirements: 1.2_\n  - _Prompt: Role: Rust Developer with expertise in data modeling and serialization | Task: Define DeviceIdentifier and DeviceConfig structs in keyrx_core/src/config.rs following requirement 1.2 | Restrictions: Must use #[repr(C)], derive all rkyv traits, DeviceIdentifier contains String pattern, DeviceConfig contains identifier and Vec<KeyMapping> | Success: Both structs compile correctly, rkyv traits work, DeviceConfig can store multiple mappings_\n\n- [x] 6. Define Metadata and ConfigRoot structs\n  - File: keyrx_core/src/config.rs (same file as tasks 1-5)\n  - Create Metadata struct with compilation_timestamp (u64), compiler_version (String), source_hash (String)\n  - Create ConfigRoot struct with version (Version), devices (Vec<DeviceConfig>), metadata (Metadata)\n  - Add #[repr(C)] to both structs\n  - Derive rkyv traits: Archive, Serialize, Deserialize\n  - Purpose: Root configuration structure\n  - _Leverage: design.md ConfigRoot specification_\n  - _Requirements: 1.1_\n  - _Prompt: Role: Rust Systems Programmer with expertise in data structures and serialization | Task: Define Metadata and ConfigRoot structs in keyrx_core/src/config.rs following requirement 1.1 | Restrictions: Must use #[repr(C)], derive all rkyv traits, ConfigRoot is the top-level structure containing all config data | Success: Structs compile, rkyv serialization works, ConfigRoot can be serialized and deserialized_\n\n- [x] 7. Write unit tests for config data structures\n  - File: keyrx_core/src/config.rs (add #[cfg(test)] mod tests at end)\n  - Test Version::current() returns 1.0.0\n  - Test Version Display formatting\n  - Test KeyCode has all expected variants\n  - Test all 6 KeyMapping variants can be created\n  - Test all 4 Condition variants can be created\n  - Test DeviceConfig creation with mappings\n  - Test ConfigRoot serialization/deserialization round-trip\n  - Test deterministic serialization (same struct → same bytes)\n  - Purpose: Verify all data structures work correctly\n  - _Leverage: ai-dev-foundation test patterns_\n  - _Requirements: 7.1, 7.2_\n  - _Prompt: Role: Rust Test Engineer with expertise in unit testing and property-based testing | Task: Write comprehensive unit tests for all config data structures in keyrx_core/src/config.rs following requirements 7.1 and 7.2 | Restrictions: Must test all structs/enums, verify rkyv serialization round-trips, test determinism, use #[cfg(test)] module | Success: All tests pass, coverage >90% for config.rs, deterministic serialization verified_\n\n- [x] 8. Create error types module\n  - File: keyrx_compiler/src/error.rs\n  - Define ParseError enum with variants:\n    - SyntaxError { file, line, column, message }\n    - InvalidPrefix { expected, got, context }\n    - ModifierIdOutOfRange { got, max }\n    - LockIdOutOfRange { got, max }\n    - PhysicalModifierInMD { name }\n    - MissingPrefix { key, context }\n    - ImportNotFound { path, searched_paths }\n    - CircularImport { chain }\n    - ResourceLimitExceeded { limit_type }\n  - Define SerializeError enum with variants: RkyvError, IoError\n  - Define DeserializeError enum with variants: InvalidMagic, VersionMismatch, HashMismatch, RkyvError\n  - Implement Display and std::error::Error traits for all error types\n  - Add context fields (file path, line, column) to ParseError variants\n  - Purpose: Structured error handling for compiler with prefix validation errors\n  - _Leverage: Rust error handling patterns from tech.md_\n  - _Requirements: 6.1, 6.2, 6.3_\n  - _Prompt: Role: Rust Developer with expertise in error handling and type design | Task: Create comprehensive error types in keyrx_compiler/src/error.rs following requirements 6.1-6.3 with prefix validation errors | Restrictions: Must define all error enums with proper context fields, implement Display and Error traits, errors must be actionable for users, include all prefix validation error variants | Success: Error types compile, Display shows user-friendly messages with examples, all error scenarios covered including prefix validation_\n\n- [x] 9. Implement prefix validation helper functions\n  - File: keyrx_compiler/src/parser.rs (create file, these will be used by task 13)\n  - Implement parse_virtual_key(s: &str) -> Result<KeyCode, ParseError>\n    - Validates VK_ prefix, parses key name\n  - Implement parse_modifier_id(s: &str) -> Result<u8, ParseError>\n    - Validates MD_ prefix, rejects physical modifier names (e.g., MD_LShift)\n    - Parses hex ID (00-FE), validates range\n  - Implement parse_lock_id(s: &str) -> Result<u8, ParseError>\n    - Validates LK_ prefix, parses hex ID (00-FE), validates range\n  - Implement parse_condition_string(s: &str) -> Result<Condition, ParseError>\n    - Parses MD_XX or LK_XX into Condition variant\n  - All functions return descriptive ParseError variants on failure\n  - Purpose: Centralized prefix validation logic\n  - _Leverage: error.rs for ParseError types_\n  - _Requirements: 2.2, 2.3, 6.3_\n  - _Prompt: Role: Rust Developer with expertise in parsing and validation | Task: Implement prefix validation helper functions in keyrx_compiler/src/parser.rs following requirements 2.2, 2.3, and 6.3 | Restrictions: Must validate all prefixes (VK_, MD_, LK_), reject invalid formats, reject physical modifier names in MD_, validate hex ranges 00-FE, return clear ParseError variants | Success: All validation functions work correctly, reject invalid inputs with clear errors, accept all valid inputs_\n\n- [x] 10. Write unit tests for prefix validation functions\n  - File: keyrx_compiler/src/parser.rs (add #[cfg(test)] mod prefix_tests)\n  - Test parse_virtual_key accepts \"VK_A\", \"VK_Enter\", etc.\n  - Test parse_virtual_key rejects \"A\" (missing prefix)\n  - Test parse_modifier_id accepts \"MD_00\", \"MD_FE\"\n  - Test parse_modifier_id rejects \"MD_LShift\", \"MD_Ctrl\" (physical names)\n  - Test parse_modifier_id rejects \"MD_100\" (out of range)\n  - Test parse_modifier_id rejects \"MD_FF\" (out of range, max is FE)\n  - Test parse_lock_id accepts \"LK_00\", \"LK_FE\"\n  - Test parse_lock_id rejects \"LK_FF\" (out of range)\n  - Test parse_condition_string handles both MD_ and LK_ prefixes\n  - Purpose: Verify prefix validation correctness\n  - _Leverage: ai-dev-foundation test patterns_\n  - _Requirements: 7.2_\n  - _Prompt: Role: Rust Test Engineer with expertise in validation testing | Task: Write comprehensive unit tests for prefix validation functions following requirement 7.2 | Restrictions: Must test all valid and invalid cases, verify error messages, use #[cfg(test)] module | Success: All tests pass, coverage >90%, all validation edge cases tested_\n\n- [x] 11. Implement import resolver module\n  - File: keyrx_compiler/src/import_resolver.rs\n  - Create ImportResolver struct with visited_files (HashSet<PathBuf>) field\n  - Implement resolve_imports(path: &Path) -> Result<Vec<PathBuf>, ParseError>\n  - Implement detect_circular_imports(chain: &[PathBuf]) -> Result<(), ParseError>\n  - Resolve paths relative to current file's directory\n  - Detect circular imports using visited_files tracking\n  - Purpose: Handle multi-file configuration imports\n  - _Leverage: error.rs for ParseError types_\n  - _Requirements: 4.1, 4.2, 4.3_\n  - _Prompt: Role: Rust Developer with expertise in file I/O and graph algorithms | Task: Implement import resolver in keyrx_compiler/src/import_resolver.rs following requirements 4.1-4.3 | Restrictions: Must detect circular imports, resolve relative paths correctly, return ParseError on failures, use HashSet for cycle detection | Success: Resolver handles recursive imports, detects cycles, resolves paths correctly, all error cases covered_\n\n- [x] 12. Write unit tests for import resolver\n  - File: keyrx_compiler/src/import_resolver.rs (add #[cfg(test)] mod tests)\n  - Test simple import resolution\n  - Test recursive imports (3+ levels deep)\n  - Test circular import detection (A→B→C→A)\n  - Test file not found error\n  - Test relative path resolution\n  - Purpose: Verify import system correctness\n  - _Leverage: ai-dev-foundation test patterns_\n  - _Requirements: 7.2_\n  - _Prompt: Role: Rust Test Engineer with expertise in unit testing and file system testing | Task: Write comprehensive unit tests for import resolver following requirement 7.2 | Restrictions: Must test all import scenarios, use temporary files for testing, verify error messages, use #[cfg(test)] module | Success: All tests pass, coverage >90%, all import scenarios verified_\n\n- [x] 13. Implement Rhai DSL parser with all custom functions\n  - File: keyrx_compiler/src/parser.rs (extend from task 9)\n  - Create Parser struct with engine (rhai::Engine) and current_config (ConfigRoot) fields\n  - Implement new() to initialize Rhai engine with custom functions\n  - Register map(from: String, to: String) - uses prefix validation from task 9\n    - Validates `from` as physical key (no prefix)\n    - Validates `to` with VK_/MD_/LK_ prefix, creates appropriate KeyMapping variant\n  - Register tap_hold(key: String, tap: String, hold: String, threshold_ms: i64)\n    - Validates tap has VK_ prefix, hold has MD_ prefix\n    - Creates TapHold mapping variant\n  - Register when(condition) { ... } - accepts single string or array of strings\n    - Parses condition strings with MD_/LK_ prefix validation\n    - Creates Conditional mapping with AllActive for arrays\n  - Register when_not(condition: String) { ... } - single string only\n    - Creates Conditional mapping with NotActive wrapper\n  - Register with_shift(key: String) - validates VK_ prefix, creates ModifiedOutput with shift=true\n  - Register with_ctrl(key: String) - creates ModifiedOutput with ctrl=true\n  - Register with_alt(key: String) - creates ModifiedOutput with alt=true\n  - Register with_mods(key: String, shift: bool, ctrl: bool, alt: bool, win: bool) - named parameter syntax\n  - Register device(pattern: String) { ... } - creates DeviceConfig\n  - Implement parse_script(path: &Path) -> Result<ConfigRoot, ParseError>\n  - Set resource limits: max_operations(10_000), max_expr_depth(100), set_max_call_levels(100)\n  - Add 10-second timeout using std::time\n  - Purpose: Complete Rhai DSL parser with all operations\n  - _Leverage: Rhai documentation, error.rs, import_resolver.rs, prefix validation from task 9_\n  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7_\n  - _Prompt: Role: Rust Developer with expertise in Rhai scripting and DSL design | Task: Implement complete Rhai DSL parser in keyrx_compiler/src/parser.rs following requirements 2.1-2.7 with all custom functions and prefix validation | Restrictions: Must register all functions (map, tap_hold, when, when_not, with_shift, with_ctrl, with_alt, with_mods, device), enforce resource limits, handle syntax errors gracefully, integrate with import resolver, use prefix validation from task 9 | Success: Parser evaluates all Rhai DSL operations correctly, custom functions work, resource limits enforced, error messages include line/column, prefix validation integrated_\n\n- [x] 14. Write unit tests for parser\n  - File: keyrx_compiler/src/parser.rs (add #[cfg(test)] mod tests)\n  - Test device() function creates DeviceConfig\n  - Test map() function with VK_, MD_, LK_ outputs\n  - Test map() rejects missing prefixes\n  - Test tap_hold() function creates TapHold mapping\n  - Test tap_hold() validates VK_ for tap, MD_ for hold\n  - Test when() with single condition (string)\n  - Test when() with multiple conditions (array)\n  - Test when_not() creates NotActive condition\n  - Test with_shift(), with_ctrl(), with_alt() create ModifiedOutput\n  - Test with_mods() with named parameters\n  - Test complete script parsing (device + multiple map calls)\n  - Test nested when blocks (modifier cascades)\n  - Test syntax error handling with line numbers\n  - Test resource limit enforcement (infinite loop detection)\n  - Test timeout handling\n  - Purpose: Verify parser correctness and error handling\n  - _Leverage: ai-dev-foundation test patterns_\n  - _Requirements: 7.2_\n  - _Prompt: Role: Rust Test Engineer with expertise in Rhai testing and DSL validation | Task: Write comprehensive unit tests for Rhai parser following requirement 7.2 | Restrictions: Must test all custom functions, verify error messages, test prefix validation integration, test resource limits, use temporary Rhai scripts for testing | Success: All tests pass, coverage >90%, all parser scenarios verified including prefix validation_\n\n- [x] 15. Implement binary serializer\n  - File: keyrx_compiler/src/serialize.rs\n  - Define KRX_MAGIC constant: [0x4B, 0x52, 0x58, 0x0A] (\"KRX\\n\")\n  - Define KRX_VERSION constant: 1u32\n  - Implement serialize(config: &ConfigRoot) -> Result<Vec<u8>, SerializeError>\n  - Build 48-byte header: magic (4 bytes), version (4 bytes), hash (32 bytes), size (8 bytes)\n  - Serialize ConfigRoot using rkyv::to_bytes()\n  - Compute SHA256 hash of serialized data\n  - Embed hash in header\n  - Return complete binary (header + data)\n  - Purpose: Serialize ConfigRoot to .krx binary format\n  - _Leverage: rkyv documentation, sha2 crate for hashing, error.rs_\n  - _Requirements: 3.1, 3.2, 3.3_\n  - _Prompt: Role: Rust Systems Programmer with expertise in binary formats and cryptographic hashing | Task: Implement binary serializer in keyrx_compiler/src/serialize.rs following requirements 3.1-3.3 | Restrictions: Must use rkyv for serialization, compute SHA256 hash, create 48-byte header with magic/version/hash/size, ensure deterministic output | Success: Serializer produces valid .krx files, hash is correct, same input produces identical output_\n\n- [x] 16. Implement binary deserializer\n  - File: keyrx_compiler/src/serialize.rs (same file as task 15)\n  - Implement deserialize(bytes: &[u8]) -> Result<&ArchivedConfigRoot, DeserializeError>\n  - Verify magic bytes (first 4 bytes == KRX_MAGIC)\n  - Verify version (bytes 4-8 == KRX_VERSION)\n  - Extract embedded hash (bytes 8-40)\n  - Compute SHA256 hash of data (bytes 48+)\n  - Compare computed hash vs embedded hash\n  - Deserialize using rkyv::check_archived_root() for validation\n  - Return zero-copy reference to ArchivedConfigRoot\n  - Purpose: Deserialize and validate .krx files\n  - _Leverage: rkyv validation features, sha2 crate_\n  - _Requirements: 3.4, 3.5, 3.6_\n  - _Prompt: Role: Rust Systems Programmer with expertise in binary deserialization and validation | Task: Implement binary deserializer in keyrx_compiler/src/serialize.rs following requirements 3.4-3.6 | Restrictions: Must verify magic bytes, version, and hash, use rkyv validation features, provide zero-copy access, return detailed errors on failures | Success: Deserializer validates .krx files correctly, rejects corrupted files, provides zero-copy access, all error cases handled_\n\n- [x] 17. Write unit tests for serializer/deserializer\n  - File: keyrx_compiler/src/serialize.rs (add #[cfg(test)] mod tests)\n  - Test serialize produces valid binary format\n  - Test deserialize validates magic bytes\n  - Test deserialize validates version\n  - Test deserialize validates hash\n  - Test round-trip: deserialize(serialize(config)) works\n  - Test deterministic serialization: serialize(config) == serialize(config)\n  - Test corrupted file rejection (invalid magic, hash, version)\n  - Purpose: Verify serialization correctness and validation\n  - _Leverage: ai-dev-foundation test patterns_\n  - _Requirements: 7.2, 7.4_\n  - _Prompt: Role: Rust Test Engineer with expertise in binary format testing and property-based testing | Task: Write comprehensive tests for serializer/deserializer following requirements 7.2 and 7.4 | Restrictions: Must test all validation paths, verify determinism, test error cases, use property-based tests for determinism | Success: All tests pass, coverage >90%, deterministic serialization verified, all error scenarios tested_\n\n- [x] 18. Implement CLI interface\n  - File: keyrx_compiler/src/main.rs\n  - Use clap derive macros for CLI definition\n  - Define subcommands: compile, verify, hash, parse\n  - compile: Takes input.rhai and -o output.krx, calls parser and serializer\n  - verify: Takes config.krx, calls deserializer and prints validation result\n  - hash: Takes config.krx, extracts and prints SHA256 hash\n  - parse: Takes input.rhai and --json flag, parses and outputs JSON\n  - Implement --help for all commands\n  - Exit with 0 on success, 1 on error\n  - Purpose: User-facing command-line interface\n  - _Leverage: clap documentation, parser.rs, serialize.rs, error.rs_\n  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6_\n  - _Prompt: Role: Rust CLI Developer with expertise in clap and user experience design | Task: Implement complete CLI interface in keyrx_compiler/src/main.rs following requirements 5.1-5.6 | Restrictions: Must use clap derive macros, implement all subcommands, provide helpful error messages, support --help, exit with correct codes | Success: All subcommands work correctly, help text is clear, errors are user-friendly, exit codes correct_\n\n- [x] 19. Implement error formatting (user-friendly and JSON)\n  - File: keyrx_compiler/src/error.rs (extend from task 8)\n  - Implement format_error_user_friendly(error: &ParseError) -> String\n  - Implement format_error_json(error: &ParseError) -> String\n  - User-friendly format: file:line:column: error message with code snippet and suggestions\n  - Include specific suggestions for prefix errors:\n    - Missing prefix: \"Output must have VK_, MD_, or LK_ prefix: B → use VK_B for virtual key\"\n    - Invalid prefix: \"Unknown key prefix: MD_LShift (use MD_00 through MD_FE for custom modifiers)\"\n    - Wrong context: \"tap_hold hold parameter must have MD_ prefix, got: VK_Space\"\n  - JSON format: {\"error_code\": \"...\", \"message\": \"...\", \"file\": \"...\", \"line\": ..., \"column\": ..., \"suggestion\": \"...\"}\n  - Add \"did you mean\" suggestions for unknown key names\n  - Purpose: Clear error messages for users and machines\n  - _Leverage: error.rs error types_\n  - _Requirements: 6.2, 6.3, 6.4, 6.5_\n  - _Prompt: Role: Rust Developer with expertise in error formatting and UX | Task: Implement error formatting functions in keyrx_compiler/src/error.rs following requirements 6.2-6.5 with detailed prefix error suggestions | Restrictions: Must format errors for both human and machine consumption, include context (file/line/column), provide actionable suggestions with examples, JSON must be parseable | Success: Error messages are clear and actionable with specific examples, JSON format is valid, suggestions help users fix issues quickly_\n\n- [x] 20. Write integration tests for CLI\n  - File: keyrx_compiler/tests/integration/cli_tests.rs\n  - Test compile command: Rhai → .krx file\n  - Test verify command: valid .krx → success, corrupted → error\n  - Test hash command: .krx → SHA256 hash output\n  - Test parse command: Rhai → JSON output\n  - Test --help for all commands\n  - Test error scenarios: missing files, invalid syntax, prefix errors, etc.\n  - Purpose: End-to-end verification of CLI functionality\n  - _Leverage: ai-dev-foundation integration test patterns_\n  - _Requirements: 7.3_\n  - _Prompt: Role: QA Engineer with expertise in integration testing and CLI testing | Task: Write comprehensive integration tests for CLI in keyrx_compiler/tests/integration/cli_tests.rs following requirement 7.3 | Restrictions: Must test all subcommands end-to-end, use temporary files, verify output formats, test error scenarios including prefix validation | Success: All integration tests pass, all CLI workflows verified, error handling tested_\n\n- [x] 21. Write property-based tests for deterministic serialization\n  - File: keyrx_compiler/tests/property_tests.rs\n  - Use proptest or quickcheck crate\n  - Generate arbitrary ConfigRoot instances (with all 6 KeyMapping variants)\n  - Test property: serialize(config) == serialize(config)\n  - Test property: deserialize(serialize(config)) == config (round-trip)\n  - Test property: hash(serialize(config1)) != hash(serialize(config2)) if config1 != config2\n  - Run 1000+ iterations\n  - Purpose: Verify deterministic serialization with random inputs\n  - _Leverage: proptest/quickcheck documentation_\n  - _Requirements: 7.4_\n  - _Prompt: Role: Rust Test Engineer with expertise in property-based testing and formal verification | Task: Write property-based tests for serialization in keyrx_compiler/tests/property_tests.rs following requirement 7.4 | Restrictions: Must use proptest or quickcheck, test determinism and round-trip properties, run 1000+ iterations, generate random valid configs with all mapping variants | Success: All property tests pass with 1000+ iterations, deterministic serialization verified statistically_\n\n- [x] 22. Set up fuzzing for parser\n  - File: keyrx_core/fuzz/fuzz_targets/fuzz_parser.rs\n  - Initialize cargo-fuzz if not already set up\n  - Create fuzz target that feeds random bytes to Rhai parser\n  - Ensure parser never panics on arbitrary input\n  - Run for 60+ seconds in CI\n  - Purpose: Discover parser edge cases and crashes\n  - _Leverage: cargo-fuzz documentation from ai-dev-foundation_\n  - _Requirements: 7.5_\n  - _Prompt: Role: Security Engineer with expertise in fuzzing and vulnerability discovery | Task: Set up fuzzing for Rhai parser in keyrx_core/fuzz/fuzz_targets/fuzz_parser.rs following requirement 7.5 | Restrictions: Must use cargo-fuzz, parser must never panic, run for 60+ seconds minimum, test arbitrary inputs | Success: Fuzz target runs without crashes, parser handles all inputs gracefully, no panics discovered_\n\n- [x] 23. Set up fuzzing for deserializer\n  - File: keyrx_core/fuzz/fuzz_targets/fuzz_deserialize.rs\n  - Create fuzz target that feeds random bytes to deserializer\n  - Ensure deserializer never panics on arbitrary input\n  - Verify all invalid inputs return errors (not crashes)\n  - Run for 60+ seconds in CI\n  - Purpose: Discover deserialization edge cases and potential security issues\n  - _Leverage: cargo-fuzz documentation_\n  - _Requirements: 7.5_\n  - _Prompt: Role: Security Engineer with expertise in binary format fuzzing and memory safety | Task: Set up fuzzing for binary deserializer in keyrx_core/fuzz/fuzz_targets/fuzz_deserialize.rs following requirement 7.5 | Restrictions: Must use cargo-fuzz, deserializer must never panic or exhibit UB, all invalid inputs must return errors, run for 60+ seconds | Success: Fuzz target runs without crashes/UB, deserializer handles all inputs safely, no vulnerabilities discovered_\n\n- [x] 24. Add integration test for multi-file imports\n  - File: keyrx_compiler/tests/integration/import_tests.rs\n  - Create test with 3+ Rhai files importing each other\n  - Test successful import resolution and merging\n  - Test circular import detection\n  - Test file not found errors\n  - Verify final ConfigRoot contains all imported devices\n  - Purpose: Verify import system works end-to-end\n  - _Leverage: ai-dev-foundation integration test patterns_\n  - _Requirements: 7.3, 4.1-4.5_\n  - _Prompt: Role: QA Engineer with expertise in integration testing and file system testing | Task: Write integration tests for multi-file imports in keyrx_compiler/tests/integration/import_tests.rs following requirements 7.3 and 4.1-4.5 | Restrictions: Must test all import scenarios, use temporary files, verify merged configuration, test error cases | Success: All import scenarios work correctly, circular imports detected, errors are clear, configurations merge properly_\n\n- [x] 25. Update keyrx_core/src/lib.rs to export config module\n  - File: keyrx_core/src/lib.rs\n  - Add pub mod config; to export config module\n  - Add re-exports: pub use config::{ConfigRoot, DeviceConfig, KeyMapping, KeyCode, Version, Condition};\n  - Verify no_std compatibility\n  - Purpose: Make config types available to other crates\n  - _Leverage: structure.md module organization_\n  - _Requirements: 1.7_\n  - _Prompt: Role: Rust Developer with expertise in module systems and library design | Task: Update keyrx_core/src/lib.rs to export config module following requirement 1.7 | Restrictions: Must maintain no_std compatibility, export all public types (including Condition), follow Rust module conventions | Success: Config types are accessible from keyrx_core, no_std builds work, all types exported correctly_\n\n- [x] 26. Update keyrx_compiler/src/main.rs to add mod declarations\n  - File: keyrx_compiler/src/main.rs (update from task 18)\n  - Add mod declarations: mod parser; mod serialize; mod import_resolver; mod error;\n  - Verify all modules compile together\n  - Purpose: Wire all compiler modules together\n  - _Leverage: structure.md module organization_\n  - _Requirements: All_\n  - _Prompt: Role: Rust Developer with expertise in project structure and module organization | Task: Update keyrx_compiler/src/main.rs to declare all modules following structure.md conventions | Restrictions: Must declare all modules (parser, serialize, import_resolver, error), verify compilation, follow Rust module patterns | Success: All modules compile together, imports work correctly, no compilation errors_\n\n- [x] 27. Add example Rhai configuration files\n  - File: keyrx_compiler/examples/simple.rhai\n  - Write simple example with device() and map() calls (VK_ outputs)\n  - File: keyrx_compiler/examples/advanced.rhai\n  - Write advanced example demonstrating:\n    - Custom modifiers (MD_XX): CapsLock as navigation layer\n    - Custom locks (LK_XX): Toggle states\n    - Tap/hold behavior: Space as tap for space, hold for MD_00\n    - when() blocks with nested modifiers (cascades)\n    - when_not() blocks\n    - Physical modifier outputs: with_shift(), with_ctrl()\n  - Document syntax with comments\n  - Purpose: Provide user-facing examples of DSL syntax\n  - _Leverage: design.md Rhai DSL specification, DSL_MANUAL.md examples_\n  - _Requirements: 2.1-2.7_\n  - _Prompt: Role: Technical Writer with expertise in DSL documentation and examples | Task: Create comprehensive example Rhai configuration files in keyrx_compiler/examples/ demonstrating all DSL features | Restrictions: Must be valid Rhai syntax, show all DSL operations (map, tap_hold, when, when_not, with_shift, etc.), include helpful comments, demonstrate prefix system clearly | Success: Examples are clear and working, demonstrate all key DSL features, comments explain syntax and showcase advanced use cases_\n\n- [x] 28. Add README.md for keyrx_compiler\n  - File: keyrx_compiler/README.md\n  - Document CLI usage with examples\n  - Show compile, verify, hash, parse commands\n  - Include example Rhai snippet with prefix system\n  - Explain VK_/MD_/LK_ prefix semantics\n  - Link to simple.rhai and advanced.rhai examples\n  - Link to DSL_MANUAL.md for complete reference\n  - Purpose: User-facing documentation for compiler\n  - _Leverage: design.md CLI specification, DSL_MANUAL.md_\n  - _Requirements: All_\n  - _Prompt: Role: Technical Writer with expertise in CLI documentation and user guides | Task: Create comprehensive README for keyrx_compiler documenting all CLI commands and DSL prefix system | Restrictions: Must document all subcommands, include examples, explain VK_/MD_/LK_ prefix system, reference example files and DSL manual, keep it concise and actionable | Success: README is clear and complete, all commands documented with examples, prefix system explained clearly, users can learn the CLI and DSL quickly_\n\n- [x] 29. Run full verification and fix any issues\n  - Execute: make verify\n  - Fix any clippy warnings\n  - Fix any format issues (cargo fmt)\n  - Ensure all tests pass\n  - Verify 90%+ coverage for config system\n  - Purpose: Final quality check before completion\n  - _Leverage: ai-dev-foundation verify.sh script_\n  - _Requirements: All_\n  - _Prompt: Role: Senior Rust Developer with expertise in code quality and CI/CD | Task: Run full verification (make verify) and fix any issues to meet quality standards | Restrictions: Must pass clippy with no warnings, code must be formatted, all tests must pass, coverage must be >90% | Success: make verify passes, no clippy warnings, all tests green, coverage >90%, ready for production_\n",
  "fileStats": {
    "size": 33484,
    "lines": 418,
    "lastModified": "2025-12-21T13:44:22.471Z"
  },
  "comments": []
}