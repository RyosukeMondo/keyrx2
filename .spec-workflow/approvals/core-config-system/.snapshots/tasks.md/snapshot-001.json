{
  "id": "snapshot_1766302502882_nb4iks808",
  "approvalId": "approval_1766302502878_fep04k2j3",
  "approvalTitle": "Tasks for Core Configuration System",
  "version": 1,
  "timestamp": "2025-12-21T07:35:02.882Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document - Core Configuration System\n\n## Phase 1: Configuration Data Structures\n\n- [ ] 1. Define Version struct in keyrx_core\n  - File: keyrx_core/src/config.rs\n  - Create Version struct with major, minor, patch fields (u8)\n  - Derive rkyv traits: Archive, Serialize, Deserialize\n  - Add #[repr(C)] for stable layout\n  - Implement Version::current() -> Version (returns 1.0.0)\n  - Implement Display trait for version formatting\n  - Purpose: Version information for binary compatibility checking\n  - _Leverage: tech.md specifications for rkyv usage_\n  - _Requirements: 1.1_\n  - _Prompt: Role: Rust Systems Programmer with expertise in binary serialization and versioning | Task: Define Version struct in keyrx_core/src/config.rs following requirement 1.1, using rkyv traits and #[repr(C)] for stable binary layout | Restrictions: Must use u8 for all version fields, derive all required rkyv traits, implement current() to return Version { major: 1, minor: 0, patch: 0 } | Success: Struct compiles, derives rkyv traits correctly, Display trait shows \"1.0.0\" format, current() returns correct version_\n\n- [ ] 1.1 Define KeyCode enum with 100+ key codes\n  - File: keyrx_core/src/config.rs\n  - Create KeyCode enum with #[repr(u16)]\n  - Define all standard keys: A-Z (0x00-0x19), 0-9 (0x20-0x29), F1-F12 (0x30-0x3B)\n  - Define modifiers: LShift, RShift, LCtrl, RCtrl, LAlt, RAlt, LMeta, RMeta (0x100-0x107)\n  - Define special keys: Escape, Enter, Backspace, Tab, Space, CapsLock, etc. (0x200+)\n  - Define arrow keys: Left, Right, Up, Down (0x210-0x213)\n  - Derive: Archive, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, Hash, Debug\n  - Explicitly number all variants (prevent reordering issues)\n  - Create comprehensive documentation with key code ranges\n  - Purpose: Complete keyboard key code enumeration\n  - _Leverage: design.md KeyCode enum specification_\n  - _Requirements: 1.4_\n  - _Prompt: Role: Input Systems Engineer with expertise in keyboard scancode mappings | Task: Define comprehensive KeyCode enum in keyrx_core/src/config.rs with 100+ keys following requirement 1.4 and design.md specifications | Restrictions: Must use #[repr(u16)], explicitly number all variants, cover all standard keyboard keys, derive all required traits, organize keys by category (letters, numbers, modifiers, special) | Success: Enum compiles with all traits, includes A-Z, 0-9, F1-F12, modifiers, special keys, arrows, all variants have explicit numbers, documentation explains key ranges_\n\n- [ ] 1.2 Define KeyMapping enum\n  - File: keyrx_core/src/config.rs\n  - Create KeyMapping enum with #[repr(C)]\n  - Define Simple variant: { from: KeyCode, to: KeyCode }\n  - Add placeholder comments for future variants (TapHold, Layer)\n  - Derive: Archive, Serialize, Deserialize, Clone, PartialEq, Eq, Debug\n  - Purpose: Enumeration of different mapping types\n  - _Leverage: design.md KeyMapping specification_\n  - _Requirements: 1.3_\n  - _Prompt: Role: Rust Developer with expertise in enum design and binary serialization | Task: Define KeyMapping enum in keyrx_core/src/config.rs following requirement 1.3 with Simple variant and placeholders for future variants | Restrictions: Must use #[repr(C)], include only Simple variant for now, add comments for future TapHold and Layer variants, derive all required rkyv traits | Success: Enum compiles, Simple variant works with two KeyCode fields, serialization works, comments indicate future expansion points_\n\n- [ ] 1.3 Define DeviceIdentifier and DeviceConfig structs\n  - File: keyrx_core/src/config.rs\n  - Create DeviceIdentifier struct with pattern field (String)\n  - Create DeviceConfig struct with identifier (DeviceIdentifier) and mappings (Vec<KeyMapping>)\n  - Add #[repr(C)] to both structs\n  - Derive rkyv traits: Archive, Serialize, Deserialize\n  - Add documentation explaining device identifier pattern format\n  - Purpose: Device-specific configuration storage\n  - _Leverage: design.md DeviceConfig specification_\n  - _Requirements: 1.2_\n  - _Prompt: Role: Rust Systems Programmer with expertise in data modeling and serialization | Task: Define DeviceIdentifier and DeviceConfig structs in keyrx_core/src/config.rs following requirement 1.2 | Restrictions: Must use String for pattern (to support glob patterns), use Vec for mappings (variable length), add #[repr(C)], derive rkyv traits, document pattern format (e.g., \"USB\\\\VID_1234&PID_5678\\\\SERIAL_*\") | Success: Structs compile, serialize correctly, Vec<KeyMapping> works, documentation explains identifier format with examples_\n\n- [ ] 1.4 Define Metadata and ConfigRoot structs\n  - File: keyrx_core/src/config.rs\n  - Create Metadata struct with compiler_version (String) and source_hash ([u8; 32])\n  - Create ConfigRoot struct with version (Version), devices (Vec<DeviceConfig>), metadata (Metadata)\n  - Add #[repr(C)] to both structs\n  - Derive rkyv traits: Archive, Serialize, Deserialize\n  - Add comprehensive documentation for ConfigRoot (top-level config structure)\n  - Purpose: Top-level configuration data structure\n  - _Leverage: design.md ConfigRoot specification_\n  - _Requirements: 1.1_\n  - _Prompt: Role: Software Architect specializing in data structure design and versioning | Task: Define Metadata and ConfigRoot structs in keyrx_core/src/config.rs following requirement 1.1 as the root configuration structure | Restrictions: Must include version for compatibility, Vec<DeviceConfig> for multiple devices, Metadata for compilation info, use #[repr(C)], derive rkyv traits, no timestamp field (non-deterministic) | Success: Structs compile, ConfigRoot is the root serialization target, all fields serialize correctly, documentation explains structure hierarchy_\n\n- [ ] 1.5 Add KeyCode Rhai module generator\n  - File: keyrx_core/src/config.rs\n  - Implement KeyCode::rhai_module() -> rhai::Module\n  - Register all KeyCode variants as constants (Key::A, Key::B, etc.)\n  - Create macro for bulk registration to avoid repetition\n  - Add unit tests verifying all keys registered\n  - Purpose: Enable Rhai scripts to reference key codes (Key::A syntax)\n  - _Leverage: design.md Rhai module specification_\n  - _Requirements: 2.3_\n  - _Prompt: Role: Rust Developer with expertise in Rhai integration and macro programming | Task: Implement KeyCode::rhai_module() in keyrx_core/src/config.rs following design.md to expose all key codes to Rhai scripts | Restrictions: Must register all 100+ KeyCode variants, use macro for bulk registration (avoid manual repetition), return rhai::Module, enable Key::A syntax in scripts, test all keys are accessible | Success: Function compiles, returns Module with all keys registered, Rhai can access Key::A/Key::Escape/etc., macro reduces boilerplate, tests verify all keys present_\n\n- [ ] 1.6 Write unit tests for config structures\n  - File: keyrx_core/tests/test_config.rs\n  - Test Version serialization/deserialization\n  - Test KeyCode enum (all variants serialize correctly)\n  - Test KeyMapping::Simple serialization\n  - Test DeviceConfig with multiple mappings\n  - Test ConfigRoot roundtrip (serialize → deserialize → verify equality)\n  - Test determinism (serialize same config 100 times → same bytes)\n  - Purpose: Verify data structures serialize correctly and deterministically\n  - _Leverage: design.md testing strategy_\n  - _Requirements: 8.1_\n  - _Prompt: Role: QA Engineer with expertise in Rust testing and rkyv serialization | Task: Write comprehensive unit tests for config structures in keyrx_core/tests/test_config.rs following design.md testing strategy | Restrictions: Must test all struct serialization, verify roundtrip equality, test determinism (same input → same bytes), use rkyv for serialization, achieve ≥95% coverage of config.rs | Success: All tests pass, roundtrip works for all types, determinism verified (100 iterations), KeyCode enum serialization tested, ConfigRoot serialization works_\n\n## Phase 2: Binary Serialization\n\n- [ ] 2. Implement binary format constants\n  - File: keyrx_compiler/src/serialize.rs\n  - Define MAGIC constant: &[u8; 4] = b\"KRXC\"\n  - Define CURRENT_VERSION: Version = Version { major: 1, minor: 0, patch: 0 }\n  - Define header size constants (MAGIC_SIZE = 4, HASH_SIZE = 32, etc.)\n  - Add documentation explaining binary format layout\n  - Purpose: Binary format specification constants\n  - _Leverage: design.md binary format specification_\n  - _Requirements: 3.1, 3.3_\n  - _Prompt: Role: Systems Programmer with expertise in binary file formats | Task: Define binary format constants in keyrx_compiler/src/serialize.rs following design.md binary format specification | Restrictions: Must use MAGIC = b\"KRXC\", version 1.0.0, define all header field sizes, document binary layout in comments, use const for all constants | Success: Constants compile, MAGIC is 4 bytes, version matches current, header size constants correct (magic=4, version=3, reserved=1, hash=32, len=8), documentation shows binary layout_\n\n- [ ] 2.1 Implement BinarySerializer::normalize\n  - File: keyrx_compiler/src/serialize.rs\n  - Create normalize(config: &ConfigRoot) -> ConfigRoot function\n  - Sort devices by identifier.pattern (deterministic ordering)\n  - Sort mappings within each device by (from, to) tuple\n  - Clone config with sorted collections\n  - Add unit test verifying sort order\n  - Purpose: Ensure deterministic serialization by normalizing data\n  - _Leverage: design.md normalization strategy_\n  - _Requirements: 3.2, 4.3_\n  - _Prompt: Role: Rust Developer with expertise in data normalization and deterministic algorithms | Task: Implement BinarySerializer::normalize in keyrx_compiler/src/serialize.rs to ensure deterministic serialization by sorting all collections | Restrictions: Must sort devices by identifier.pattern lexicographically, sort mappings by from/to key codes, clone config (don't modify original), use stable sort, test with randomized input | Success: Function compiles, sorts devices correctly, sorts mappings correctly, produces identical output for equivalent configs regardless of insertion order, unit test verifies determinism_\n\n- [ ] 2.2 Implement BinarySerializer::serialize\n  - File: keyrx_compiler/src/serialize.rs\n  - Create serialize(config: &ConfigRoot) -> Result<Vec<u8>> function\n  - Call normalize(config) for deterministic ordering\n  - Serialize normalized config with rkyv::AlignedVec\n  - Compute SHA256 hash of payload\n  - Build binary: magic + version + reserved + hash + len + payload\n  - Add error handling for serialization failures\n  - Purpose: Serialize ConfigRoot to .krx binary format\n  - _Leverage: design.md serialization implementation_\n  - _Requirements: 3.1, 3.2_\n  - _Prompt: Role: Serialization Engineer with expertise in rkyv and cryptographic hashing | Task: Implement BinarySerializer::serialize in keyrx_compiler/src/serialize.rs following design.md to convert ConfigRoot to binary format | Restrictions: Must normalize first, use rkyv::AlignedVec for serialization, compute SHA256 of payload only, build header with correct format (magic + version + reserved + hash + len), use little-endian for length, handle all errors | Success: Function compiles, produces valid binary, hash is correct, header format matches spec, roundtrip works (serialize → deserialize), determinism verified_\n\n- [ ] 2.3 Implement BinarySerializer::deserialize with validation\n  - File: keyrx_compiler/src/serialize.rs\n  - Create deserialize(bytes: &[u8]) -> Result<&ConfigRoot> function\n  - Verify magic number matches b\"KRXC\"\n  - Check version compatibility (major version must match)\n  - Extract stored hash, recompute from payload, compare\n  - Use rkyv::check_archived_root for validation\n  - Return archived root (zero-copy access)\n  - Add comprehensive error types (InvalidMagic, IncompatibleVersion, HashMismatch, ValidationFailed)\n  - Purpose: Deserialize and validate .krx binary safely\n  - _Leverage: design.md deserialization implementation_\n  - _Requirements: 3.4, 3.5_\n  - _Prompt: Role: Security-Focused Rust Developer with expertise in safe deserialization | Task: Implement BinarySerializer::deserialize in keyrx_compiler/src/serialize.rs with full validation following design.md | Restrictions: Must verify magic number first, check version compatibility, verify hash before deserializing, use rkyv::check_archived_root for validation, return Result with specific error types, never panic on invalid input | Success: Function compiles, rejects invalid magic, rejects version mismatch, detects hash corruption, validates rkyv data, passes fuzz testing (no panics on random input), zero-copy deserialization works_\n\n- [ ] 2.4 Implement hash verification functions\n  - File: keyrx_compiler/src/serialize.rs\n  - Create verify_binary(bytes: &[u8]) -> Result<bool> function\n  - Create extract_hash(bytes: &[u8]) -> Result<[u8; 32]> function\n  - Implement hash comparison without full deserialization\n  - Add helper to_hex_string for hash display\n  - Purpose: Standalone hash verification for --verify and --hash flags\n  - _Leverage: design.md hash verification specification_\n  - _Requirements: 4.1, 4.2_\n  - _Prompt: Role: Cryptography Engineer with expertise in secure hash verification | Task: Implement hash verification functions in keyrx_compiler/src/serialize.rs for standalone hash checking | Restrictions: Must verify without deserializing full payload, extract hash from header bytes 8-40, recompute SHA256 from payload, compare in constant time (prevent timing attacks), provide hex encoding helper | Success: Functions compile, verify_binary checks hash correctly, extract_hash returns stored hash, to_hex_string produces lowercase hex, timing-safe comparison used_\n\n- [ ] 2.5 Write serialization unit tests\n  - File: keyrx_compiler/tests/test_serialize.rs\n  - Test serialize → deserialize roundtrip for various configs\n  - Test determinism: serialize same config 1000 times → identical bytes\n  - Test hash verification: modify single byte → verify_binary fails\n  - Test version mismatch error\n  - Test invalid magic number error\n  - Test corrupted payload validation error\n  - Test large configs (10K mappings) performance\n  - Purpose: Comprehensive serialization testing\n  - _Leverage: design.md testing strategy_\n  - _Requirements: 8.1, 8.3_\n  - _Prompt: Role: Test Engineer with expertise in serialization testing and fuzzing | Task: Write comprehensive serialization tests in keyrx_compiler/tests/test_serialize.rs following design.md testing strategy | Restrictions: Must test roundtrip, verify determinism with 1000 iterations, test all error paths, test large configs, measure performance, use proptest for random configs, achieve ≥95% coverage of serialize.rs | Success: All tests pass, determinism verified, error handling tested, large config serializes in <100ms, deserializes in <10ms, proptest roundtrip works for random configs_\n\n## Phase 3: Rhai DSL Evaluator\n\n- [ ] 3. Create DeviceHandle custom type for Rhai\n  - File: keyrx_compiler/src/parser.rs\n  - Define DeviceHandle struct with identifier (String) and mappings (Vec<KeyMapping>)\n  - Implement new(identifier: String) -> Self\n  - Implement map(&mut self, from: KeyCode, to: KeyCode) method\n  - Implement to_config(self) -> DeviceConfig conversion\n  - Add Clone derive for Rhai compatibility\n  - Purpose: Rhai-accessible device handle for building configurations\n  - _Leverage: design.md DeviceHandle specification_\n  - _Requirements: 2.2, 2.3_\n  - _Prompt: Role: Rhai Integration Engineer with expertise in custom types | Task: Create DeviceHandle struct in keyrx_compiler/src/parser.rs as Rhai custom type following design.md | Restrictions: Must be Clone, implement new() constructor, implement map() method accepting two KeyCode params, store mappings internally, provide to_config() for conversion to DeviceConfig | Success: Struct compiles, Clone works, new() creates handle, map() adds KeyMapping::Simple to internal vec, to_config() produces valid DeviceConfig_\n\n- [ ] 3.1 Implement RhaiEvaluator struct\n  - File: keyrx_compiler/src/parser.rs\n  - Create RhaiEvaluator struct with engine (rhai::Engine) and devices (Vec<DeviceConfig>)\n  - Implement new() to create evaluator with configured engine\n  - Configure engine: set_max_operations(1_000_000), set_max_string_size(1024), set_max_array_size(10_000)\n  - Disable dangerous features (no file I/O, no network, no system calls)\n  - Purpose: Rhai engine wrapper for script evaluation\n  - _Leverage: design.md RhaiEvaluator specification_\n  - _Requirements: 2.1_\n  - _Prompt: Role: Scripting Language Security Expert with Rhai expertise | Task: Implement RhaiEvaluator struct in keyrx_compiler/src/parser.rs with secure Rhai engine configuration | Restrictions: Must set resource limits (max ops, max string size, max array size), disable file I/O, disable network, disable process spawning, configure engine in new(), store engine and devices list | Success: Struct compiles, engine created with limits, dangerous features disabled, new() initializes correctly, resource limits prevent DoS_\n\n- [ ] 3.2 Register device() API in Rhai\n  - File: keyrx_compiler/src/parser.rs\n  - Implement register_device_api(engine: &mut Engine) function\n  - Register device() function: String → DeviceHandle\n  - Register DeviceHandle type with Rhai\n  - Register map() method on DeviceHandle\n  - Add documentation for API usage\n  - Purpose: Enable device(\"USB\\\\...\") syntax in Rhai scripts\n  - _Leverage: design.md device() API specification_\n  - _Requirements: 2.2_\n  - _Prompt: Role: Rhai API Designer with expertise in custom function registration | Task: Implement register_device_api in keyrx_compiler/src/parser.rs to expose device() function to Rhai | Restrictions: Must register device(String) -> DeviceHandle, register DeviceHandle as custom type, register map method on handle, enable method call syntax (handle.map(...)), document usage | Success: Function compiles, device() callable from Rhai, returns DeviceHandle, map() callable on handle, type registration works, examples in comments_\n\n- [ ] 3.3 Register KeyCode enum module in Rhai\n  - File: keyrx_compiler/src/parser.rs\n  - Implement register_key_enum(engine: &mut Engine) function\n  - Call KeyCode::rhai_module() from keyrx_core\n  - Register module as static module \"Key\" in engine\n  - Verify Key::A, Key::Escape, etc. syntax works\n  - Purpose: Enable Key::A syntax in Rhai scripts\n  - _Leverage: KeyCode::rhai_module from Phase 1.5_\n  - _Requirements: 2.3_\n  - _Prompt: Role: Rhai Module Integration Specialist | Task: Implement register_key_enum in keyrx_compiler/src/parser.rs to expose KeyCode enum to Rhai via static module | Restrictions: Must call KeyCode::rhai_module(), register as static module named \"Key\", enable Key::A/Key::Escape syntax, verify all keys accessible from Rhai | Success: Function compiles, KeyCode module registered, Rhai can access Key::A syntax, all 100+ keys available, module is static (not instance)_\n\n- [ ] 3.4 Implement eval_script method\n  - File: keyrx_compiler/src/parser.rs\n  - Create eval_script(&mut self, script: &str, file_path: &Path) -> Result<ConfigRoot>\n  - Compile script to AST with engine.compile(script)\n  - Evaluate AST with eval_ast_with_scope\n  - Extract DeviceHandle objects from scope\n  - Convert handles to DeviceConfig via to_config()\n  - Build ConfigRoot with extracted devices\n  - Add comprehensive error handling (syntax errors, eval errors)\n  - Purpose: Parse and evaluate Rhai script to produce ConfigRoot\n  - _Leverage: design.md eval_script implementation_\n  - _Requirements: 2.4_\n  - _Prompt: Role: Compiler Engineer with expertise in AST evaluation and error handling | Task: Implement eval_script method in keyrx_compiler/src/parser.rs to parse Rhai and produce ConfigRoot | Restrictions: Must compile to AST, use Scope for variable storage, extract all DeviceHandle objects, convert to DeviceConfig, build ConfigRoot with Version and Metadata, map Rhai errors to CompileError, include line/column info | Success: Method compiles, parses valid scripts, extracts devices correctly, builds valid ConfigRoot, reports syntax errors with line numbers, handles eval errors gracefully_\n\n- [ ] 3.5 Write Rhai evaluation unit tests\n  - File: keyrx_compiler/tests/test_parser.rs\n  - Test simple script: one device, one mapping\n  - Test multi-device script: multiple devices with different mappings\n  - Test syntax error: invalid Rhai syntax\n  - Test unknown key error: Key::InvalidKey\n  - Test empty script: no devices\n  - Test edge cases: max operations limit, max string size\n  - Purpose: Verify Rhai evaluation works correctly\n  - _Leverage: design.md testing examples_\n  - _Requirements: 8.1_\n  - _Prompt: Role: QA Automation Engineer with scripting language testing expertise | Task: Write comprehensive Rhai evaluation tests in keyrx_compiler/tests/test_parser.rs | Restrictions: Must test valid scripts (1 device, multiple devices), test error cases (syntax error, unknown key), test resource limits (max ops, max string), verify ConfigRoot structure matches script, test all error messages have line numbers | Success: All tests pass, simple script works, multi-device works, syntax errors detected with line info, unknown key errors clear, resource limits enforced, ≥90% coverage of parser.rs_\n\n## Phase 4: Import System\n\n- [ ] 4. Implement ImportResolver struct\n  - File: keyrx_compiler/src/import_resolver.rs\n  - Create ImportResolver struct with visited (HashSet<PathBuf>) and base_dir (PathBuf)\n  - Implement new(base_dir: impl Into<PathBuf>) -> Self\n  - Add clear() method to reset visited set\n  - Purpose: Track import resolution state and prevent circular imports\n  - _Leverage: design.md ImportResolver specification_\n  - _Requirements: 6.1, 6.3_\n  - _Prompt: Role: Compiler Infrastructure Engineer with expertise in module systems | Task: Implement ImportResolver struct in keyrx_compiler/src/import_resolver.rs for tracking import state | Restrictions: Must use HashSet<PathBuf> for visited tracking, store base_dir for relative path resolution, implement new() constructor, provide clear() to reset state, use PathBuf for all paths | Success: Struct compiles, new() initializes with base dir, visited set empty on creation, clear() resets visited, paths stored as absolute canonical paths_\n\n- [ ] 4.1 Implement import detection with regex\n  - File: keyrx_compiler/src/import_resolver.rs\n  - Create find_imports(script: &str) -> Result<Vec<String>> function\n  - Use regex to find: import \"path/to/file.rhai\";\n  - Pattern: r#\"import\\s+\"([^\"]+\\.rhai)\"\\s*;\"#\n  - Extract all import paths from captures\n  - Validate import paths (must end with .rhai)\n  - Purpose: Find all import statements in Rhai script\n  - _Leverage: design.md import resolution specification_\n  - _Requirements: 6.1_\n  - _Prompt: Role: Regex Expert with compiler development experience | Task: Implement find_imports in keyrx_compiler/src/import_resolver.rs using regex to detect import statements | Restrictions: Must match 'import \"path.rhai\";' syntax, allow whitespace, extract path from quotes, require .rhai extension, return Vec of paths, handle malformed imports gracefully | Success: Function compiles, regex matches import statements, extracts paths correctly, rejects non-.rhai extensions, handles multiple imports per file, whitespace variations supported_\n\n- [ ] 4.2 Implement path resolution\n  - File: keyrx_compiler/src/import_resolver.rs\n  - Create resolve_path(import_path: &str, current_file: &Path) -> Result<PathBuf>\n  - Resolve path relative to current file's directory\n  - Canonicalize path (resolve .. and . components)\n  - Check if file exists, return error if not found\n  - Return absolute canonical path\n  - Purpose: Convert relative import paths to absolute paths\n  - _Leverage: design.md path resolution strategy_\n  - _Requirements: 6.2_\n  - _Prompt: Role: Filesystem Abstraction Engineer with path resolution expertise | Task: Implement resolve_path in keyrx_compiler/src/import_resolver.rs for converting relative imports to absolute paths | Restrictions: Must resolve relative to current file's parent directory, use Path::join, canonicalize to absolute path, check file existence, return FileNotFound error with search path, handle cross-platform paths (use PathBuf) | Success: Function compiles, resolves relative paths correctly, returns absolute paths, detects missing files, handles ../ and ./ correctly, works on Windows and Linux_\n\n- [ ] 4.3 Implement circular import detection\n  - File: keyrx_compiler/src/import_resolver.rs\n  - Modify resolve() to track import chain\n  - Check if path in visited set before processing\n  - Return CircularImport error with full chain (A → B → C → A)\n  - Add import chain to error message\n  - Purpose: Prevent infinite loops from circular imports\n  - _Leverage: design.md circular import detection_\n  - _Requirements: 6.3_\n  - _Prompt: Role: Graph Algorithm Expert with compiler design experience | Task: Implement circular import detection in ImportResolver::resolve following design.md | Restrictions: Must use HashSet to track visited paths, check before inserting, build import chain string for error, return CircularImport error with chain (e.g., \"main.rhai → a.rhai → b.rhai → a.rhai\"), prevent infinite recursion | Success: Function detects circular imports, errors with full chain, HashSet prevents revisiting, complex circular cases caught (A→B→C→A), error message shows complete cycle_\n\n- [ ] 4.4 Implement recursive import resolution\n  - File: keyrx_compiler/src/import_resolver.rs\n  - Create resolve(&mut self, script: &str, current_file: &Path) -> Result<String>\n  - Find all import statements in script\n  - For each import: resolve path, check circular, read file, recursively resolve\n  - Replace import statement with resolved content\n  - Return fully inlined script (all imports expanded)\n  - Purpose: Recursively resolve all imports to single script\n  - _Leverage: design.md import processing flow_\n  - _Requirements: 6.2, 6.4_\n  - _Prompt: Role: Recursive Algorithm Specialist with compiler development expertise | Task: Implement recursive resolve method in keyrx_compiler/src/import_resolver.rs to expand all imports | Restrictions: Must find imports, resolve paths, detect cycles, read files, recursively process imports, replace import statements with content, return single inlined script, preserve line numbers in errors, limit recursion depth (100 max) | Success: Method resolves single import, resolves nested imports (A→B→C), detects cycles, replaces import statements correctly, error messages include full import chain, recursion limit prevents stack overflow_\n\n- [ ] 4.5 Write import resolution tests\n  - File: keyrx_compiler/tests/test_import_resolver.rs\n  - Create test fixtures: single import, nested imports, circular import\n  - Test single import: main.rhai imports devices.rhai\n  - Test nested imports: main → a → b → c (3 levels deep)\n  - Test circular import detection: main → a → b → a\n  - Test import not found error\n  - Test relative path resolution (../, ./)\n  - Purpose: Verify import system works correctly\n  - _Leverage: design.md testing strategy_\n  - _Requirements: 8.1_\n  - _Prompt: Role: Integration Test Engineer with filesystem testing expertise | Task: Write comprehensive import resolution tests in keyrx_compiler/tests/test_import_resolver.rs with file fixtures | Restrictions: Must create actual test files in tests/fixtures/, test single import, test nested imports (3+ levels), test circular detection, test missing file error, test relative paths, verify final inlined script correct, clean up fixtures | Success: All tests pass, single import works, nested imports expand correctly, circular imports detected, missing files error with correct path, relative paths resolve, ≥90% coverage of import_resolver.rs_\n\n## Phase 5: CLI Compiler\n\n- [ ] 5. Define CLI struct with clap derive\n  - File: keyrx_compiler/src/main.rs\n  - Use clap derive to define Cli struct\n  - Add input field (PathBuf, required positional argument)\n  - Add output field (Option<PathBuf>, -o/--output flag)\n  - Add verbose (bool, -v/--verbose flag)\n  - Add quiet (bool, -q/--quiet flag)\n  - Add json (bool, --json flag)\n  - Define Commands enum: Compile, Verify, Hash, ParseOnly\n  - Purpose: CLI argument parsing structure\n  - _Leverage: design.md CLI structure specification_\n  - _Requirements: 5.1, 5.5_\n  - _Prompt: Role: CLI Tool Developer with clap expertise | Task: Define CLI struct in keyrx_compiler/src/main.rs using clap derive following design.md | Restrictions: Must use clap 4.x with derive macros, define Cli with all flags, create Commands enum for subcommands, add help text for all fields, set version from Cargo.toml, follow UNIX conventions | Success: Struct compiles, --help shows all options, subcommands listed, input required, output optional (defaults to input.krx), flags work (--verbose, --quiet, --json), version from package_\n\n- [ ] 5.1 Implement compile_command function\n  - File: keyrx_compiler/src/main.rs\n  - Create compile_command(input, output, cli) -> !\n  - Read Rhai script from input file\n  - Resolve imports with ImportResolver\n  - Parse script with RhaiEvaluator\n  - Serialize config with BinarySerializer\n  - Write .krx file\n  - Output success message with hash\n  - Handle all errors with unwrap_or_exit pattern\n  - Purpose: Compile Rhai → .krx\n  - _Leverage: design.md compile_command implementation_\n  - _Requirements: 5.2, 5.3_\n  - _Prompt: Role: Systems Integration Engineer with error handling expertise | Task: Implement compile_command in keyrx_compiler/src/main.rs to orchestrate compilation pipeline | Restrictions: Must call all components (ImportResolver, RhaiEvaluator, BinarySerializer), handle errors gracefully, output success with hash, support --json flag, exit with code 0 on success, write binary to output path, default output to input.krx | Success: Function compiles, reads script, resolves imports, parses Rhai, serializes binary, writes file, prints hash, errors handled, JSON output works, exit codes correct_\n\n- [ ] 5.2 Implement verify_command function\n  - File: keyrx_compiler/src/main.rs\n  - Create verify_command(file, cli) -> !\n  - Read .krx binary from file\n  - Call BinarySerializer::verify_binary\n  - Output \"VALID\" or \"CORRUPTED\"\n  - Support --json flag for structured output\n  - Exit with code 0 if valid, 1 if corrupted\n  - Purpose: Verify .krx binary hash without recompiling\n  - _Leverage: design.md verify command specification_\n  - _Requirements: 5.5, 4.2_\n  - _Prompt: Role: Verification Tool Developer with cryptography experience | Task: Implement verify_command in keyrx_compiler/src/main.rs for hash verification | Restrictions: Must read binary file, call verify_binary, output clear result (VALID/CORRUPTED), support --json output, exit 0 for valid, exit 1 for corrupted, handle file not found error | Success: Function compiles, reads .krx file, verifies hash, outputs correct result, JSON mode works, exit codes correct, errors handled gracefully_\n\n- [ ] 5.3 Implement hash_command function\n  - File: keyrx_compiler/src/main.rs\n  - Create hash_command(file, cli) -> !\n  - Read .krx binary from file\n  - Call BinarySerializer::extract_hash\n  - Output hash in hex format\n  - Support --json flag\n  - Exit with code 0\n  - Purpose: Extract and print hash from .krx file\n  - _Leverage: design.md hash command specification_\n  - _Requirements: 5.5, 4.1_\n  - _Prompt: Role: CLI Utility Developer with hex encoding expertise | Task: Implement hash_command in keyrx_compiler/src/main.rs to extract and display hash | Restrictions: Must read binary, extract hash from header, convert to hex string (lowercase), output hash only (no prefix), support --json output {\"hash\": \"...\"}, exit 0, handle errors | Success: Function compiles, extracts hash correctly, outputs hex (64 chars), JSON mode works, quiet mode suppresses extra output, exit code 0_\n\n- [ ] 5.4 Implement parse_only_command function\n  - File: keyrx_compiler/src/main.rs\n  - Create parse_only_command(input, cli) -> !\n  - Read Rhai script\n  - Resolve imports\n  - Parse script (syntax check only, no compilation)\n  - Output \"Syntax OK\" or error message\n  - Support --json flag\n  - Purpose: Syntax check without compiling\n  - _Leverage: design.md parse-only specification_\n  - _Requirements: 5.5_\n  - _Prompt: Role: Syntax Checker Tool Developer | Task: Implement parse_only_command in keyrx_compiler/src/main.rs for syntax validation | Restrictions: Must parse script, resolve imports, check syntax only (don't compile to binary), output \"Syntax OK\" on success, show errors with line numbers, support --json, exit 0 for valid, exit 1 for invalid | Success: Function compiles, parses script, detects syntax errors, outputs clear messages, JSON mode works, doesn't create .krx file, exit codes correct_\n\n- [ ] 5.5 Implement error handling with unwrap_or_exit\n  - File: keyrx_compiler/src/main.rs\n  - Create UnwrapOrExit trait for Result<T, E>\n  - Implement unwrap_or_exit(message) method\n  - Output error in human or JSON format based on --json flag\n  - Exit with code 1 on error\n  - Use throughout all command functions\n  - Purpose: Consistent error handling across CLI\n  - _Leverage: design.md error handling pattern_\n  - _Requirements: 5.4, 7.1-7.4_\n  - _Prompt: Role: Error Handling Framework Developer | Task: Implement UnwrapOrExit trait in keyrx_compiler/src/main.rs for consistent error handling | Restrictions: Must work with any Result type, output to stderr, support --json flag, include error message and context, exit with code 1, use throughout CLI commands, show user-friendly errors in normal mode | Success: Trait compiles, unwrap_or_exit method works, outputs to stderr, JSON errors structured, human errors readable, exit code 1, used in all commands_\n\n- [ ] 5.6 Write CLI integration tests\n  - File: keyrx_compiler/tests/test_cli.rs\n  - Test compile command: valid script → .krx created\n  - Test verify command: valid .krx → \"VALID\"\n  - Test hash command: extracts correct hash\n  - Test parse-only command: syntax check works\n  - Test error cases: invalid script, missing file, corrupted binary\n  - Test --json flag for all commands\n  - Test exit codes (0 for success, 1 for failure)\n  - Purpose: End-to-end CLI testing\n  - _Leverage: design.md integration testing examples_\n  - _Requirements: 8.2_\n  - _Prompt: Role: CLI Integration Test Engineer | Task: Write comprehensive CLI tests in keyrx_compiler/tests/test_cli.rs testing all commands end-to-end | Restrictions: Must test compile/verify/hash/parse-only commands, test valid and invalid inputs, verify exit codes, test --json output, use assert_cmd crate for CLI testing, create fixtures, clean up temp files | Success: All tests pass, compile creates .krx, verify detects corruption, hash extracts correctly, parse-only validates syntax, errors return exit 1, JSON output valid, ≥90% coverage of main.rs_\n\n## Phase 6: Error Handling and Validation\n\n- [ ] 6. Define CompileError enum with thiserror\n  - File: keyrx_compiler/src/error.rs\n  - Create CompileError enum with thiserror::Error derive\n  - Define error variants: SyntaxError, UnknownKey, DuplicateMapping, CircularImport, ImportNotFound, SerializationError\n  - Each variant includes relevant context (line, column, file)\n  - Implement Display for human-readable messages\n  - Create SourceLocation struct for error locations\n  - Purpose: Comprehensive error type for compiler\n  - _Leverage: design.md error types specification_\n  - _Requirements: 7.1, 7.2_\n  - _Prompt: Role: Error Type Designer with thiserror expertise | Task: Define CompileError enum in keyrx_compiler/src/error.rs using thiserror following design.md | Restrictions: Must use thiserror, include all error variants from design, store SourceLocation for each error, implement Display, provide context (file, line, column), make errors user-friendly | Success: Enum compiles, thiserror derives work, Display shows readable messages, SourceLocation included, all error types from requirements covered, errors provide actionable information_\n\n- [ ] 6.1 Implement error message formatting\n  - File: keyrx_compiler/src/error.rs\n  - Implement Display for CompileError with colored output\n  - Show code snippet for syntax errors (line with error marker)\n  - Provide suggestions for UnknownKey errors (did you mean...)\n  - Format error messages following Rust compiler style\n  - Support --no-color flag to disable colors\n  - Purpose: User-friendly error messages\n  - _Leverage: design.md error output formats_\n  - _Requirements: 7.4_\n  - _Prompt: Role: Developer Experience Engineer with terminal formatting expertise | Task: Implement Display for CompileError in keyrx_compiler/src/error.rs with Rust-compiler-style formatting | Restrictions: Must show file:line:column, show code snippet with caret (^) pointing to error, use colors (red for error, yellow for suggestions), provide \"did you mean\" for unknown keys, respect --no-color, follow rustc error style | Success: Display implemented, errors show snippet, caret points to error column, colors work, suggestions helpful, --no-color disables colors, errors match rustc style_\n\n- [ ] 6.2 Implement JSON error serialization\n  - File: keyrx_compiler/src/error.rs\n  - Add to_json() method to CompileError\n  - Serialize error to structured JSON\n  - Include: error type, message, location (file, line, column), suggestions\n  - Use serde_json for serialization\n  - Purpose: Machine-readable error output for AI agents\n  - _Leverage: design.md JSON error schema_\n  - _Requirements: 7.4_\n  - _Prompt: Role: API Integration Engineer with JSON schema expertise | Task: Implement to_json for CompileError in keyrx_compiler/src/error.rs following design.md JSON schema | Restrictions: Must return serde_json::Value, include all fields (error type, message, location, suggestions), match schema from design.md, handle all error variants, enable AI parsing | Success: Method compiles, outputs valid JSON, includes all required fields, location structured correctly, suggestions array included, AI agents can parse, matches design.md schema_\n\n- [ ] 6.3 Implement \"did you mean\" suggestions\n  - File: keyrx_compiler/src/error.rs\n  - Create suggest_key(unknown: &str) -> Vec<String> function\n  - Use Levenshtein distance to find similar key names\n  - Return top 3 closest matches\n  - Integrate into UnknownKey error\n  - Purpose: Help users fix typos in key names\n  - _Requirements: 7.2_\n  - _Prompt: Role: Fuzzy Matching Algorithm Developer | Task: Implement suggest_key in keyrx_compiler/src/error.rs using Levenshtein distance for key suggestions | Restrictions: Must compute edit distance for all KeyCode variants, return top 3 matches, threshold distance <3 for relevance, use strsim or similar crate, integrate into UnknownKey error, show in error message | Success: Function compiles, finds similar keys, \"KeyAA\" suggests \"KeyA\", \"Esape\" suggests \"Escape\", top 3 returned, suggestions useful, integrated into error display_\n\n- [ ] 6.4 Write error handling unit tests\n  - File: keyrx_compiler/tests/test_error.rs\n  - Test all error variants construct correctly\n  - Test Display formatting for each error type\n  - Test JSON serialization for each error type\n  - Test \"did you mean\" suggestions\n  - Test colored output vs plain output\n  - Purpose: Verify error handling works correctly\n  - _Requirements: 8.1_\n  - _Prompt: Role: QA Engineer specializing in error path testing | Task: Write comprehensive error tests in keyrx_compiler/tests/test_error.rs | Restrictions: Must test all error variants, verify Display output, verify JSON structure, test suggestions, test color output, verify line/column info preserved, test error conversions (Rhai error → CompileError) | Success: All tests pass, all error types tested, Display readable, JSON valid, suggestions work, colors can be disabled, ≥95% coverage of error.rs_\n\n## Phase 7: Documentation and Examples\n\n- [ ] 7. Create sample Rhai configurations\n  - File: examples/simple.rhai, examples/multi_device.rhai, examples/modular/\n  - Create simple.rhai: single device, CapsLock → Escape\n  - Create multi_device.rhai: two devices with different mappings\n  - Create modular example: main.rhai with imports\n  - Add comments explaining syntax\n  - Verify all examples compile successfully\n  - Purpose: Example configurations for users\n  - _Leverage: requirements.md example configurations_\n  - _Requirements: All requirements (examples)_\n  - _Prompt: Role: Technical Writer specializing in code examples | Task: Create example Rhai configurations in examples/ directory following requirements.md examples | Restrictions: Must create simple.rhai (1 device, 1 mapping), multi_device.rhai (2 devices), modular example (main with imports), add detailed comments, verify compilation works, show common use cases | Success: Examples created, simple.rhai works, multi_device works, modular imports work, all compile without errors, comments explain syntax, cover common patterns_\n\n- [ ] 7.1 Update .claude/CLAUDE.md with DSL documentation\n  - File: .claude/CLAUDE.md\n  - Add \"Configuration DSL (Rhai)\" section\n  - Document device() function: syntax, parameters, examples\n  - Document map() method: syntax, parameters, examples\n  - Document KeyCode enum: how to reference keys (Key::A syntax)\n  - Document import system: syntax, relative paths, examples\n  - Add troubleshooting: common errors and fixes\n  - Purpose: AI agent documentation for configuration DSL\n  - _Requirements: 8.7_\n  - _Prompt: Role: Developer Advocate specializing in DSL documentation | Task: Update .claude/CLAUDE.md with Rhai DSL documentation for AI agents | Restrictions: Must document device() function, map() method, Key:: syntax, import system, provide examples, explain error messages, show compilation command, be concise and example-driven | Success: Documentation added, device() documented with examples, map() explained, KeyCode syntax shown, imports explained, examples compile, troubleshooting covers common errors, AI agents can learn DSL from doc_\n\n- [ ] 7.2 Create keyrx_compiler README\n  - File: keyrx_compiler/README.md\n  - Explain purpose: Rhai → .krx compiler\n  - Show installation: cargo build --bin keyrx_compiler\n  - Document all CLI commands: compile, verify, hash, parse-only\n  - Show examples for each command\n  - Document flags: --verbose, --quiet, --json\n  - Add troubleshooting section\n  - Purpose: User-facing compiler documentation\n  - _Requirements: 8.7_\n  - _Prompt: Role: Technical Writer with CLI tool documentation expertise | Task: Create comprehensive README.md in keyrx_compiler/ following design.md | Restrictions: Must explain purpose, show installation, document all commands, provide examples, document all flags, add troubleshooting, include quick start, show output examples | Success: README created, purpose clear, installation instructions work, all commands documented, examples correct, flags explained, troubleshooting helpful, quick start works_\n\n- [ ] 7.3 Add inline documentation to public APIs\n  - File: keyrx_core/src/config.rs, keyrx_compiler/src/*.rs\n  - Add rustdoc comments to all public structs, enums, functions\n  - Include examples in doc comments (//! # Examples)\n  - Document all fields and variants\n  - Add module-level documentation\n  - Run cargo doc to verify docs build\n  - Purpose: Comprehensive API documentation\n  - _Requirements: 8.7_\n  - _Prompt: Role: API Documentation Specialist | Task: Add comprehensive rustdoc comments to all public APIs in keyrx_core and keyrx_compiler | Restrictions: Must document all pub items, include examples, explain parameters and return values, add module docs, use standard rustdoc format, verify with cargo doc, no warnings | Success: All pub items documented, examples included, cargo doc builds without warnings, documentation clear and helpful, examples compile in doc tests_\n\n## Phase 8: Testing and Validation\n\n- [ ] 8. Implement property-based tests with proptest\n  - File: keyrx_compiler/tests/test_proptest.rs\n  - Define arbitrary strategies for ConfigRoot, KeyCode, KeyMapping\n  - Test roundtrip: serialize → deserialize → verify equality (1000 iterations)\n  - Test determinism: serialize same config 100 times → same bytes\n  - Test hash stability: same config → same hash\n  - Purpose: Property-based testing for serialization\n  - _Leverage: design.md proptest strategies_\n  - _Requirements: 8.3_\n  - _Prompt: Role: Property-Based Testing Expert with proptest expertise | Task: Write proptest-based tests in keyrx_compiler/tests/test_proptest.rs following design.md | Restrictions: Must define arbitrary strategies for all types, test roundtrip property, test determinism (100 runs), test hash stability, run 1000+ iterations, use proptest crate, verify no panics | Success: Tests compile, strategies generate valid configs, roundtrip property holds, determinism verified (same input → same bytes), hash stable, 1000+ iterations pass_\n\n- [ ] 8.1 Create integration test suite\n  - File: keyrx_compiler/tests/integration_test.sh\n  - Test full workflow: write .rhai → compile → verify → hash\n  - Test import resolution: multi-file project compiles\n  - Test error handling: invalid script produces clear error\n  - Test CLI flags: --json, --quiet, --verbose\n  - Test exit codes for all scenarios\n  - Use BATS framework (already installed from ai-dev-foundation)\n  - Purpose: End-to-end integration testing\n  - _Leverage: ai-dev-foundation testing infrastructure_\n  - _Requirements: 8.2_\n  - _Prompt: Role: Integration Test Engineer with BATS framework expertise | Task: Create comprehensive integration test suite in keyrx_compiler/tests/integration_test.sh using BATS | Restrictions: Must test full workflow (rhai → krx), test imports, test errors, test all CLI flags, verify exit codes, use BATS, create fixtures, clean up after tests, run in CI | Success: Test script created, all workflows tested, imports work, errors detected, flags tested, exit codes verified, BATS tests pass, runs in CI successfully_\n\n- [ ] 8.2 Run security audit with cargo-fuzz\n  - File: keyrx_compiler/fuzz/\n  - Create fuzz target for BinarySerializer::deserialize\n  - Run fuzzer for 1 hour (or until coverage saturates)\n  - Fix any panics or crashes discovered\n  - Document fuzzing results\n  - Purpose: Ensure deserializer never panics on malformed input\n  - _Requirements: 8.5 (reliability)_\n  - _Prompt: Role: Security Engineer specializing in fuzz testing | Task: Set up cargo-fuzz for BinarySerializer::deserialize and run security audit | Restrictions: Must create fuzz target in keyrx_compiler/fuzz/, generate random binaries, ensure no panics on invalid input, run for 1+ hours, fix all crashes, document results, verify validation catches all malformed data | Success: Fuzz target created, runs without crash, no panics on random input, validation rejects invalid binaries gracefully, 1hr+ runtime clean, all crashes fixed, results documented_\n\n- [ ] 8.3 Verify deterministic compilation\n  - File: keyrx_compiler/tests/test_determinism.sh\n  - Compile same .rhai file 1000 times\n  - Verify all .krx outputs are byte-identical (diff)\n  - Compute hash for each output, verify all match\n  - Test on different machines (if possible)\n  - Document results\n  - Purpose: Prove deterministic compilation works\n  - _Requirements: 3.2, 4.3_\n  - _Prompt: Role: Determinism Verification Engineer | Task: Create determinism verification test in keyrx_compiler/tests/test_determinism.sh | Restrictions: Must compile same script 1000 times, use diff to compare binaries, verify all identical, compute hash for each, verify hashes match, run on CI, document any differences | Success: Test script created, 1000 compilations identical, diff shows no differences, all hashes match, test passes on CI, determinism proven_\n\n- [ ] 8.4 Benchmark compilation performance\n  - File: keyrx_compiler/benches/compile_bench.rs\n  - Benchmark simple config (<100 lines) compilation\n  - Benchmark large config (1000 lines, 10K mappings) compilation\n  - Benchmark serialization time\n  - Benchmark deserialization time\n  - Benchmark hash computation time\n  - Use Criterion for benchmarking\n  - Purpose: Verify performance targets met\n  - _Leverage: design.md performance targets_\n  - _Requirements: 8.5 (performance)_\n  - _Prompt: Role: Performance Engineer with Criterion benchmarking expertise | Task: Create comprehensive benchmarks in keyrx_compiler/benches/compile_bench.rs using Criterion | Restrictions: Must benchmark compile (simple and large), serialize, deserialize, hash, use Criterion, generate reports, verify targets met (<1s simple, <2s large, <100ms serialize, <10ms deserialize), run on CI | Success: Benchmarks created, Criterion runs, simple compile <1s, large compile <2s, serialize <100ms, deserialize <10ms, hash <5ms, targets met, reports generated_\n\n## Phase 9: Final Integration and Polishing\n\n- [ ] 9. Run full verification suite\n  - Run make verify (clippy, fmt, tests, coverage)\n  - Fix any warnings or errors\n  - Ensure ≥90% code coverage for core modules\n  - Verify all unit tests pass\n  - Verify all integration tests pass\n  - Purpose: Final quality check\n  - _Requirements: All requirements_\n  - _Prompt: Role: QA Lead with release verification expertise | Task: Run complete verification suite and ensure all quality checks pass | Restrictions: Must run make verify, fix all clippy warnings, ensure rustfmt passes, verify ≥90% coverage, all tests pass, no errors or warnings, ready for production | Success: make verify passes, no clippy warnings, rustfmt clean, coverage ≥90%, all tests pass (unit, integration, proptest), benchmarks run, code production-ready_\n\n- [ ] 9.1 Create end-to-end demonstration script\n  - File: scripts/demo_config_system.sh\n  - Write demonstration Rhai script\n  - Compile with keyrx_compiler\n  - Verify hash\n  - Extract hash\n  - Show JSON output\n  - Demonstrate error handling\n  - Purpose: Showcase all features working together\n  - _Requirements: All requirements_\n  - _Prompt: Role: Developer Advocate creating product demonstrations | Task: Create demonstration script in scripts/demo_config_system.sh showing all config system features | Restrictions: Must create example .rhai, compile to .krx, verify hash, extract hash, show JSON output, demonstrate errors, show imports, annotate commands, make executable | Success: Demo script created, shows compilation, verification, hash extraction, JSON output, error handling, imports working, executable, runs cleanly, demonstrates all features_\n\n- [ ] 9.2 Update project README with config system\n  - File: README.md (root)\n  - Add \"Configuration System\" section\n  - Explain Rhai DSL briefly\n  - Show quick start: write .rhai → compile → use\n  - Link to keyrx_compiler README for details\n  - Add troubleshooting section\n  - Purpose: Top-level documentation update\n  - _Requirements: All requirements_\n  - _Prompt: Role: Technical Writer updating project overview | Task: Update root README.md with configuration system section | Restrictions: Must add \"Configuration System\" section, explain Rhai briefly, show quick example, link to compiler README, add to table of contents, keep concise (users want quick overview) | Success: README updated, config system explained, quick example works, links correct, TOC updated, concise and clear_\n\n- [ ] 9.3 Create verification checklist\n  - File: .spec-workflow/specs/core-config-system/VERIFICATION.md\n  - Create checklist mapping all requirements to evidence\n  - Document test results (unit, integration, proptest, fuzz)\n  - Document benchmark results\n  - Document coverage metrics\n  - Verify all acceptance criteria met\n  - Purpose: Prove spec completeness\n  - _Requirements: All requirements_\n  - _Prompt: Role: QA Lead with requirements traceability expertise | Task: Create comprehensive verification checklist in VERIFICATION.md mapping all requirements to evidence | Restrictions: Must check every acceptance criterion from requirements.md, provide evidence (test name, file location, metric), document all test results, show coverage, show benchmarks, verify completeness | Success: Checklist created, all requirements covered, evidence provided for each, test results documented, coverage shown (≥90%), benchmarks shown, spec provably complete_\n\n- [ ] 9.4 Final code review and cleanup\n  - Review all code for: TODOs, debug prints, commented code\n  - Remove any temporary code\n  - Ensure all public APIs documented\n  - Verify error messages are user-friendly\n  - Check for any unsafe code (should be none except in rkyv)\n  - Run final make verify\n  - Purpose: Code quality final pass\n  - _Requirements: All requirements_\n  - _Prompt: Role: Senior Rust Developer with code review expertise | Task: Perform final code review and cleanup for core-config-system | Restrictions: Must remove all TODOs, remove debug prints/commented code, verify all pub APIs documented, check error messages friendly, verify no unsafe except in dependencies, run make verify, ensure production quality | Success: No TODOs remain, no debug code, all APIs documented, errors user-friendly, no unexpected unsafe, make verify passes, code clean and production-ready_\n",
  "fileStats": {
    "size": 53140,
    "lines": 634,
    "lastModified": "2025-12-21T07:34:52.370Z"
  },
  "comments": []
}