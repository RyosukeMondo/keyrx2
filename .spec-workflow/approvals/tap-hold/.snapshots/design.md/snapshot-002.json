{
  "id": "snapshot_1766587812499_2j60t6w9v",
  "approvalId": "approval_1766464354902_gldgk4xwd",
  "approvalTitle": "Tap-Hold Design Document",
  "version": 2,
  "timestamp": "2025-12-24T14:50:12.499Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Tap-Hold Functionality\n\n## Overview\n\nTap-Hold implements dual-function key behavior through a Deterministic Finite Automaton (DFA) that tracks key press timing. The system decides between \"tap\" (quick release) and \"hold\" (sustained press) based on configurable time thresholds, enabling keys like CapsLock to serve multiple purposes.\n\nThe implementation follows keyrx's core principles: sub-millisecond latency, deterministic behavior, and WASM compatibility for browser-based simulation.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **no_std Core**: State machine implemented in keyrx_core without std dependencies\n- **Zero-copy processing**: No heap allocation in hot path\n- **Virtual clock for testing**: Time abstraction via `Clock` trait\n- **rkyv serialization**: TapHold config already serializable (existing infrastructure)\n\n### Project Structure (structure.md)\n- State machine logic in `keyrx_core/src/runtime/tap_hold.rs`\n- Time abstraction in `keyrx_core/src/runtime/clock.rs`\n- Integration in `keyrx_core/src/runtime/event.rs`\n- Tests in `keyrx_core/src/runtime/tap_hold.rs` (inline) and `keyrx_core/tests/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **BaseKeyMapping::TapHold**: Already defined in `keyrx_core/src/config/mappings.rs` (complete)\n- **tap_hold() DSL function**: Already implemented in `keyrx_compiler/src/parser/functions/tap_hold.rs` (complete)\n- **DeviceState**: Existing modifier/lock state management in `keyrx_core/src/runtime/state.rs`\n- **KeyEvent**: Existing event structure (needs timestamp field addition)\n- **process_event()**: Existing event processing pipeline (needs tap-hold branch implementation)\n\n### Integration Points\n- **Event Processing**: Insert tap-hold logic into `process_event()` match arm\n- **State Management**: Use existing `DeviceState.modifiers` for hold modifier activation\n- **Daemon Event Loop**: Pass OS timestamps through to keyrx_core\n\n## Architecture\n\nThe tap-hold system uses a state machine per pending key, managed by a `TapHoldProcessor` that integrates with the existing event processing pipeline.\n\n### Modular Design Principles\n- **Single File Responsibility**: `tap_hold.rs` handles only state machine logic\n- **Component Isolation**: `Clock` trait isolates time source (real vs virtual)\n- **Service Layer Separation**: State machine pure logic, daemon handles I/O\n- **Utility Modularity**: Timer utilities reusable for future features (combos, macros)\n\n```mermaid\ngraph TD\n    subgraph \"Event Flow\"\n        A[KeyEvent from OS] --> B{Is TapHold Key?}\n        B -->|No| C[Existing Simple/Modifier/Lock Logic]\n        B -->|Yes| D[TapHoldProcessor]\n    end\n\n    subgraph \"TapHoldProcessor\"\n        D --> E{Current State?}\n        E -->|Idle| F[Record press time, enter Pending]\n        E -->|Pending| G{Event Type?}\n        G -->|Release| H{Elapsed < Threshold?}\n        H -->|Yes| I[Output Tap Key]\n        H -->|No| J[Deactivate Hold Modifier]\n        G -->|Other Key Press| K[Confirm Hold Immediately]\n        E -->|Hold| L{Release?}\n        L -->|Yes| J\n    end\n\n    subgraph \"Timer Background\"\n        M[Timer Check] --> N{Any Pending Keys?}\n        N -->|Yes| O{Threshold Exceeded?}\n        O -->|Yes| P[Activate Hold Modifier]\n    end\n```\n\n## Components and Interfaces\n\n### Component 1: Clock Trait\n- **Purpose**: Abstract time source for deterministic testing\n- **Interfaces**:\n  ```rust\n  pub trait Clock {\n      fn now(&self) -> u64; // Microseconds since epoch\n  }\n  ```\n- **Dependencies**: None\n- **Reuses**: New component (enables DST principle from product.md)\n\n### Component 2: TapHoldState\n- **Purpose**: Represent state of a single pending tap-hold key\n- **Interfaces**:\n  ```rust\n  #[derive(Clone, Copy)]\n  pub enum TapHoldPhase {\n      Idle,\n      Pending { pressed_at: u64 },\n      Hold,\n  }\n\n  pub struct TapHoldState {\n      pub key: KeyCode,\n      pub phase: TapHoldPhase,\n      pub tap_key: KeyCode,\n      pub hold_modifier: u8,\n      pub threshold_us: u64,\n  }\n  ```\n- **Dependencies**: KeyCode from keyrx_core\n- **Reuses**: Existing KeyCode type\n\n### Component 3: TapHoldProcessor\n- **Purpose**: Manage multiple tap-hold keys and process events\n- **Interfaces**:\n  ```rust\n  pub struct TapHoldProcessor<const N: usize> {\n      pending: ArrayVec<TapHoldState, N>, // Max N concurrent tap-holds\n  }\n\n  impl<const N: usize> TapHoldProcessor<N> {\n      pub fn new() -> Self;\n\n      pub fn process_event(\n          &mut self,\n          event: KeyEvent,\n          current_time: u64,\n          state: &mut DeviceState,\n      ) -> ArrayVec<KeyEvent, 4>;\n\n      pub fn check_timeouts(\n          &mut self,\n          current_time: u64,\n          state: &mut DeviceState,\n      ) -> ArrayVec<KeyEvent, 4>;\n\n      pub fn is_pending(&self, key: KeyCode) -> bool;\n  }\n  ```\n- **Dependencies**: KeyEvent, DeviceState, ArrayVec\n- **Reuses**: Existing DeviceState for modifier management\n\n### Component 4: KeyEvent Timestamp Extension\n- **Purpose**: Carry timing information through event pipeline\n- **Interfaces**:\n  ```rust\n  // Extend existing KeyEvent\n  pub struct KeyEvent {\n      pub key: KeyCode,\n      pub event_type: EventType, // Press, Release, Repeat\n      pub timestamp_us: u64,     // NEW: Microseconds timestamp\n  }\n  ```\n- **Dependencies**: Existing KeyEvent structure\n- **Reuses**: Extends existing type\n\n## Data Models\n\n### TapHoldConfig (Already Exists)\n```rust\n// In keyrx_core/src/config/mappings.rs (already defined)\npub enum BaseKeyMapping {\n    TapHold {\n        from: KeyCode,      // Input key\n        tap: KeyCode,       // Output on quick release\n        hold_modifier: u8,  // Modifier to activate on hold (MD_00-FE)\n        threshold_ms: u16,  // Time threshold in milliseconds\n    },\n    // ... other variants\n}\n```\n\n### PendingKeyRegistry\n```rust\n// Runtime state for tracking pending keys\npub struct PendingKeyRegistry<const N: usize> {\n    entries: ArrayVec<TapHoldState, N>,\n}\n\nimpl<const N: usize> PendingKeyRegistry<N> {\n    pub fn add(&mut self, state: TapHoldState) -> Result<(), RegistryFull>;\n    pub fn remove(&mut self, key: KeyCode) -> Option<TapHoldState>;\n    pub fn get(&self, key: KeyCode) -> Option<&TapHoldState>;\n    pub fn get_mut(&mut self, key: KeyCode) -> Option<&mut TapHoldState>;\n    pub fn iter(&self) -> impl Iterator<Item = &TapHoldState>;\n    pub fn check_timeouts(&mut self, now: u64) -> ArrayVec<(KeyCode, u8), N>;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Registry Full (> N concurrent tap-holds)**\n   - **Handling**: Reject new tap-hold registration, pass key through as simple press\n   - **User Impact**: Key acts as regular key, debug log emitted\n   - **Recovery**: Automatic when other tap-holds complete\n\n2. **Missing Timestamp from OS**\n   - **Handling**: Use monotonic clock reading, log warning\n   - **User Impact**: None visible, slightly less accurate timing\n   - **Recovery**: Automatic, next event may have timestamp\n\n3. **Threshold Exceeded During Processing Delay**\n   - **Handling**: Retroactively treat as hold (check elapsed time on release)\n   - **User Impact**: Correct behavior despite delay\n   - **Recovery**: Automatic\n\n4. **State Corruption (should never happen)**\n   - **Handling**: Log error, reset to Idle, clear pending modifiers\n   - **User Impact**: One missed key action\n   - **Recovery**: Full state reset\n\n## Testing Strategy\n\n### Unit Testing\n- **State Machine Transitions**: Test all Idle → Pending → Hold → Idle paths\n- **Timing Edge Cases**: Exact threshold, threshold ± 1ms\n- **Concurrent Keys**: Multiple tap-holds active simultaneously\n- **Permissive Hold**: Other key press during Pending triggers Hold\n- **Virtual Clock**: All tests use injectable clock\n\n```rust\n#[test]\nfn test_tap_under_threshold() {\n    let mut processor = TapHoldProcessor::<4>::new();\n    let mut state = DeviceState::new();\n    let clock = VirtualClock::new();\n\n    // Press at t=0\n    let events = processor.process_event(\n        KeyEvent::press(KEY_CAPSLOCK, 0),\n        clock.now(),\n        &mut state,\n    );\n    assert!(events.is_empty()); // No output yet\n\n    // Release at t=150ms (under 200ms threshold)\n    clock.advance_ms(150);\n    let events = processor.process_event(\n        KeyEvent::release(KEY_CAPSLOCK, clock.now()),\n        clock.now(),\n        &mut state,\n    );\n    assert_eq!(events.len(), 2); // Press + Release of Escape\n    assert_eq!(events[0].key, KEY_ESCAPE);\n}\n```\n\n### Integration Testing\n- **End-to-End Config**: Compile tap_hold Rhai → .krx → load in test daemon\n- **Cross-Device**: Tap-hold on Device A affects conditionals on Device B\n- **With Conditionals**: tap_hold inside when_start block\n\n### End-to-End Testing\n- **Virtual E2E**: Use VirtualKeyboard to send keys, verify output\n- **Timing Accuracy**: Verify sub-ms precision with virtual clock\n- **Stress Test**: 100+ tap-holds with randomized timing (property-based)\n\n### Property-Based Testing\n```rust\nproptest! {\n    #[test]\n    fn tap_hold_deterministic(\n        events in prop::collection::vec(key_event_strategy(), 0..1000),\n        seed in any::<u64>(),\n    ) {\n        let result1 = simulate_with_seed(&events, seed);\n        let result2 = simulate_with_seed(&events, seed);\n        prop_assert_eq!(result1, result2); // Deterministic\n    }\n}\n```\n",
  "fileStats": {
    "size": 9288,
    "lines": 270,
    "lastModified": "2025-12-23T04:32:14.731Z"
  },
  "comments": []
}