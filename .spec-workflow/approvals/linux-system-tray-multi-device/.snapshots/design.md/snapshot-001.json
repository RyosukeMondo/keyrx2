{
  "id": "snapshot_1766594584323_hwmbhidoy",
  "approvalId": "approval_1766594584319_tixnmifz8",
  "approvalTitle": "Linux System Tray + Multi-Device Design",
  "version": 1,
  "timestamp": "2025-12-24T16:43:04.323Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design implements system tray integration and multi-device event discrimination for Linux, achieving feature parity with Windows while enabling the \"keyboard-aware remapping\" killer feature.\n\n**Key Components:**\n1. **Cross-platform SystemTray trait**: Abstraction layer for tray icons\n2. **Linux tray implementation**: Using `ksni` crate (KDE/freedesktop StatusNotifierItem protocol)\n3. **Device ID propagation**: Serial numbers flow from evdev → KeyEvent → Rhai\n4. **Device manager**: Enumerate and track multiple input devices\n\n**Architecture Goal:** Maximize code reuse between platforms while respecting OS-specific tray implementations.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Multi-Device Architecture (QMK-Inspired):**\n> \"Single daemon process, global `ExtendedState` shared across ALL connected devices\"\n\nThis design preserves the single-daemon model. Device IDs are metadata only—remapping still uses the global state machine.\n\n**Platform Trait Abstraction:**\n> \"Platform-specific code isolated in `keyrx_daemon`, core logic remains `no_std`\"\n\nSystem tray is 100% in `keyrx_daemon/src/platform/`. `keyrx_core` remains unchanged (device_id is transport metadata, not core logic).\n\n**Linux Input Subsystem:**\n> \"Uses evdev ioctl, device identification via `/dev/input/by-id/` (persistent serial numbers)\"\n\nDesign leverages existing `EvdevInput::serial()` method. No changes to evdev layer needed—only add device_id to event pipeline.\n\n### Project Structure (structure.md)\n\n**Four-Crate Workspace:**\n```\nkeyrx_daemon/\n├── src/\n│   ├── platform/\n│   │   ├── mod.rs          # SystemTray trait added here\n│   │   ├── linux/\n│   │   │   ├── mod.rs      # DeviceManager added\n│   │   │   └── tray.rs     # NEW: Linux tray implementation\n│   │   └── windows/\n│   │       └── tray.rs     # Refactored to implement SystemTray trait\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n1. **Windows Tray Implementation (`keyrx_daemon/src/platform/windows/tray.rs`)**\n   - **Reuse:** Event model (`TrayControlEvent::Reload`, `TrayControlEvent::Exit`)\n   - **Reuse:** Icon loading via `image` crate (`load_icon()` function)\n   - **Reuse:** Menu structure (Reload, Separator, Exit)\n   - **Extend:** Extract interface as `SystemTray` trait\n\n2. **Linux EvdevInput (`keyrx_daemon/src/platform/linux/mod.rs`)**\n   - **Reuse:** `EvdevInput::serial()` method (line 273-277) for device IDs\n   - **Reuse:** `EvdevInput::name()` for human-readable device names\n   - **Extend:** Device enumeration logic to open multiple devices simultaneously\n\n3. **KeyEvent Structure (`keyrx_core/src/runtime/event.rs`)**\n   - **Extend:** Add `device_id: Option<String>` field (non-breaking change via builder pattern)\n   - **Reuse:** Existing `with_timestamp()` pattern for chaining\n\n### Integration Points\n\n1. **Daemon Main Loop**\n   - **Current:** Platform-specific event processing in `keyrx_daemon/src/main.rs`\n   - **Integration:** Add tray polling before event processing: `if let Some(event) = tray.poll_event() { handle_tray_event(event); }`\n\n2. **Rhai Scripting Engine**\n   - **Current:** `keyrx_compiler` generates static lookup tables, no runtime Rhai\n   - **Integration:** Add `device_id()` method to Rhai's `event` object bindings (compile-time only, stored in .krx)\n\n3. **Web UI**\n   - **Current:** Daemon serves embedded React app via `axum` (keyrx_daemon/src/web/)\n   - **Integration:** New REST endpoint `/api/devices` returning JSON list of active devices\n\n## Architecture\n\n### Modular Design Principles\n\n**File Responsibility Breakdown:**\n- `platform/mod.rs`: SystemTray trait only (35 lines)\n- `platform/linux/tray.rs`: Linux-specific tray (120 lines, mirrors Windows structure)\n- `platform/linux/device_manager.rs`: Device enumeration (80 lines)\n- `platform/windows/tray.rs`: Refactored to implement trait (no logic changes, +10 lines for trait impl)\n\n**Service Layer Separation:**\n- **Platform Layer:** Captures events with device_id metadata\n- **Core Layer:** Processes events (unchanged, device_id is optional metadata)\n- **Presentation Layer:** Web UI displays device list (read-only)\n\n### System Architecture Diagram\n\n```mermaid\ngraph TD\n    subgraph Linux Platform\n        A[/dev/input/event0<br/>Laptop Keyboard] --> B[EvdevInput]\n        C[/dev/input/event1<br/>USB Numpad] --> D[EvdevInput]\n        E[/dev/input/event2<br/>Gaming Keyboard] --> F[EvdevInput]\n\n        B -->|KeyEvent + device_id| G[DeviceManager]\n        D -->|KeyEvent + device_id| G\n        F -->|KeyEvent + device_id| G\n\n        G -->|Merged Event Stream| H[Daemon Main Loop]\n\n        I[Linux System Tray<br/>ksni crate] -->|TrayControlEvent| H\n    end\n\n    subgraph Cross-Platform\n        H --> J[Remapping Engine<br/>keyrx_core]\n        J -->|Remapped Events| K[UinputOutput]\n    end\n\n    subgraph Web UI\n        H -->|WebSocket| L[React Dashboard]\n        L -->|REST /api/devices| M[Device List Display]\n    end\n\n    style I fill:#e1f5e1\n    style B fill:#e1f5e1\n    style D fill:#e1f5e1\n    style F fill:#e1f5e1\n```\n\n## Components and Interfaces\n\n### Component 1: SystemTray Trait\n\n**Purpose:** Cross-platform abstraction for system tray functionality\n\n**Interfaces:**\n```rust\n// keyrx_daemon/src/platform/mod.rs\n\npub enum TrayControlEvent {\n    Reload,\n    Exit,\n}\n\npub trait SystemTray {\n    /// Creates a new system tray icon\n    fn new() -> Result<Self, Box<dyn std::error::Error>> where Self: Sized;\n\n    /// Polls for tray menu events (non-blocking)\n    fn poll_event(&self) -> Option<TrayControlEvent>;\n\n    /// Cleanup (called on daemon shutdown)\n    fn shutdown(&mut self) -> Result<(), Box<dyn std::error::Error>>;\n}\n```\n\n**Dependencies:** None (trait only)\n\n**Reuses:** TrayControlEvent enum from Windows implementation (moved to platform/mod.rs)\n\n### Component 2: Linux Tray Implementation\n\n**Purpose:** Implement system tray for Linux using `ksni` crate\n\n**Interfaces:**\n```rust\n// keyrx_daemon/src/platform/linux/tray.rs\n\npub struct LinuxSystemTray {\n    handle: ksni::Handle<TrayService>,\n    event_receiver: Receiver<TrayControlEvent>,\n}\n\nimpl SystemTray for LinuxSystemTray {\n    fn new() -> Result<Self, Box<dyn std::error::Error>> { /* ... */ }\n    fn poll_event(&self) -> Option<TrayControlEvent> { /* ... */ }\n    fn shutdown(&mut self) -> Result<(), Box<dyn std::error::Error>> { /* ... */ }\n}\n\n// Internal service for ksni callbacks\nstruct TrayService {\n    sender: Sender<TrayControlEvent>,\n}\n\nimpl ksni::Tray for TrayService {\n    fn activate(&mut self, _x: i32, _y: i32) { /* ... */ }\n    fn id(&self) -> String { \"keyrx-daemon\".to_string() }\n    fn title(&self) -> String { \"KeyRx Daemon\".to_string() }\n    fn menu(&self) -> Vec<ksni::MenuItem<Self>> { /* Reload, Separator, Exit */ }\n}\n```\n\n**Dependencies:**\n- `ksni = \"0.2\"` (KDE StatusNotifierItem protocol)\n- `crossbeam-channel` (already in workspace, for event passing)\n\n**Reuses:**\n- Icon loading from `assets/icon.png` (Windows approach)\n- `TrayControlEvent` enum\n- Menu structure (Reload, Exit)\n\n### Component 3: DeviceManager\n\n**Purpose:** Enumerate and manage multiple input devices with unique IDs\n\n**Interfaces:**\n```rust\n// keyrx_daemon/src/platform/linux/device_manager.rs\n\npub struct DeviceInfo {\n    pub id: String,           // Serial or fallback path\n    pub name: String,         // Human-readable name\n    pub path: PathBuf,        // /dev/input/eventX\n    pub serial: Option<String>, // USB serial if available\n}\n\npub struct DeviceManager {\n    devices: HashMap<String, EvdevInput>,\n    device_info: HashMap<String, DeviceInfo>,\n}\n\nimpl DeviceManager {\n    /// Enumerate all keyboard devices in /dev/input/\n    pub fn enumerate() -> Result<Self, DeviceError>;\n\n    /// Get next event from any device (blocking)\n    pub fn next_event(&mut self) -> Result<(KeyEvent, String), DeviceError>;\n\n    /// Get device info by ID\n    pub fn device_info(&self, id: &str) -> Option<&DeviceInfo>;\n\n    /// List all device IDs\n    pub fn device_ids(&self) -> Vec<String>;\n}\n```\n\n**Dependencies:**\n- `evdev` (already in workspace)\n- `std::collections::HashMap`\n\n**Reuses:**\n- `EvdevInput::open()`, `EvdevInput::serial()`, `EvdevInput::name()`\n- Existing device path handling\n\n### Component 4: KeyEvent Extension\n\n**Purpose:** Add optional device_id field to KeyEvent\n\n**Interfaces:**\n```rust\n// keyrx_core/src/runtime/event.rs\n\npub struct KeyEvent {\n    keycode: KeyCode,\n    pressed: bool,\n    timestamp_us: u64,\n    device_id: Option<String>,  // NEW FIELD\n}\n\nimpl KeyEvent {\n    // Existing constructors remain unchanged (device_id defaults to None)\n    pub fn press(keycode: KeyCode) -> Self { /* ... */ }\n    pub fn release(keycode: KeyCode) -> Self { /* ... */ }\n\n    // NEW: Builder method for device_id\n    pub fn with_device_id(mut self, id: String) -> Self {\n        self.device_id = Some(id);\n        self\n    }\n\n    // NEW: Accessor\n    pub fn device_id(&self) -> Option<&str> {\n        self.device_id.as_deref()\n    }\n}\n```\n\n**Dependencies:** None (pure Rust)\n\n**Reuses:** Existing `with_timestamp()` builder pattern\n\n## Data Models\n\n### DeviceInfo Model\n```rust\npub struct DeviceInfo {\n    /// Unique identifier (serial or path-based)\n    pub id: String,\n\n    /// Human-readable name from evdev\n    pub name: String,\n\n    /// Device node path\n    pub path: PathBuf,\n\n    /// USB serial number (if available)\n    pub serial: Option<String>,\n}\n```\n\n### TrayControlEvent Enum\n```rust\npub enum TrayControlEvent {\n    /// User clicked \"Reload Config\"\n    Reload,\n\n    /// User clicked \"Exit\"\n    Exit,\n}\n```\n\n### Web API Response\n```json\n// GET /api/devices\n{\n  \"devices\": [\n    {\n      \"id\": \"usb-Logitech_USB_Keyboard-event-kbd\",\n      \"name\": \"Logitech USB Keyboard\",\n      \"path\": \"/dev/input/event0\",\n      \"serial\": \"123456\",\n      \"active\": true\n    },\n    {\n      \"id\": \"platform-i8042-serio-0-event-kbd\",\n      \"name\": \"AT Translated Set 2 keyboard\",\n      \"path\": \"/dev/input/event1\",\n      \"serial\": null,\n      \"active\": true\n    }\n  ]\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **System Tray Unavailable (Headless Server)**\n   - **Handling:** Log warning, continue without tray\n   - **User Impact:** Daemon runs, but no GUI control (CLI still works)\n   - **Code:**\n     ```rust\n     match LinuxSystemTray::new() {\n         Ok(tray) => Some(tray),\n         Err(e) => {\n             log::warn!(\"System tray unavailable: {}. Use CLI to control daemon.\", e);\n             None\n         }\n     }\n     ```\n\n2. **Device Enumeration Failure (Permission Denied)**\n   - **Handling:** Log error, exit with code 1\n   - **User Impact:** Daemon won't start; user must fix permissions (add to `input` group)\n   - **Code:**\n     ```rust\n     DeviceManager::enumerate().map_err(|e| {\n         eprintln!(\"Failed to enumerate devices: {}\", e);\n         eprintln!(\"Try: sudo usermod -aG input $USER && reboot\");\n         std::process::exit(1);\n     })\n     ```\n\n3. **Device Hot-Unplug (USB Keyboard Removed)**\n   - **Handling:** V1: Ignore hot-plug (requires restart). V2: Detect and update device list.\n   - **User Impact:** If device unplugged, daemon continues with remaining devices\n   - **Code:** (V2 future enhancement, not in this spec)\n\n4. **Tray Event Channel Overflow**\n   - **Handling:** Use bounded channel with capacity 10; if full, drop oldest event\n   - **User Impact:** Rapid clicks on tray menu may miss events (acceptable, user can retry)\n   - **Code:**\n     ```rust\n     let (tx, rx) = crossbeam_channel::bounded(10);\n     // sender.try_send() instead of send() to avoid blocking\n     ```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Tray Trait:**\n- Test that Windows implementation still compiles after trait refactor (no behavior change)\n- Mock SystemTray for Linux to verify poll_event() returns correct events\n\n**DeviceManager:**\n- Test device enumeration with mock `/dev/input/` paths\n- Test device_id generation (serial available vs fallback to path)\n- Test next_event() merges events from multiple devices correctly\n\n**KeyEvent Extension:**\n- Test `with_device_id()` builder pattern\n- Test backward compatibility: events without device_id still process correctly\n- Test device_id accessor returns None for legacy events\n\n### Integration Testing\n\n**Linux Tray:**\n- Manual test: Run daemon, verify tray icon appears in KDE/GNOME panel\n- Click \"Reload Config\" → verify daemon reloads .krx (check logs)\n- Click \"Exit\" → verify daemon exits cleanly (no stuck grabs)\n\n**Multi-Device:**\n- Connect 2 USB keyboards\n- Verify daemon enumerates both with distinct IDs\n- Verify events are tagged with correct device_id\n- Verify web UI shows both devices in /api/devices\n\n**Rhai Integration:**\n- Write Rhai script: `if event.device_id() == \"numpad\" { remap(Key::A, Key::F13) }`\n- Compile to .krx\n- Verify only numpad events trigger remap (main keyboard unaffected)\n\n### End-to-End Testing\n\n**Scenario: USB Numpad as Stream Deck**\n1. User connects USB numpad\n2. Daemon enumerates devices, assigns ID \"usb-NumericKeypad-123\"\n3. User writes Rhai config:\n   ```rhai\n   if event.device_id() == \"usb-NumericKeypad-123\" {\n       map(NUM_1, F13);  // OBS scene 1\n       map(NUM_2, F14);  // OBS scene 2\n   }\n   ```\n4. Compile to .krx, reload via tray\n5. Press Num1 on numpad → F13 injected\n6. Press 1 on main keyboard → normal `1` (not remapped)\n7. Verify in web UI: numpad shows green indicator when active\n\n**Coverage Target:** 85% for new code (DeviceManager, tray implementations)\n",
  "fileStats": {
    "size": 13524,
    "lines": 434,
    "lastModified": "2025-12-24T16:42:58.455Z"
  },
  "comments": []
}