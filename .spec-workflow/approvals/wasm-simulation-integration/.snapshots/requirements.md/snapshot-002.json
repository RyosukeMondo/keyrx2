{
  "id": "snapshot_1767018762269_if43sbj1k",
  "approvalId": "approval_1767018502802_q8jld8r6a",
  "approvalTitle": "WASM Simulation Integration Requirements",
  "version": 2,
  "timestamp": "2025-12-29T14:32:42.269Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe WASM Simulation Integration feature enables users to test keyboard remapping configurations directly in the web UI without reloading the daemon. Currently, users must edit a Rhai config, compile it to a .krx binary, reload the daemon, and then test with real keyboard input to verify their configuration works correctly. This creates a slow feedback loop that hinders rapid iteration and experimentation.\n\nBy compiling keyrx_core's simulation engine to WebAssembly (WASM), we can provide instant, deterministic testing of configurations in the browser. Users can simulate tap-hold timings, layer switches, modifier combinations, and macro sequences with millisecond-precision event sequences, seeing exactly how their configuration will behave before applying it to the daemon.\n\nThis is critical for:\n- **Configuration Development**: Test tap-hold thresholds and timing-sensitive logic without trial-and-error on real hardware\n- **Debugging**: Reproduce exact event sequences that trigger unexpected behavior\n- **Education**: Understand how the remapping engine processes events through interactive visualization\n- **Confidence**: Verify configuration correctness before committing changes to production\n\n## Alignment with Product Vision\n\nThis feature aligns with the KeyRx vision of providing a comprehensive, user-friendly keyboard remapping solution by:\n\n- **Developer Experience**: Instant feedback loop accelerates configuration development and reduces frustration\n- **Transparency**: Users see exactly how the DFA state machine processes each event, building mental models of the system\n- **Code Reuse**: 100% reuse of keyrx_core engine ensures WASM simulation matches daemon behavior exactly\n- **Modern UX**: Browser-based testing matches user expectations for web applications in 2025\n- **Accessibility**: No daemon required - users can experiment with configurations on any platform with a web browser\n\n## Requirements\n\n### Requirement 1: WASM Build Pipeline\n\n**User Story:** As a KeyRx developer, I want keyrx_core to compile to WASM, so that I can run the simulation engine in the browser.\n\n#### Acceptance Criteria\n\n1. WHEN keyrx_core is compiled with `wasm-pack build` THEN the build SHALL succeed without errors\n2. WHEN the WASM module is loaded in a browser THEN it SHALL be <10MB in size (optimized release build)\n3. WHEN the WASM module is initialized THEN it SHALL expose a JavaScript API for simulation functions\n4. WHEN keyrx_core has no_std-incompatible dependencies THEN the build SHALL use feature flags to exclude them from WASM builds\n\n### Requirement 2: Configuration Loading in WASM\n\n**User Story:** As a web UI user, I want to load my Rhai configuration into the simulator, so that I can test it without compiling to .krx format.\n\n#### Acceptance Criteria\n\n1. WHEN a user uploads a .rhai file in the web UI THEN the WASM module SHALL parse it and build an in-memory DFA\n2. WHEN parsing fails THEN the system SHALL return detailed error messages with line numbers\n3. WHEN a user uploads a .krx binary THEN the WASM module SHALL deserialize it using rkyv\n4. WHEN configuration exceeds 1MB THEN the system SHALL warn the user about potential performance impact\n5. WHEN configuration is loaded THEN the system SHALL validate it for correctness (no invalid key codes, no circular dependencies)\n\n### Requirement 3: Event Sequence Simulation\n\n**User Story:** As a user testing tap-hold timings, I want to simulate precise key press/release sequences with microsecond timestamps, so that I can verify my threshold settings are correct.\n\n#### Acceptance Criteria\n\n1. WHEN a user creates an event sequence THEN they SHALL be able to specify press/release events with timestamps in microseconds\n2. WHEN a user simulates a sequence THEN the WASM engine SHALL process events in timestamp order\n3. WHEN simulation completes THEN the system SHALL return the output events with latency statistics\n4. WHEN a sequence contains 1000 events THEN simulation SHALL complete in <100ms\n5. WHEN a user simulates a built-in scenario (e.g., \"tap-hold-under-threshold\") THEN the system SHALL generate the appropriate event sequence automatically\n\n### Requirement 4: Built-in Test Scenarios\n\n**User Story:** As a user learning KeyRx, I want pre-built test scenarios for common patterns (tap-hold, layer switching, modifiers), so that I can quickly verify my configuration handles standard cases.\n\n#### Acceptance Criteria\n\n1. WHEN a user selects \"Tap-Hold Under Threshold\" scenario THEN the system SHALL simulate a key press and release within the configured threshold\n2. WHEN a user selects \"Tap-Hold Over Threshold\" scenario THEN the system SHALL simulate a key press held beyond the threshold\n3. WHEN a user selects \"Layer Switch\" scenario THEN the system SHALL simulate layer activation and key presses on that layer\n4. WHEN a user selects \"Modifier Combination\" scenario THEN the system SHALL simulate modifier keys pressed in sequence\n5. WHEN a scenario completes THEN the system SHALL display the expected vs. actual output for comparison\n\n### Requirement 5: Simulation Output Visualization\n\n**User Story:** As a user debugging my configuration, I want to see each step of event processing (DFA state transitions, modifier state changes, layer activations), so that I can understand where my configuration behaves unexpectedly.\n\n#### Acceptance Criteria\n\n1. WHEN simulation runs THEN the system SHALL capture each DFA state transition\n2. WHEN simulation runs THEN the system SHALL capture modifier and lock state changes\n3. WHEN simulation runs THEN the system SHALL capture layer activation/deactivation events\n4. WHEN simulation completes THEN the UI SHALL display a timeline of state changes\n5. WHEN a user hovers over a timeline event THEN the UI SHALL show the full state at that moment (active modifiers, locks, layer)\n6. WHEN output events differ from input events THEN the UI SHALL highlight the differences\n\n### Requirement 6: Performance Monitoring\n\n**User Story:** As a performance-conscious user, I want to see latency statistics for simulated event processing, so that I can identify if my configuration has performance bottlenecks.\n\n#### Acceptance Criteria\n\n1. WHEN simulation completes THEN the system SHALL report min/avg/max/p95/p99 latency for event processing\n2. WHEN any event processing exceeds 5ms THEN the system SHALL flag it as a performance warning\n3. WHEN configuration has more than 100 layers THEN the system SHALL warn about potential lookup performance impact\n4. WHEN simulation processes 1000 events/second THEN the WASM module SHALL use <100MB memory\n\n### Requirement 7: Integration with Web UI Configuration Editor\n\n**User Story:** As a user editing my configuration in the web UI, I want to test my changes immediately without saving or reloading, so that I can iterate quickly.\n\n#### Acceptance Criteria\n\n1. WHEN a user edits a key mapping in the web UI THEN they SHALL see a \"Test Configuration\" button\n2. WHEN a user clicks \"Test Configuration\" THEN the system SHALL compile the current UI state to a configuration and load it into the WASM simulator\n3. WHEN a user creates a custom event sequence THEN the system SHALL save it for reuse\n4. WHEN a user runs simulation THEN the UI SHALL display results alongside the configuration editor\n5. WHEN simulation reveals an error THEN the UI SHALL highlight the problematic mapping\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**:\n  - WASM bindings isolated in keyrx_core/src/wasm.rs\n  - JavaScript API wrapper isolated in keyrx_ui/src/wasm/core.ts\n  - Simulation UI components isolated in keyrx_ui/src/components/Simulator/\n- **Modular Design**:\n  - WASM module exposes minimal API (load_config, simulate_events, get_state)\n  - No direct DOM manipulation in WASM (output via return values only)\n  - Simulation logic reuses existing keyrx_core::simulator module\n- **Dependency Management**:\n  - WASM build uses feature flags to exclude daemon-specific dependencies\n  - No web-sys or js-sys dependencies in core simulation logic\n  - UI depends on WASM module via TypeScript type definitions\n- **Clear Interfaces**:\n  - WASM API documented with JSDoc comments\n  - Event types defined in shared schema (Rust + TypeScript)\n  - Error types clearly distinguish parse errors, validation errors, and simulation errors\n\n### Performance\n\n- **WASM Module Size**: Optimized build SHALL be <10MB (gzipped)\n- **Initialization Time**: WASM module load + initialization SHALL complete in <500ms\n- **Simulation Latency**: 1000-event sequence SHALL simulate in <100ms\n- **Memory Usage**: WASM module SHALL use <100MB memory during simulation\n- **Configuration Load**: 1000-line Rhai config SHALL parse and compile in <200ms\n\n### Security\n\n- **Sandboxing**: WASM code runs in browser sandbox with no filesystem or network access\n- **Input Validation**: All user-provided configurations validated before simulation\n- **Memory Safety**: Rust's ownership system prevents buffer overflows in WASM\n- **No Eval**: Configuration parsing does NOT use JavaScript eval()\n\n### Reliability\n\n- **Error Handling**: WASM panics caught and converted to JavaScript exceptions\n- **Graceful Degradation**: If WASM fails to load, UI shows error message and disables simulation features\n- **Browser Compatibility**: WASM module SHALL work in Chrome 90+, Firefox 88+, Safari 15+, Edge 90+\n- **Deterministic**: Same configuration + same event sequence SHALL always produce identical output\n\n### Usability\n\n- **Discovery**: \"Test Configuration\" button prominently displayed in configuration editor\n- **Feedback**: Simulation results displayed within 1 second of clicking \"Run Simulation\"\n- **Error Messages**: Parse errors include line numbers and helpful suggestions\n- **Examples**: Web UI includes 5+ example configurations with pre-built test scenarios\n- **Documentation**: Inline help text explains how to create custom event sequences\n\n## Dependencies\n\n### Existing Infrastructure\n\nThis feature builds on existing KeyRx components:\n\n1. **keyrx_core** (no_std library):\n   - Already supports WASM (no_std compatible)\n   - Simulator module already implemented (keyrx_core/src/simulator.rs)\n   - rkyv serialization for .krx binaries\n   - DFA state machine and event processing\n\n2. **keyrx_compiler**:\n   - Rhai parser (can be adapted for WASM use)\n   - DFA generation logic (needed for Rhai → DFA compilation in browser)\n\n3. **keyrx_ui**:\n   - React components already set up\n   - Configuration editor UI exists\n   - Need to add Simulator panel and WASM integration\n\n### New Dependencies\n\n- **wasm-pack**: Build tool for Rust → WASM compilation\n- **wasm-bindgen**: Rust ↔ JavaScript interop\n- **serde-wasm-bindgen**: Serialize Rust types to JavaScript (optional, for complex return values)\n\n### Build Pipeline Changes\n\n- Add WASM build target to CI/CD (GitHub Actions)\n- Add `npm run build:wasm` script to compile keyrx_core to WASM\n- Integrate WASM build into UI build process (vite.config.ts)\n",
  "fileStats": {
    "size": 11056,
    "lines": 193,
    "lastModified": "2025-12-29T14:28:16.914Z"
  },
  "comments": []
}