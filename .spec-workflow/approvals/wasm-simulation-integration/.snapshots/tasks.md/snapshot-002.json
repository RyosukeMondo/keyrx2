{
  "id": "snapshot_1767019445483_io5cprjbv",
  "approvalId": "approval_1767019425064_80i74h9fp",
  "approvalTitle": "WASM Simulation Integration Tasks",
  "version": 2,
  "timestamp": "2025-12-29T14:44:05.483Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks Document\n\n## Phase 1: WASM Module Foundation\n\n- [ ] 1. Add WASM build configuration to keyrx_core/Cargo.toml\n  - File: keyrx_core/Cargo.toml\n  - Add `crate-type = [\"cdylib\", \"rlib\"]` for WASM compilation\n  - Add wasm-bindgen dependency with features\n  - Add serde-wasm-bindgen for JSON serialization\n  - Configure wasm feature flag to exclude daemon-specific dependencies\n  - Purpose: Enable keyrx_core to compile to WebAssembly target\n  - _Leverage: Existing keyrx_core dependencies (rkyv, serde, simulator.rs)_\n  - _Requirements: 1.1 (WASM Build Pipeline)_\n  - _Prompt: Role: Rust Build Engineer with expertise in Cargo configuration and WebAssembly compilation | Task: Configure keyrx_core/Cargo.toml to support WASM compilation following requirement 1.1, adding necessary dependencies (wasm-bindgen 0.2+, serde-wasm-bindgen 0.5+) and crate-type configuration for both cdylib (WASM) and rlib (native) targets | Restrictions: Do not modify existing dependencies, ensure WASM feature flag excludes daemon-specific code (evdev, uinput), maintain no_std compatibility | Success: Cargo.toml allows both native and WASM builds, wasm-pack build succeeds without errors, WASM module size <15MB unoptimized_\n\n- [ ] 2. Create WASM module entry point in keyrx_core/src/wasm.rs\n  - File: keyrx_core/src/wasm.rs\n  - Create module with wasm-bindgen annotations\n  - Set up panic hook for better error messages in browser console\n  - Implement ConfigHandle type (opaque reference to loaded configs)\n  - Create global CONFIG_STORE using once_cell for storing loaded configurations\n  - Purpose: Establish WASM module structure and handle configuration lifecycle\n  - _Leverage: keyrx_core/src/lib.rs (existing module exports), keyrx_core/src/config.rs (config structures)_\n  - _Requirements: 1.1 (WASM Build Pipeline), 2.1 (Configuration Loading)_\n  - _Prompt: Role: Rust WebAssembly Developer with expertise in wasm-bindgen and browser FFI | Task: Create WASM module entry point in keyrx_core/src/wasm.rs following requirements 1.1 and 2.1, implementing panic hook (console_error_panic_hook), ConfigHandle opaque type, and global CONFIG_STORE using once_cell::Lazy<Mutex<Vec<_>>> pattern | Restrictions: Must use #[wasm_bindgen] annotations correctly, ensure thread safety with proper locking, do not expose internal Rust types directly to JavaScript | Success: Module compiles to WASM, panic hook provides readable browser errors, ConfigHandle prevents direct memory access from JavaScript, CONFIG_STORE is thread-safe_\n\n- [ ] 3. Implement load_config function in keyrx_core/src/wasm.rs\n  - File: keyrx_core/src/wasm.rs (continue from task 2)\n  - Create #[wasm_bindgen] function: load_config(rhai_source: &str) -> Result<ConfigHandle, JsValue>\n  - Parse Rhai source using keyrx_compiler parser (feature-gated)\n  - Generate DFA using keyrx_compiler dfa_gen\n  - Generate MPHF using keyrx_compiler mphf_gen\n  - Store compiled config in CONFIG_STORE, return handle\n  - Purpose: Enable browser-side Rhai configuration compilation\n  - _Leverage: keyrx_compiler/src/parser.rs (Rhai parsing), keyrx_compiler/src/dfa_gen.rs (DFA generation), keyrx_compiler/src/mphf_gen.rs (MPHF generation)_\n  - _Requirements: 2.1 (Configuration Loading in WASM), 2.2-2.5 (Acceptance criteria)_\n  - _Prompt: Role: Rust Compiler Engineer with expertise in Rhai scripting and code generation | Task: Implement load_config function in keyrx_core/src/wasm.rs following requirements 2.1-2.5, reusing keyrx_compiler parser, dfa_gen, and mphf_gen modules to compile Rhai source to in-memory DFA and MPHF structures | Restrictions: Must validate Rhai syntax and return detailed parse errors with line numbers, limit configuration size to 1MB and warn if exceeded, ensure memory-safe storage in CONFIG_STORE | Success: Rhai configs compile correctly to DFA, parse errors include line numbers, compiled configs stored safely, ConfigHandle returned for valid inputs_\n\n- [ ] 4. Implement load_krx function in keyrx_core/src/wasm.rs\n  - File: keyrx_core/src/wasm.rs (continue from task 3)\n  - Create #[wasm_bindgen] function: load_krx(binary: &[u8]) -> Result<ConfigHandle, JsValue>\n  - Deserialize .krx binary using rkyv with validation\n  - Store deserialized config in CONFIG_STORE\n  - Purpose: Support loading pre-compiled .krx binaries in browser\n  - _Leverage: keyrx_core/src/config.rs (rkyv-serialized structures)_\n  - _Requirements: 2.3 (Configuration Loading - .krx support)_\n  - _Prompt: Role: Rust Serialization Expert with expertise in rkyv zero-copy deserialization | Task: Implement load_krx function in keyrx_core/src/wasm.rs following requirement 2.3, using rkyv to deserialize and validate .krx binary format with bytecheck validation | Restrictions: Must validate binary format before deserialization to prevent panics, limit binary size to 10MB, ensure zero-copy deserialization works in WASM linear memory | Success: Valid .krx binaries deserialize correctly, invalid binaries return clear error messages, deserialization is zero-copy and efficient_\n\n- [ ] 5. Implement simulate function in keyrx_core/src/wasm.rs\n  - File: keyrx_core/src/wasm.rs (continue from task 4)\n  - Create #[wasm_bindgen] function: simulate(config: ConfigHandle, events_json: &str) -> Result<JsValue, JsValue>\n  - Deserialize EventSequence from JSON using serde-wasm-bindgen\n  - Lookup config from CONFIG_STORE using handle\n  - Process events using keyrx_core::simulator module\n  - Track state changes (modifiers, locks, layers) during simulation\n  - Measure per-event latency in microseconds\n  - Return SimulationResult as JSON via serde-wasm-bindgen\n  - Purpose: Enable browser-based event simulation with detailed results\n  - _Leverage: keyrx_core/src/simulator.rs (event processing), keyrx_core/src/state.rs (state tracking)_\n  - _Requirements: 3.1-3.5 (Event Sequence Simulation), 5.1-5.6 (Simulation Output Visualization), 6.1-6.4 (Performance Monitoring)_\n  - _Prompt: Role: Rust Performance Engineer with expertise in event processing and benchmarking | Task: Implement simulate function in keyrx_core/src/wasm.rs following requirements 3.1-3.5, 5.1-5.6, and 6.1-6.4, using keyrx_core::simulator for event processing with microsecond-precision latency tracking and state change capture | Restrictions: Must complete 1000-event simulation in <100ms, validate ConfigHandle before use, serialize results to JSON without panics, track all DFA state transitions and modifier/lock changes | Success: Simulations run within latency requirements, state changes captured accurately, latency stats calculated correctly (min/avg/max/p95/p99), results serialize to well-formed JSON_\n\n- [ ] 6. Implement get_state function in keyrx_core/src/wasm.rs\n  - File: keyrx_core/src/wasm.rs (continue from task 5)\n  - Create #[wasm_bindgen] function: get_state(config: ConfigHandle) -> Result<JsValue, JsValue>\n  - Retrieve current simulation state (modifiers, locks, active layer)\n  - Return DaemonState as JSON matching daemon IPC format\n  - Purpose: Allow UI to query current state between simulations\n  - _Leverage: keyrx_core/src/state.rs (ExtendedState), keyrx_daemon/src/web/api.rs (DaemonState format)_\n  - _Requirements: 5.2 (State capture during simulation)_\n  - _Prompt: Role: Rust API Developer with expertise in state management and serialization | Task: Implement get_state function in keyrx_core/src/wasm.rs following requirement 5.2, returning current simulation state in same JSON format as daemon IPC (active modifiers, locks, active layer, raw 255-bit state vector) | Restrictions: Must validate ConfigHandle, match exact DaemonState JSON schema from daemon API, ensure state vector serialization is correct | Success: State returned matches daemon format exactly, includes all active modifiers/locks/layer, raw state vector is 255 bits_\n\n- [ ] 7. Add WASM module exports to keyrx_core/src/lib.rs\n  - File: keyrx_core/src/lib.rs\n  - Add conditional compilation: #[cfg(target_arch = \"wasm32\")] pub mod wasm;\n  - Ensure simulator module is public: pub mod simulator;\n  - Purpose: Make WASM module accessible when compiling for wasm32 target\n  - _Leverage: Existing keyrx_core/src/lib.rs module exports_\n  - _Requirements: 1.1 (WASM Build Pipeline)_\n  - _Prompt: Role: Rust Module Organization Expert | Task: Update keyrx_core/src/lib.rs to conditionally export WASM module for wasm32 target following requirement 1.1, ensuring simulator module is public for WASM reuse | Restrictions: Do not break existing native builds, only export wasm module for wasm32 target, maintain existing module visibility | Success: Native builds unaffected, WASM builds include wasm module, simulator module accessible from WASM code_\n\n## Phase 2: Build Pipeline & TypeScript Integration\n\n- [ ] 8. Add wasm-pack build script to keyrx_ui/package.json\n  - File: keyrx_ui/package.json\n  - Add npm script: \"build:wasm\": \"cd ../keyrx_core && wasm-pack build --target web --out-dir ../keyrx_ui/src/wasm/pkg\"\n  - Add npm script: \"dev:wasm\": \"npm run build:wasm && vite\"\n  - Add wasm-pack to devDependencies if needed\n  - Purpose: Automate WASM build as part of UI development workflow\n  - _Leverage: Existing keyrx_ui/package.json scripts (dev, build)_\n  - _Requirements: 1.1 (WASM Build Pipeline), 1.3 (WASM module JavaScript API)_\n  - _Prompt: Role: Frontend Build Engineer with expertise in npm scripts and WASM tooling | Task: Add wasm-pack build scripts to keyrx_ui/package.json following requirements 1.1 and 1.3, integrating WASM compilation into UI build workflow with output to src/wasm/pkg directory | Restrictions: Do not break existing build scripts, ensure wasm-pack is available or document installation, maintain build reproducibility | Success: npm run build:wasm compiles WASM successfully, output appears in keyrx_ui/src/wasm/pkg/, dev workflow includes WASM build_\n\n- [ ] 9. Configure Vite to support WASM in keyrx_ui/vite.config.ts\n  - File: keyrx_ui/vite.config.ts\n  - Add vite-plugin-wasm to plugins\n  - Add vite-plugin-top-level-await if needed\n  - Configure plugin to watch keyrx_core/src/ for changes\n  - Add custom plugin to trigger wasm-pack rebuild on Rust file changes\n  - Purpose: Enable HMR for WASM development and bundle WASM correctly\n  - _Leverage: Existing keyrx_ui/vite.config.ts plugins (react)_\n  - _Requirements: 1.1 (WASM Build Pipeline), Development workflow with HMR_\n  - _Prompt: Role: Frontend Build Engineer with expertise in Vite bundler and WASM integration | Task: Configure Vite in keyrx_ui/vite.config.ts to support WASM modules following requirement 1.1, adding vite-plugin-wasm and custom watch plugin for auto-rebuilding WASM on Rust file changes | Restrictions: Must maintain existing React HMR, ensure WASM loads asynchronously, do not break production builds | Success: WASM modules load in browser, HMR triggers on Rust changes (rebuilds WASM), production builds include optimized WASM_\n\n- [ ] 10. Create TypeScript API wrapper in keyrx_ui/src/wasm/core.ts\n  - File: keyrx_ui/src/wasm/core.ts\n  - Import generated WASM module from ./pkg/keyrx_core\n  - Create WasmCore class with init() method for WASM module initialization\n  - Wrap load_config, load_krx, simulate, get_state with type-safe Promise APIs\n  - Define TypeScript interfaces matching Rust types (EventSequence, SimulationResult, DaemonState, etc.)\n  - Add input validation before calling WASM functions\n  - Convert WASM errors to TypeScript Error objects with meaningful messages\n  - Purpose: Provide ergonomic, type-safe API for React components\n  - _Leverage: Generated TypeScript types from wasm-pack (keyrx_ui/src/wasm/pkg/)_\n  - _Requirements: 1.3 (WASM JavaScript API), 2.1-2.5 (Config loading), 3.1-3.5 (Simulation), Error handling scenarios_\n  - _Prompt: Role: TypeScript API Developer with expertise in WASM integration and async programming | Task: Create comprehensive TypeScript API wrapper in keyrx_ui/src/wasm/core.ts following requirements 1.3, 2.1-2.5, and 3.1-3.5, wrapping generated WASM module with Promise-based API, full type definitions, input validation, and error conversion | Restrictions: Must validate all inputs before calling WASM (non-empty strings, positive timestamps, valid key codes), convert WASM panics to TypeScript errors with stack traces, ensure async/await compatibility | Success: All WASM functions wrapped with Promise APIs, TypeScript types match Rust exactly, input validation prevents invalid WASM calls, errors are user-friendly and debuggable_\n\n- [ ] 11. Create built-in scenario generators in keyrx_ui/src/utils/scenarios.ts\n  - File: keyrx_ui/src/utils/scenarios.ts\n  - Implement generateTapHoldUnder(): EventSequence (tap within 200ms threshold)\n  - Implement generateTapHoldOver(): EventSequence (hold beyond 200ms threshold)\n  - Implement generateLayerSwitch(): EventSequence (activate layer, press key)\n  - Implement generateModifierCombo(): EventSequence (Shift+Ctrl+A sequence)\n  - Add configurable parameters (threshold, key codes, timing)\n  - Purpose: Provide ready-to-use test scenarios for common patterns\n  - _Leverage: EventSequence type from keyrx_ui/src/wasm/core.ts_\n  - _Requirements: 4.1-4.5 (Built-in Test Scenarios)_\n  - _Prompt: Role: Test Engineer with expertise in keyboard event simulation and timing-sensitive scenarios | Task: Implement built-in scenario generators in keyrx_ui/src/utils/scenarios.ts following requirements 4.1-4.5, creating realistic event sequences for tap-hold, layer switching, and modifier combinations with configurable timing | Restrictions: Use microsecond-precision timestamps, ensure scenarios match expected vs actual outputs specified in requirements, make timing configurable (threshold parameter) | Success: All scenarios generate valid EventSequence objects, tap-hold scenarios demonstrate threshold behavior correctly, layer and modifier scenarios test state changes_\n\n## Phase 3: React UI Components\n\n- [ ] 12. Create SimulatorPanel container component in keyrx_ui/src/components/Simulator/SimulatorPanel.tsx\n  - File: keyrx_ui/src/components/Simulator/SimulatorPanel.tsx\n  - Create main container component with layout (config loader, scenario selector, results display)\n  - Manage state: loaded config (ConfigHandle), simulation result, loading/error states\n  - Implement handleLoadConfig(rhaiSource: string) using WasmCore.loadConfig()\n  - Implement handleSimulate(eventSequence: EventSequence) using WasmCore.simulate()\n  - Purpose: Main entry point for simulation UI, coordinates child components\n  - _Leverage: keyrx_ui/src/wasm/core.ts (WasmCore API), existing DeviceList.tsx for styling patterns_\n  - _Requirements: 7.1-7.5 (Web UI Integration), 5.1-5.6 (Output Visualization)_\n  - _Prompt: Role: React Developer with expertise in component architecture and state management | Task: Create SimulatorPanel container component in keyrx_ui/src/components/Simulator/SimulatorPanel.tsx following requirements 7.1-7.5, managing config loading and simulation state with proper loading/error handling | Restrictions: Must handle all async operations with try/catch, show loading spinners during WASM calls, display errors clearly to user, follow existing component styling patterns | Success: Component renders correctly with all child components, config loading works, simulation executes and displays results, errors handled gracefully_\n\n- [ ] 13. Create ConfigLoader component in keyrx_ui/src/components/Simulator/ConfigLoader.tsx\n  - File: keyrx_ui/src/components/Simulator/ConfigLoader.tsx\n  - Create UI for loading Rhai configs (textarea input or file upload)\n  - Add \"Load Configuration\" button calling onLoad(rhaiSource: string) prop\n  - Display parse errors inline with line numbers if loading fails\n  - Purpose: Allow users to input or upload Rhai configurations for testing\n  - _Leverage: React useState, file input API_\n  - _Requirements: 2.1 (Configuration Loading), 2.2 (Parse errors with line numbers)_\n  - _Prompt: Role: React UI Developer with expertise in form handling and file uploads | Task: Create ConfigLoader component in keyrx_ui/src/components/Simulator/ConfigLoader.tsx following requirements 2.1-2.2, supporting both textarea input and file upload for Rhai configs with inline parse error display | Restrictions: Must validate file type (.rhai), limit file size to 1MB, highlight error line in textarea if parse error includes line number, maintain responsive UI during loading | Success: Users can paste or upload Rhai configs, parse errors show line numbers and helpful messages, file upload validates size and type_\n\n- [ ] 14. Create ScenarioSelector component in keyrx_ui/src/components/Simulator/ScenarioSelector.tsx\n  - File: keyrx_ui/src/components/Simulator/ScenarioSelector.tsx\n  - Create dropdown menu listing built-in scenarios (tap-hold-under, tap-hold-over, layer-switch, modifier-combo)\n  - Add \"Run Scenario\" button calling onSelect(eventSequence: EventSequence) prop\n  - Display scenario description when selected\n  - Purpose: Allow users to quickly test common patterns without creating custom sequences\n  - _Leverage: keyrx_ui/src/utils/scenarios.ts (built-in scenario generators)_\n  - _Requirements: 4.1-4.5 (Built-in Test Scenarios)_\n  - _Prompt: Role: React UI Developer with expertise in dropdown menus and user interactions | Task: Create ScenarioSelector component in keyrx_ui/src/components/Simulator/ScenarioSelector.tsx following requirements 4.1-4.5, providing dropdown of built-in scenarios with descriptions and \"Run\" button | Restrictions: Must call scenario generators from utils/scenarios.ts, show scenario description before running, disable button if no config loaded, maintain dropdown accessibility (keyboard navigation) | Success: All built-in scenarios selectable, descriptions are clear, scenarios execute correctly when selected_\n\n- [ ] 15. Create EventSequenceEditor component in keyrx_ui/src/components/Simulator/EventSequenceEditor.tsx\n  - File: keyrx_ui/src/components/Simulator/EventSequenceEditor.tsx\n  - Create UI for adding/removing events manually (key code, type press/release, timestamp)\n  - Display event list with edit/delete buttons\n  - Add \"Simulate Custom Sequence\" button calling onSubmit(eventSequence: EventSequence) prop\n  - Validate timestamps (positive, increasing order) and key codes before submission\n  - Purpose: Allow advanced users to create precise custom event sequences\n  - _Leverage: EventSequence type from keyrx_ui/src/wasm/core.ts_\n  - _Requirements: 3.1-3.5 (Event Sequence Simulation), User creates custom sequences_\n  - _Prompt: Role: React Form Developer with expertise in dynamic lists and validation | Task: Create EventSequenceEditor component in keyrx_ui/src/components/Simulator/EventSequenceEditor.tsx following requirements 3.1-3.5, providing UI for creating custom event sequences with add/remove/edit functionality and validation | Restrictions: Must validate timestamps are positive and in ascending order, validate key codes against known list, show validation errors inline, support keyboard shortcuts for adding events quickly | Success: Users can create custom event sequences, validation prevents invalid inputs, sequences execute correctly, UI is intuitive for precise timing control_\n\n- [ ] 16. Create SimulationResults component in keyrx_ui/src/components/Simulator/SimulationResults.tsx\n  - File: keyrx_ui/src/components/Simulator/SimulationResults.tsx\n  - Display timeline of simulation events (input events, state changes, output events)\n  - Visualize state changes (modifiers, locks, layers) with color-coded timeline\n  - Show input vs output comparison (highlight differences)\n  - Add hover tooltips showing full state at each event\n  - Purpose: Provide detailed visualization of simulation execution\n  - _Leverage: SimulationResult type from keyrx_ui/src/wasm/core.ts_\n  - _Requirements: 5.1-5.6 (Simulation Output Visualization)_\n  - _Prompt: Role: React Visualization Developer with expertise in timeline UI and data visualization | Task: Create SimulationResults component in keyrx_ui/src/components/Simulator/SimulationResults.tsx following requirements 5.1-5.6, rendering interactive timeline of events with state changes, input/output comparison, and hover tooltips | Restrictions: Must render timeline efficiently for 1000+ events (virtualization if needed), color-code state changes clearly (modifiers=blue, locks=orange, layers=green), highlight differences between input and output events, ensure timeline is horizontally scrollable | Success: Timeline renders all events clearly, state changes are visually distinct, hover shows full state details, input/output differences highlighted_\n\n- [ ] 17. Create LatencyStats component in keyrx_ui/src/components/Simulator/LatencyStats.tsx\n  - File: keyrx_ui/src/components/Simulator/LatencyStats.tsx\n  - Display latency statistics table (min, avg, max, p95, p99) in microseconds\n  - Show performance warnings if max > 5ms (red highlight)\n  - Add performance comparison vs requirements (<1ms target)\n  - Purpose: Show simulation performance metrics and warnings\n  - _Leverage: LatencyStats type from keyrx_ui/src/wasm/core.ts_\n  - _Requirements: 6.1-6.4 (Performance Monitoring)_\n  - _Prompt: Role: React Data Visualization Developer with expertise in performance metrics display | Task: Create LatencyStats component in keyrx_ui/src/components/Simulator/LatencyStats.tsx following requirements 6.1-6.4, displaying latency statistics with warnings for values exceeding thresholds | Restrictions: Must display all metrics (min/avg/max/p95/p99), highlight max in red if >5ms, show green checkmark if all <1ms, format values clearly (μs suffix), add tooltip explaining p95/p99 | Success: All latency metrics displayed correctly, warnings trigger at correct thresholds, users understand performance characteristics_\n\n- [ ] 18. Add SimulatorPanel route to keyrx_ui/src/App.tsx\n  - File: keyrx_ui/src/App.tsx\n  - Import SimulatorPanel component\n  - Add route: /simulator → SimulatorPanel\n  - Add navigation link to simulator in app header/sidebar\n  - Purpose: Make simulator accessible from main UI\n  - _Leverage: Existing keyrx_ui/src/App.tsx routing (if using react-router)_\n  - _Requirements: 7.1 (\"Test Configuration\" button in web UI)_\n  - _Prompt: Role: React Router Developer with expertise in application navigation | Task: Integrate SimulatorPanel into keyrx_ui/src/App.tsx following requirement 7.1, adding route and navigation link for simulator feature | Restrictions: Must preserve existing routes, follow existing navigation patterns, ensure simulator link is visible and accessible, add icon if other nav items have icons | Success: Simulator accessible via /simulator route, navigation link works, component renders correctly in app layout_\n\n## Phase 4: Integration & \"Test Configuration\" Button\n\n- [ ] 19. Create useSimulator React hook in keyrx_ui/src/hooks/useSimulator.ts\n  - File: keyrx_ui/src/hooks/useSimulator.ts\n  - Create custom hook wrapping WasmCore API with React state management\n  - Manage loading states, error states, and results\n  - Provide loadConfig, simulate, getState methods\n  - Add useEffect for WASM initialization\n  - Purpose: Provide reusable hook for simulator functionality across components\n  - _Leverage: keyrx_ui/src/wasm/core.ts (WasmCore API)_\n  - _Requirements: 7.1-7.5 (Web UI Integration)_\n  - _Prompt: Role: React Hooks Developer with expertise in custom hooks and state management | Task: Create useSimulator custom hook in keyrx_ui/src/hooks/useSimulator.ts following requirements 7.1-7.5, wrapping WasmCore with React state management for loading, errors, and results | Restrictions: Must initialize WASM in useEffect only once, handle cleanup on unmount, provide clear loading states for async operations, memoize callbacks with useCallback | Success: Hook provides type-safe API for loading configs and running simulations, loading states update correctly, errors are captured and exposed, hook can be used in multiple components_\n\n- [ ] 20. Add \"Test Configuration\" button to ConfigEditor (if exists)\n  - File: keyrx_ui/src/components/ConfigEditor.tsx (or wherever config editing happens)\n  - Add \"Test Configuration\" button next to save/apply buttons\n  - On click, navigate to /simulator with current config text as URL param or sessionStorage\n  - Purpose: Allow users to test configurations immediately from editor\n  - _Leverage: Existing ConfigEditor component (if it exists), useSimulator hook_\n  - _Requirements: 7.1-7.2 (\"Test Configuration\" button, compile UI state to config)_\n  - _Prompt: Role: React Integration Developer with expertise in component communication and navigation | Task: Add \"Test Configuration\" button to existing ConfigEditor component following requirements 7.1-7.2, passing current config text to simulator via URL params or sessionStorage | Restrictions: Must preserve editor state when navigating, ensure config text is passed correctly, do not break existing save functionality, add button in visible location | Success: Button appears in config editor, clicking navigates to simulator with config pre-loaded, original editor state preserved if user returns_\n\n- [ ] 21. Update SimulatorPanel to accept config from URL params or sessionStorage\n  - File: keyrx_ui/src/components/Simulator/SimulatorPanel.tsx (modify from task 12)\n  - Add useEffect to check URL params or sessionStorage for config text\n  - Auto-load config on mount if present\n  - Clear param/storage after loading\n  - Purpose: Support \"Test Configuration\" flow from config editor\n  - _Leverage: React useSearchParams or sessionStorage API_\n  - _Requirements: 7.2 (Compile current UI state to configuration)_\n  - _Prompt: Role: React State Management Developer with expertise in URL params and browser storage | Task: Enhance SimulatorPanel to accept config from URL params or sessionStorage following requirement 7.2, auto-loading config on mount if present | Restrictions: Must handle both URL params and sessionStorage (fallback), clear storage after loading to prevent stale data, show loading spinner during auto-load, handle errors gracefully | Success: Config auto-loads when passed from editor, storage cleared after use, UI indicates auto-loading, errors shown if config invalid_\n\n## Phase 5: Testing & Documentation\n\n- [ ] 22. Write unit tests for WASM module in keyrx_core/tests/wasm_tests.rs\n  - File: keyrx_core/tests/wasm_tests.rs\n  - Use wasm-bindgen-test for browser-based tests\n  - Test load_config with valid/invalid Rhai configs\n  - Test simulate with various event sequences\n  - Test error handling (invalid handles, parse errors)\n  - Purpose: Ensure WASM module functions correctly in browser environment\n  - _Leverage: wasm-bindgen-test framework_\n  - _Requirements: All WASM module requirements (1.1, 2.1-2.5, 3.1-3.5, etc.)_\n  - _Prompt: Role: Rust Test Engineer with expertise in WASM testing and wasm-bindgen-test | Task: Write comprehensive unit tests for WASM module in keyrx_core/tests/wasm_tests.rs covering all WASM functions (load_config, load_krx, simulate, get_state) with valid and invalid inputs | Restrictions: Must use wasm-bindgen-test framework, run tests in browser via wasm-pack test, test both success and error paths, ensure tests are deterministic | Success: All WASM functions tested, parse errors validated, simulation results verified, tests pass in headless browser (wasm-pack test --headless)_\n\n- [ ] 23. Write unit tests for TypeScript API wrapper in keyrx_ui/src/wasm/core.test.ts\n  - File: keyrx_ui/src/wasm/core.test.ts\n  - Use Vitest or Jest for TypeScript testing\n  - Mock WASM module responses\n  - Test WasmCore initialization, error conversion, input validation\n  - Purpose: Ensure TypeScript wrapper handles errors and validates inputs correctly\n  - _Leverage: Vitest/Jest mocking capabilities_\n  - _Requirements: Error handling scenarios from design doc_\n  - _Prompt: Role: TypeScript Test Engineer with expertise in mocking and async testing | Task: Write unit tests for WasmCore wrapper in keyrx_ui/src/wasm/core.test.ts, mocking WASM module to test error conversion, input validation, and Promise handling | Restrictions: Must mock WASM module completely (do not load actual WASM in tests), test all error scenarios (parse errors, invalid handles, panics), verify input validation catches invalid data | Success: All WasmCore methods tested with mocked WASM, error conversion verified, input validation prevents invalid calls, tests run quickly without WASM compilation_\n\n- [ ] 24. Write React component tests for Simulator UI in keyrx_ui/src/components/Simulator/*.test.tsx\n  - Files: keyrx_ui/src/components/Simulator/SimulatorPanel.test.tsx, EventSequenceEditor.test.tsx, SimulationResults.test.tsx, etc.\n  - Use React Testing Library for component testing\n  - Test user interactions (button clicks, form inputs)\n  - Mock useSimulator hook\n  - Purpose: Ensure React components render and behave correctly\n  - _Leverage: React Testing Library, Vitest_\n  - _Requirements: 5.1-5.6 (Output visualization), 7.1-7.5 (UI integration)_\n  - _Prompt: Role: React Test Engineer with expertise in React Testing Library and user interaction testing | Task: Write comprehensive component tests for all Simulator components following requirements 5.1-5.6 and 7.1-7.5, testing rendering, user interactions, and state management | Restrictions: Must mock useSimulator hook, test user flows (load config → select scenario → view results), verify timeline rendering and latency display, ensure accessibility (screen reader support) | Success: All components tested, user interactions verified, rendering tested with various data scenarios, tests run quickly with mocked dependencies_\n\n- [ ] 25. Write E2E test for full simulation workflow in keyrx_ui/tests/e2e/simulator.spec.ts\n  - File: keyrx_ui/tests/e2e/simulator.spec.ts\n  - Use Playwright or Cypress for E2E testing\n  - Test full user journey: navigate to simulator → load config → run scenario → verify results\n  - Test \"Test Configuration\" button flow from config editor\n  - Purpose: Validate complete simulation feature works end-to-end\n  - _Leverage: Playwright/Cypress framework_\n  - _Requirements: All requirements (end-to-end user scenarios)_\n  - _Prompt: Role: QA Automation Engineer with expertise in E2E testing and Playwright/Cypress | Task: Write end-to-end test for full simulation workflow in keyrx_ui/tests/e2e/simulator.spec.ts, testing complete user journey from config loading to result visualization | Restrictions: Must test real WASM module (not mocked), verify timeline rendering, check latency stats display, test \"Test Configuration\" button from editor, ensure tests run in CI headless mode | Success: E2E test covers full user workflow, WASM loads and executes correctly, results display as expected, test runs reliably in CI pipeline_\n\n- [ ] 26. Optimize WASM module size in keyrx_core/Cargo.toml\n  - File: keyrx_core/Cargo.toml (modify from task 1)\n  - Add release profile optimizations: opt-level = \"z\", lto = true, codegen-units = 1\n  - Configure wasm-opt in package.json build script (-Oz flag)\n  - Add code splitting if possible (split scenarios into separate WASM)\n  - Purpose: Reduce WASM module size to meet <10MB requirement\n  - _Leverage: Cargo release profile, wasm-opt from Binaryen_\n  - _Requirements: 1.1 (WASM module <10MB), 1.2 (Initialization <500ms)_\n  - _Prompt: Role: Rust Performance Engineer with expertise in WASM optimization and binary size reduction | Task: Optimize WASM module size in keyrx_core/Cargo.toml and build scripts following requirements 1.1-1.2, achieving <10MB optimized build with <500ms initialization | Restrictions: Must maintain functionality while reducing size, use opt-level=\"z\" and LTO for release builds, run wasm-opt with -Oz flag post-build, measure and document size reduction | Success: Optimized WASM build <10MB (ideally <6MB), gzipped size <2MB, initialization completes in <500ms, functionality unchanged_\n\n- [ ] 27. Add WASM build to CI/CD in .github/workflows/wasm.yml\n  - File: .github/workflows/wasm.yml (new file)\n  - Set up GitHub Actions workflow for WASM builds\n  - Install wasm-pack and Rust wasm32 target\n  - Build WASM module and verify size <10MB\n  - Run wasm-bindgen-test in headless browser\n  - Upload WASM binary as artifact\n  - Purpose: Ensure WASM builds successfully in CI and meets size requirements\n  - _Leverage: Existing GitHub Actions workflows_\n  - _Requirements: 1.1 (WASM Build Pipeline), CI integration_\n  - _Prompt: Role: DevOps Engineer with expertise in GitHub Actions and Rust CI/CD | Task: Create WASM build workflow in .github/workflows/wasm.yml, installing dependencies, building WASM, verifying size, and running browser tests | Restrictions: Must fail build if WASM >10MB, run wasm-pack test in headless Chrome, cache Rust dependencies for faster builds, run on push and pull requests | Success: WASM builds automatically on push/PR, size verified (<10MB), browser tests run and pass, artifacts uploaded for debugging_\n\n- [ ] 28. Create WASM Simulation documentation in docs/wasm-simulation.md\n  - File: docs/wasm-simulation.md (new file)\n  - Document how to use simulator in web UI\n  - Explain built-in scenarios and custom event sequences\n  - Provide examples of common testing patterns\n  - Document WASM API for advanced users\n  - Purpose: Help users understand and use the simulation feature\n  - _Leverage: Design document and requirements_\n  - _Requirements: All requirements (user-facing documentation)_\n  - _Prompt: Role: Technical Writer with expertise in user documentation and software tutorials | Task: Create comprehensive documentation for WASM simulation feature in docs/wasm-simulation.md, explaining usage, scenarios, API, and examples for both beginners and advanced users | Restrictions: Must include screenshots or diagrams, provide step-by-step tutorials, explain all built-in scenarios, document common troubleshooting issues, maintain consistent formatting with existing docs | Success: Documentation is clear and comprehensive, beginners can follow tutorials successfully, advanced users understand API details, troubleshooting section addresses common issues_\n\n## Phase 6: Final Integration & Polish\n\n- [ ] 29. Add keyboard shortcuts to EventSequenceEditor\n  - File: keyrx_ui/src/components/Simulator/EventSequenceEditor.tsx (modify from task 15)\n  - Add Ctrl+Enter to add event quickly\n  - Add Delete key to remove selected event\n  - Add arrow keys for timestamp adjustment\n  - Purpose: Improve UX for creating precise event sequences\n  - _Leverage: React keyboard event handlers_\n  - _Requirements: Usability (user experience enhancements)_\n  - _Prompt: Role: UX Engineer with expertise in keyboard interactions and accessibility | Task: Add keyboard shortcuts to EventSequenceEditor following usability best practices, implementing Ctrl+Enter (add event), Delete (remove), arrow keys (adjust timing) | Restrictions: Must not conflict with browser shortcuts, ensure accessibility (screen reader compatible), provide visual feedback for shortcuts, document shortcuts in UI tooltip or help text | Success: Shortcuts work reliably, improve editing speed, accessible to keyboard-only users, shortcuts documented in UI_\n\n- [ ] 30. Add export/import for custom event sequences in EventSequenceEditor\n  - File: keyrx_ui/src/components/Simulator/EventSequenceEditor.tsx (modify from task 15)\n  - Add \"Export Sequence\" button (downloads JSON file)\n  - Add \"Import Sequence\" file upload (loads JSON)\n  - Validate imported JSON format\n  - Purpose: Allow users to save and share custom test sequences\n  - _Leverage: File download/upload APIs, EventSequence type_\n  - _Requirements: Future enhancement (shared scenarios)_\n  - _Prompt: Role: Full-stack Developer with expertise in file I/O and JSON serialization | Task: Add export/import functionality to EventSequenceEditor for saving and loading custom event sequences as JSON files | Restrictions: Must validate imported JSON schema, limit file size to 1MB, provide clear error messages for invalid files, use EventSequence type for validation | Success: Users can export sequences as JSON, import works with validation, files are human-readable JSON, invalid imports show helpful errors_\n\n- [ ] 31. Add visualization toggle for timeline detail level in SimulationResults\n  - File: keyrx_ui/src/components/Simulator/SimulationResults.tsx (modify from task 16)\n  - Add toggle: \"Show State Changes\" (on by default)\n  - Add toggle: \"Show All Events\" vs \"Show Differences Only\"\n  - Optimize rendering for large simulations (>1000 events)\n  - Purpose: Improve performance and clarity for large simulations\n  - _Leverage: React virtualization libraries (react-window) if needed_\n  - _Requirements: Performance (render 1000+ events efficiently)_\n  - _Prompt: Role: React Performance Engineer with expertise in virtualization and large data rendering | Task: Add visualization controls to SimulationResults for toggling timeline detail level, implementing efficient rendering for 1000+ events using virtualization if needed | Restrictions: Must maintain 60fps scrolling for 1000+ events, use react-window or similar for virtualization, preserve all data (just toggle visibility), ensure toggles are clearly labeled | Success: Timeline renders smoothly with 1000+ events, toggles reduce visual clutter, virtualization implemented if needed, performance meets 60fps target_\n\n- [ ] 32. Final integration testing and bug fixes\n  - Files: Various (bug fixes as needed)\n  - Test all components together in production build\n  - Fix any integration issues discovered\n  - Verify performance requirements met (<100ms for 1000 events, <10MB WASM)\n  - Test in multiple browsers (Chrome, Firefox, Safari)\n  - Purpose: Ensure complete feature works reliably in production\n  - _Leverage: All implemented components_\n  - _Requirements: All requirements (final verification)_\n  - _Prompt: Role: Senior QA Engineer with expertise in integration testing and cross-browser compatibility | Task: Perform comprehensive integration testing of complete WASM simulation feature, identifying and fixing bugs, verifying performance requirements, and testing cross-browser compatibility | Restrictions: Must test in Chrome, Firefox, and Safari, verify all performance requirements (latency, WASM size, initialization time), fix all critical bugs before completion, document any known limitations | Success: Feature works reliably in all target browsers, all performance requirements met, no critical bugs remain, known limitations documented_\n",
  "fileStats": {
    "size": 38501,
    "lines": 355,
    "lastModified": "2025-12-29T14:43:37.751Z"
  },
  "comments": []
}