keyrx：Rustを用いた超低遅延・決定論的入力再構成システムのアーキテクチャ詳細報告1. 序論：入力システムのパラダイムシフトと設計哲学1.1 背景と現状の課題コンピュータ入力のカスタマイズ、すなわちキーボードリマッピングの領域は、長らく二つの極端なアプローチに分断されてきました。一方には、QMK Firmware 1 に代表される、マイクロコントローラ（MCU）上で動作するファームウェアレベルのソリューションが存在します。これらは極めて低いレイテンシと高い信頼性を誇りますが、特定のハードウェアに依存し、再設定にはコンパイルとフラッシュ書き込みという高い障壁を伴います。もう一方には、オペレーティングシステムのユーザースペースで動作するソフトウェアソリューション（AutoHotKeyやKarabiner-Elementsなど）があります。これらは柔軟性が高い反面、OSのスケジューラの影響を受けやすく、ガベージコレクションやインタープリタのオーバーヘッドにより、プロフェッショナルな用途や競技レベルのゲーミングに求められる「1ms（ミリ秒）以下の確定的なレイテンシ」を保証することが困難でした 2。本プロジェクト「keyrx」は、これら両者の利点を統合し、欠点を排除することを目的としています。Rust言語のゼロコスト抽象化とメモリ安全性を活用し、システムプログラミングの領域でOSフック（Windows Low-Level Hooks, Linux input subsystem/evdev）を直接操作することで、ソフトウェアでありながらファームウェア並みのパフォーマンスを実現します。1.2 「AI Coding Agent First」という設計哲学keyrxの最も特異かつ核心的な要件は、「AI Coding Agent First」という設計哲学です。これは、単にAIによってコードが書かれることを意味するのではなく、AIエージェントが自律的に構成を検証・修正・展開できるシステムアーキテクチャであることを要求します。従来のソフトウェア開発、特にGUIを伴うアプリケーションでは、最終的な品質保証（QA）は人間による手動テスト（User Acceptance Testing: UAT）に依存していました。しかし、キーマップの組み合わせは無限に近く、特に「255の修飾キーと255のロックキー」という極めて複雑な要件 [User Query] を満たす場合、人間による網羅的なテストは不可能です。したがって、keyrxは以下の原則に基づいて設計されます：完全な決定論（Determinism）： 同じ入力シーケンスと構成に対して、システムは常にビット単位で同一の出力を生成しなければならない。これには時間の経過も含まれ、テスト環境では時間を仮想的に制御可能である必要があります。可観測性と制御性（Observability & Controllability）： GUIで行える全ての操作（設定の変更、プロファイルの切り替え、デバイスの特定）は、CLIまたはAPIを通じて機械可読な形式で実行・検証可能でなければなりません。モジュール間の厳格な契約： 構成ロジック（Rhaiスクリプト）と実行ロジック（Rustコア）は完全に分離され、コンパイル時に検証可能な中間表現（IR）を介してのみ結合されます。1.3 技術的目標：1msのレイテンシバジェット「1msのレイテンシ」という要件は、システム全体の設計に厳しい制約を課します。USBポーリングレートが一般的に1000Hz（1ms間隔）であることを考慮すると、ソフトウェア処理による遅延は可能な限りゼロに近づける必要があります。ユーザーが「遅延」を感じない、いわゆる透明性を確保するためには、処理パイプライン全体を100マイクロ秒（0.1ms）以下で完了させることが理想的です。このバジェット内訳は以下の通り計算されます：OSコンテキストスイッチ（フック呼び出し）： 5〜20µsデータデシリアライズ/メモリアクセス： < 1µs（ゼロコピー）キー検索（完全ハッシュ関数）： < 50ns状態遷移（DFA）： < 50ns出力生成（OSへのインジェクション）： < 1µsIPCオーバーヘッド（必要な場合）： 10〜50µsこの極限のパフォーマンスを達成するためには、ガベージコレクションを持つ言語やランタイムは排除され、動的なメモリ確保（ヒープアロケーション）さえもホットパス（実行頻度の高い経路）から排除する必要があります。2. システムアーキテクチャ概要keyrxのアーキテクチャは、構成フェーズ（コンパイル時）と実行フェーズ（ランタイム）を明確に分離することで、柔軟性とパフォーマンスの両立を図っています。2.1 高レベルコンポーネント構成システムは以下の4つの主要なクレート（Rustのライブラリ単位）で構成されます。keyrx_compiler（コンパイラ）：ユーザーが記述したRhaiスクリプト 4 を解析し、静的な「操作テーブル（Ops Table）」と「状態遷移機械（DFA）」を生成します。このプロセスは設定変更時にのみ実行され、ランタイムのレイテンシには影響しません。ここでRhaiの動的な柔軟性が、Rustの静的かつ高速なデータ構造へと「焼き固め」られます。keyrx_core（コアロジック）：no_std（標準ライブラリ非依存）で記述された純粋なロジックライブラリです。OSのAPIには一切依存せず、抽象化されたイベントストリームを入力とし、変換後のイベントストリームを出力します。この設計により、本コアはデーモン内でのネイティブ実行だけでなく、WASMとしてブラウザ内でのシミュレーション実行も可能にします 5。keyrx_daemon（デーモン）：各OS（Windows/Linux）に特化した常駐プロセスです。OS固有のフックAPI（Windows LL Hooks, Linux evdev）を管理し、keyrx_coreをホストします。コンパイル済みの設定ファイル（.krx）をメモリマップし、ゼロコピーで読み込みます 7。keyrx_ui（フロントエンド）：Reactベースのユーザーインターフェースです。WASMコンパイルされたkeyrx_coreを内包しており、ユーザーがスクリプトを編集すると、即座にブラウザ内でその挙動をサイクル単位で正確にシミュレーションできます 8。2.2 決定論的シリアライゼーションと検証AIエージェントがシステムを検証するためには、システムの状態が透明でなければなりません。keyrxはrkyvクレートを使用し、内部状態や設定データを決定論的なバイナリ形式にシリアライズします 7。これにより、ある設定Aと設定Bが機能的に同一であるかを、バイナリハッシュの比較のみで瞬時に判定できます。JSONやTOMLのようなテキスト形式と比較して、パース処理が不要であるため、デーモンの起動時間短縮にも寄与します。3. コアリマッピングエンジン：動的スクリプトから静的テーブルへの変換ユーザー要件にある「Rhaiスクリプトサポート」と「1msレイテンシ」は、一見すると相反する要求です。スクリプト言語のランタイム評価は、予測不可能な遅延を引き起こす要因となります。keyrxは、「コンパイル時評価（Compile-Time Evaluation）」という戦略を採用することで、この矛盾を解決します。3.1 RhaiによるDSL（ドメイン固有言語）の設計RhaiはRustとの親和性が高く、組み込み向けの軽量スクリプト言語です 10。keyrxでは、Rhaiを実行時のイベント処理に使用するのではなく、設定を記述するためのメタ言語として使用します。ユーザーは以下のようなスクリプトを記述します：Rust// user_config.rhai
let base = layer("base");

// 拡張修飾キーの定義（255個のサポート要件）
let hyper_mod = define_modifier(128); // ID 128の修飾キー定義

// 複雑なTap/Holdロジックの定義
let capslock = tap_hold(
    Key::Escape,       // タップ時
    Key::LCtrl,        // ホールド時
    200,               // タイムアウト(ms)
    Standard           // フレーバー
);

base.map(Key::CapsLock, capslock);
base.map_combo([Key::L, Key::K], Key::BackSpace); // 同時押し
このスクリプトは、keyrx_compilerによって一度だけ実行されます。Rhaiエンジン内の関数（map, tap_holdなど）は、実際のキー処理を行うのではなく、Rust側の構造体（ConfigBuilder）にデータを登録する副作用を持ちます。3.2 O(1) ルックアップのための完全ハッシュ関数（PHF）「O(1) ルックアップを保証するプリコンパイル済みテーブルメカニズム」の実装には、**最小完全ハッシュ関数（Minimal Perfect Hash Function: MPHF）**を採用します。通常のハッシュマップ（std::collections::HashMap）は、ハッシュ衝突の解決やリサイズ処理が必要であり、最悪計算量がO(n)になる可能性があります。また、キャッシュ効率も最適ではありません。一方、配列による直接参照は高速ですが、入力空間（スキャンコードやHID Usage ID）が疎（Sparse）である場合、巨大なメモリ領域を無駄にします（例：32ビットのキー空間全体を配列で持つことは現実的ではありません）。keyrxは、boomphfクレート 11 を利用して、コンパイル時にCHDアルゴリズムに基づいたMPHFを生成します。ハイブリッド・ルックアップ戦略ステージ1：MPHFによる圧縮（Sparse to Dense）入力：(ModifierState, ScanCode) の組み合わせ。処理：CHDアルゴリズムにより、入力値を 0 から N-1 （Nは定義されたリマップルールの総数）の範囲の整数インデックスに変換します。この変換は定数時間で行われ、衝突は発生しません。パフォーマンス：約25ns。ステージ2：アクションテーブル参照入力：ステージ1で得られたインデックス。処理：フラットな配列（Vec<Action>）への直接アクセス。パフォーマンス：L1キャッシュヒット時で1-2ns。この2段階方式により、リマップルールが10個でも10000個でも、ルックアップにかかる時間は一定（O(1)）かつ極小になります。3.3 拡張状態管理：255個の修飾キーとロックキーへの対応ユーザー要件にある「255の修飾キー（modifiers）と255のロックキー（lock keys）」は、標準的なOSやキーボードファームウェアの仕様（通常8個の修飾キー）を大きく逸脱しています。これを実現するために、keyrxは独自の仮想状態ベクトルを実装します。ビットセットによる高速状態判定単純なu8やu16のフラグでは510個の状態（255 modifiers + 255 locks）を表現できません。Rust標準のVec<bool>はメモリ効率とキャッシュ効率が悪いため、fixedbitsetあるいはSIMD最適化されたhi_sparse_bitset 13 のようなビットセット構造を採用します。内部構造：Ruststruct ExtendedState {
    modifiers: [u64; 4], // 256 bits for 255 modifiers
    locks: [u64; 4],     // 256 bits for 255 locks
}
処理ロジック：キー入力イベントが発生するたびに、MPHFによるルックアップを行う前に、現在のExtendedStateとの照合が必要になる場合があります。しかし、全ての入力に対して512ビットの全状態をキーとしてハッシュ計算を行うのは非効率です。解決策として、**「関連修飾キーマスク（Relevant Modifier Mask）」**を各キーごとにプリコンパイル時に計算します。コンパイラは、特定のキー（例：「A」キー）がどの修飾キー（例：Mod_1, Mod_120）に依存して挙動を変えるかを静的解析します。実行時には、「A」が押された際、そのキーに関連する修飾キービットのみをマスクして抽出し、それをルックアップキーの一部として使用します。これにより、255個の修飾キーが存在しても、計算コストを最小限に抑えつつO(1)の特性を維持します。4. OSインテグレーション：フックメカニズムの実装詳細WindowsとLinuxでは、キー入力を傍受・注入するメカニズムが根本的に異なります。keyrxはこれらをEventStreamトレイトとして抽象化し、共通のコアロジックに接続します。4.1 Windowsにおける実装：WH_KEYBOARD_LLとRaw Inputの融合WH_KEYBOARD_LLの制約と克服Windowsにおいて、カーネルドライバなしでグローバルにキー入力をフックする唯一の方法はSetWindowsHookExを用いたWH_KEYBOARD_LLです 2。しかし、このAPIには重大な制約があります。タイムアウトによるサイレント削除： フックプロシージャが規定の時間（LowLevelHooksTimeout、デフォルト約300msだが、システム負荷によってはより短くなる）以内に復帰しない場合、OSは安全のためにフックを解除します 15。対策： フックコールバック内では一切の重い処理を行いません。受け取ったKBDLLHOOKSTRUCTデータをロックフリーなリングバッファ（crossbeam-channelなど）にプッシュし、即座にCallNextHookEx（またはブロックする場合は非呼び出し）してリターンします。実際のロジック処理は、高優先度のワーカースレッドで非同期に行います。スレッドアフィニティ： フックはインストールしたスレッドのメッセージループに依存します。対策： 専用の「フック管理スレッド」を生成し、Windowsメッセージループ（GetMessage）専用として稼働させます。Raw Inputによるデバイス識別ユーザー要件にある「シリアルナンバー対応設定（serial-number aware config）」は、WH_KEYBOARD_LLだけでは実現できません。フックメッセージには、どのデバイスから入力があったかという情報が含まれていないためです。これを解決するために、Raw Input API (WM_INPUT) を併用します 16。アーキテクチャ： 「Block-All」戦略を採用します。WH_KEYBOARD_LLですべてのキー入力を一旦ブロックします。並行してWM_INPUTで入力を受信します。こちらにはデバイスハンドルが含まれており、GetRawInputDeviceInfoを通じてデバイスのシリアルナンバーやVID/PIDを特定できます 16。keyrxのコアロジックは、Raw Inputからの情報を元にリマップ計算を行います。結果をSendInput APIを用いてOSに注入します。このハイブリッドアプローチにより、特定のキーボード（例：左側のキーボード）のみリマップし、別のキーボード（例：右側のキーボード）はスルーするといった高度な制御が可能になります。4.2 Linuxにおける実装：evdevとuinputLinux環境では、よりモダンで低遅延なサブシステムであるevdevとuinputを利用します 18。入力キャプチャ (evdev)：/dev/input/event* ノードを監視し、ioctlのEVIOCGRABを使用してデバイスを独占的にグラブします。これにより、X11やWaylandなどの上位レイヤーへ元のイベントが到達するのをカーネルレベルで阻止します。これはWindowsのフックよりも確実かつ低オーバーヘッドです。デバイス情報はioctlのEVIOCGIDから取得でき、ベンダーID、プロダクトID、そしてシリアルナンバーへ直接アクセス可能です。これにより、Windowsのような複雑な回避策なしに要件を満たせます。出力注入 (uinput)：/dev/uinputを利用して仮想キーボードデバイスを作成します。リマップ後のイベントはこの仮想デバイスから発行されます。keyrxは、255個の修飾キーやロックキーを論理的に扱うために、仮想デバイスケーパビリティとして必要な全てのキーコードをOSに通知します。パーミッションと自動化AIエージェントによる自動展開を考慮し、Linux環境ではudevルールを自動生成するセットアップスクリプトを提供します。これにより、デーモンをroot権限で走らせるセキュリティリスクを回避し、特定のinputグループユーザーとして安全に実行可能な環境を構築します。以下の表は、両OSにおける実装戦略の比較です。特性Windows (Low-Level Hooks + Raw Input)Linux (evdev + uinput)入力捕捉WH_KEYBOARD_LL (同期フック)EVIOCGRAB (排他的アクセス)デバイス識別Raw Input APIとの併用が必須EVIOCGID (ネイティブサポート)出力注入SendInput API/dev/uinput 仮想デバイスレイテンシメッセージループとOSのスケジューリングに依存 (中)カーネル直結のため極小 (低)コンテキストユーザーセッションごとのフックが必要システムワイドまたはユーザーごとの設定が可能5. 高度な状態管理とTap-Holdロジック「Tap/Holdロジック」は、キーボードリマッパーにおける最大の技術的難所です。単純なタイマー処理では、高速なタイピング時に意図しない修飾キーの発動や、逆に入力の欠落（レイテンシ感）を引き起こします。5.1 決定性有限オートマトン（DFA）による定式化keyrxでは、Tap-Holdの挙動をアドホックなif-elseロジックではなく、形式手法に基づいた決定性有限オートマトン（DFA）として実装します 20。状態（States）： Idle, Pending(TimerID), Held, Tapped, Retroactive_Holdイベント（Events）： KeyDown, KeyUp, TimerExpire, Interrupted(OtherKey)遡及的状態修正（Retroactive State Correction）「レイテンシ1ms」という要件を満たしつつ、人間の感覚に自然な挙動を提供するために、遡及的状態修正モデルを導入します。QMKファームウェアの「Permissive Hold」や「Hold On Other Key Press」22 に相当する機能をさらに一般化します。例えば、ユーザーが「ModTap(A/Ctrl)」キーを押し、10ms後に「B」キーを押したとします（タップ判定時間200ms以内）。T=0ms: ModTap Down。状態はPendingへ遷移。タイマー開始。出力は保留。T=10ms: B Down。通常のロジックでは、ModTapがリリースされるまで判定を待ちます。これが「ラグ」の正体です。keyrxの遡及的ロジックでは、「他のキーが押された」というイベントがトリガーとなり、即座にModTapをHeld（Ctrl）状態に確定させます。システムは直ちに Ctrl Down -> B Down というシーケンスを出力します。このロジックにより、ユーザーは200msのタイムアウトを待つことなく、流れるような高速入力が可能になります。このDFAはコンパイル時に生成され、ランタイムでは単なる状態遷移テーブルの参照として実行されるため、計算コストは極小です。5.2 255のロックキーの実装修飾キーと同様に、255個のロックキー（Caps Lock, Num Lockのようなトグル状態）も要件に含まれています。これらはExtendedState構造体内のlocksビットセットで管理されます。ロジック： ロックキーイベントは、キーの押下（Press）そのものではなく、リマップエンジン内部のトグルロジックによって処理されます。レイヤーとの連動： 特定のロックキーがActiveな場合のみ有効になる「条件付きレイヤー」を定義可能です。これにより、例えば「Lock_1がオンの時はゲーミングモード（Windowsキー無効化）」といった複雑な状態管理が、Rhaiスクリプト上の1行の定義で実現し、かつO(1)のルックアップで実行されます。6. AI-First検証戦略：シミュレーションとテスト「AI Coding Agent First」の哲学に従い、手動テスト（UAT）を排除するための包括的な自動化検証基盤を構築します。6.1 プロパティベーステスト（PBT）とファジングAIエージェントは、特定の仕様に基づいてコードを生成しますが、そのエッジケース（境界条件）での挙動を保証するために、proptestなどのライブラリを用いたプロパティベーステスト（PBT）を採用します 23。不変条件（Invariants）の定義：「キーダウンイベントは、必ず対応するキーアップイベントと対になる（スタックキーの防止）」「いかなる入力シーケンスにおいても、内部バッファがオーバーフローしない」「決定論的リプレイが可能である（同じシード値の入力列は常に同じ結果を生む）」さらに、cargo-fuzz（libFuzzerベース）を用いて、無作為かつ異常なイベントストリーム（不正なスキャンコード、極端に短いタイムスタンプ間隔など）をkeyrx_coreに注入し、パニックや未定義動作が発生しないことを検証します 25。6.2 決定論的シミュレーションテスト（DST）並行処理や時間経過を含むロジック（Tap-Holdなど）のテストは、通常のユニットテストでは困難です（"Flaky"なテストになりがちです）。keyrxでは、時間を完全に仮想化・モック化する**決定論的シミュレーションテスト（DST）**基盤を導入します 26。仮想クロック： テストハーネスはOSのシステムクロックを使用せず、ステップ実行可能な仮想クロックを使用します。シナリオ実行：Rust// AIエージェントが生成可能なテストコード例
let mut sim = Simulator::new(config);
sim.press(Key::A, 0);       // T=0ms
sim.advance_time(150);      // 150ms経過
sim.release(Key::A, 150);   // T=150ms
assert_eq!(sim.output_events(), vec!); // 期待値の検証
このDST環境は、WASMを通じてフロントエンド上でも動作するため、ユーザー（またはAI）は設定変更の影響を即座に、かつ厳密に検証できます。7. フロントエンドとWASMインテグレーション7.1 React + WASMによるサイクル精度のシミュレーションReactで構築されるフロントエンド（keyrx_ui）は、単なる設定エディタではありません。Rustコア（keyrx_core）をwasm32-unknown-unknownターゲットにコンパイルしたWASMモジュールを内包しており、ブラウザ内でデーモンと完全に同一のロジックを動作させます 8。wasm-bindgenとserde-wasm-bindgen： Rustの構造体とJavaScriptオブジェクトの相互変換には、serde互換のバインディングを使用し、型安全性を維持しつつデータをやり取りします。Visualizer： ユーザーがキーを押すと、仮想キーボード上で状態遷移（Pending -> Heldなど）が色分けされてリアルタイムに可視化されます。これにより、Tap-Holdのタイムアウト設定などが直感的に理解可能になります。7.2 IPCプロトコルとデーモン制御フロントエンド（ElectronやTauri、あるいはローカルWebサーバー経由のブラウザ）とバックグラウンドデーモンの通信には、安全性とパフォーマンスを考慮したIPCを採用します。制御チャネル（gRPC / Named Pipes）： 設定のアップロード、プロファイルの切り替え、ステータス取得などの低頻度・高信頼性が求められる通信に使用。ストリームチャネル（Shared Memory Ring Buffer）： デバッグ目的で入力イベントのログをフロントエンドに流す場合、IPCのオーバーヘッドがメインループを阻害しないよう、ロックフリーな共有メモリ（memmap2クレート利用）を使用します 28。8. 結論と実装ロードマップ8.1 結論本報告書で詳述した「keyrx」のアーキテクチャは、従来のキーボードリマッパーの限界を打破するものです。Rhaiによる柔軟な記述力と、MPHF/DFAによるO(1)の高速実行性能を、コンパイル時評価という手法で融合しました。さらに、255個の拡張修飾キーという極端な要件に対しても、ビットセットとマスク最適化により現実的な解を提示しました。何より、「AI Coding Agent First」の哲学に基づき、手動テストを排除した検証可能なエコシステムを構築することで、将来的な機能拡張やメンテナンスの自動化を約束します。8.2 実装戦略（ロードマップ）フェーズ1：コアとコンパイラ（The Core）keyrx_core (no_std) の実装。DFAエンジンとビットセット状態管理。keyrx_compilerの実装。RhaiパーサーとMPHF生成ロジック。CLIベースのシミュレータによる論理検証。フェーズ2：OSレイヤー（The Integration）Linuxデーモンの実装 (evdev/uinput)。Windowsデーモンの実装 (WH_KEYBOARD_LL + Raw Input)。1msレイテンシの実測と最適化。フェーズ3：UIとエコシステム（The Experience）WASMコンパイルパイプラインの構築。Reactフロントエンドの実装。AIエージェント用APIの整備とE2Eテストスイートの完成。このロードマップに従い、keyrxは「入力の自由」を再定義するプラットフォームとして具現化されます。